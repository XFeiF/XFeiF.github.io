<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Make everyday count!</title>
  
  <subtitle>Everything will be ok!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.x-fei.me/"/>
  <updated>2018-09-17T06:47:45.350Z</updated>
  <id>http://blog.x-fei.me/</id>
  
  <author>
    <name>XFeiF</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode Challenge 🏆 Dynamic Programming Problems X 100 ⚡️</title>
    <link href="http://blog.x-fei.me/2018/09/16/LeetCode-Challenge-Dynamic-Programming-Problems-X-100/"/>
    <id>http://blog.x-fei.me/2018/09/16/LeetCode-Challenge-Dynamic-Programming-Problems-X-100/</id>
    <published>2018-09-15T16:00:00.000Z</published>
    <updated>2018-09-17T06:47:45.350Z</updated>
    
    <content type="html"><![CDATA[<p><center> LeetCode Challenge 🏆 </center></p><blockquote><p>挑战目标🎖: 100道DP题<br> <span>&nbsp;&nbsp;&nbsp;</span>时间<span>&nbsp;&nbsp;&nbsp;&nbsp;</span>🗓: <span>&nbsp;</span>70天 （2018-09-13 👉🏻 2018-11-15）<br> <span>&nbsp;&nbsp;&nbsp;</span>进度<span>&nbsp;&nbsp;&nbsp;&nbsp;</span>🛴: <span>&nbsp;</span>12/100<br> 成功奖励🍭: ██████████<br> 失败惩罚🙈: ██████████  </p></blockquote><p>Solved: 🥈🥉🥉<br><a id="more"></a></p><hr><h2 id="Day5"><a href="#Day5" class="headerlink" title="Day5"></a>Day5</h2><p><strong>Date: 18-09-17</strong>  </p><h3 id="357-M"><a href="#357-M" class="headerlink" title="357-M"></a>357-M</h3><p><a href="https://leetcode.com/problems/count-numbers-with-unique-digits/description/" target="_blank" rel="noopener">357. Count Numbers with Unique Digits</a>  </p><blockquote><p>Difficulty：★★☆☆☆<br>Beats: 69.17%<br>Time Complexity: O(n)<br>Remark: 简单题，可以总结为数学问题，这道题说明，状态不一定要直接解决我们的最终问题，它可以是最终答案的骨架。  </p></blockquote><p>一看就懂，直接放代码。<br>Code:  </p><pre><code class="py"><span class="comment">#     n = 1 : 10</span><span class="comment">#     n = 2 : 9 * 9      (1-9)|(0-9 except first Digit)</span><span class="comment">#     n = 3 : 9 * 9 * 8  (1-9)|(0-9 except first Digit) | (0-9 except first Digit))</span><span class="comment">#     ...   </span><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">countNumbersWithUniqueDigits</span><span class="params">(self, n)</span>:</span>        <span class="string">"""</span><span class="string">        :type n: int</span><span class="string">        :rtype: int</span><span class="string">        """</span>        <span class="keyword">if</span> n == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">1</span>        <span class="keyword">if</span> n == <span class="number">1</span>: <span class="keyword">return</span> <span class="number">10</span>        dp = [<span class="number">0</span>]*(n+<span class="number">1</span>)        dp[<span class="number">1</span>] = <span class="number">10</span>        dp[<span class="number">2</span>] = <span class="number">9</span>*<span class="number">9</span>        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>, n+<span class="number">1</span>):            dp[i] = dp[i<span class="number">-1</span>] * (<span class="number">10</span>-i+<span class="number">1</span>)        <span class="keyword">return</span> sum(dp)</code></pre><hr><h2 id="Day4"><a href="#Day4" class="headerlink" title="Day4"></a>Day4</h2><p><strong>Date: 18-09-16</strong>  </p><h3 id="714-M"><a href="#714-M" class="headerlink" title="714-M"></a>714-M</h3><p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/description/" target="_blank" rel="noopener">714. Best Time to Buy and Sell Stock with Transaction Fee</a>  </p><blockquote><p>Difficulty：★★★★☆<br>Beats: 44.97%<br>Time Complexity: O(n)<br>Remark: 比较难，什么状态，以及状态方程。我个人想不到需要两个状态方程来维护，所以看了很多题解。买卖这两个字很值得推敲。  </p></blockquote><p>Explanation:<br>有两个题解写的比较好，推荐一下。<br><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/discuss/136388" target="_blank" rel="noopener">精简的解释</a><br><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/discuss/75928/" target="_blank" rel="noopener">利用状态机，含图解，非本题</a><br><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/discuss/108870/" target="_blank" rel="noopener">针对买卖股票系列，总结十分全面</a>  </p><p>本题的关键就是要想清楚什么时候买、什么时候卖。这二者又取决于今天 买/卖 和明天 买/卖 有什么联系。  </p><p>买和卖之间的桥梁就是股票以及利润。  </p><p>以<code>1, 4, 2, 8, 4, 9</code>为例。<br>第0天，假设不买，则利润为<code>profit[0] = 0</code>；假设买了，持有<code>shares[0] = -1</code>。<br>第1天，根据第0天的两种状态：<br>今天卖还是不卖呢，可以卖手中持有的，如果卖，收益是 <code>tmp = shares[0] + nums[1] - fee</code>，这里结果是1，如果不卖，收益就是<code>profit[0]=0</code>，说明今天卖昨天买的可以有正收益，因此<code>profit[1] = max(tmp, profit[0])</code>；<br>那么今天适不适合买呢，如果买，就面临一个选择。因为要求不能持有多余一股，所以今天买了，昨天就不能买。因此，若今天买，需要付出<code>tmp = profits[0] - nums[1] = -4</code>，显然第0天买更划算，因此<code>shares[1] = max(tmp,  shares[0])</code>。<br>……<br>以此类推，可以理解为：  </p><blockquote><p><code>dp[i][0]</code>: arrive i, no shares at hand.<br><code>dp[i][1]</code>: arrive i, shares at hand.<br><code>dp[i][1] = max(dp[i-1][0] - nums[i], dp[i-1][1])</code>: buy at nums[i] or do nothing.<br><code>dp[i][0] = max(dp[i-1][1] + nums[i] - fee, dp[i-1][0])</code>: sell at nums[i] or do nothing.  </p></blockquote><p>Code:  </p><pre><code class="py"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices, fee)</span>:</span>        <span class="string">"""</span><span class="string">        :type prices: List[int]</span><span class="string">        :type fee: int</span><span class="string">        :rtype: int</span><span class="string">        """</span>        <span class="comment"># dp = [[0 for _ in range(2)] for _ in range(len(prices))]</span>        <span class="comment"># dp[0][0] = 0</span>        <span class="comment"># dp[0][1] = -prices[0]</span>        <span class="comment"># for i in range(1, len(prices)):</span>        <span class="comment">#     dp[i][1] = max([dp[i - 1][0] - prices[i], dp[i - 1][1]])</span>        <span class="comment">#     dp[i][0] = max([dp[i - 1][1] + prices[i] - fee, dp[i - 1][0]])</span>        <span class="comment"># print(dp)</span>        <span class="comment"># return dp[-1][0]</span>        profits = <span class="number">0</span>        shares = -prices[<span class="number">0</span>]        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(prices)):            tmp_shares = shares            shares = max(profits - prices[i], shares)            profits = max(tmp_shares + prices[i] - fee, profits)        <span class="keyword">return</span> profits</code></pre><hr><h3 id="647-M"><a href="#647-M" class="headerlink" title="647-M"></a>647-M</h3><p><a href="https://leetcode.com/problems/palindromic-substrings/description/" target="_blank" rel="noopener">647. Palindromic Substrings</a>  </p><blockquote><p>Difficulty：★★★☆☆<br>Beats: 29.16%<br>Time Complexity: O(n^2)<br>Remark: 关键还是要分析出相邻状态之间的关系。  </p></blockquote><p>Explanation:  </p><ul><li><p><em>Step1: 判断</em><br>满足重叠子问题、最优子结构性质。考虑如果某个串是回文串，那么它所临近的串应该如何判断呢？</p></li><li><p><em>Step2: 状态</em><br>直观一点，我们可以简单的认为状态是从<code>i</code>到<code>j</code>的子串是否是回文串，即<code>T[i][j]</code>是否是回文串。</p></li></ul><ul><li><em>Step3: 状态方程</em><br>假设现在<code>T[i][j]</code>是回文串，对于<code>s[j+1]</code>，基于回文串的性质，我们知道，如果在已有回文串的两边加上同样的字符，它依然是一个回文串，所以若<code>s[i-1]</code>和<code>s[j+1]</code>相等，就可以得出<code>T[i-1][j+1]</code>也是回文串。所以我们可以推导出状态方程：<br><code>if s[i]==s[j]: T[i][j] = T[i+1][j-1]</code>  </li></ul><ul><li><em>Step4: Tabulation or Memorizatio</em><br>本题我们的父问题需要多个子问题堆叠，比较简单的想法是自底向上，构建二维状态矩阵。  </li></ul><p>Code</p><pre><code class="py"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">countSubstrings</span><span class="params">(self, s)</span>:</span>        <span class="string">"""</span><span class="string">        :type s: str</span><span class="string">        :rtype: int</span><span class="string">        """</span>        <span class="keyword">if</span> <span class="keyword">not</span> s:            <span class="keyword">return</span> <span class="number">0</span>        n = len(s)        T = [[<span class="keyword">None</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]        res = <span class="number">0</span>        <span class="keyword">for</span> l <span class="keyword">in</span> range(n):            <span class="keyword">for</span> i <span class="keyword">in</span> range(n):                j = i+l                <span class="keyword">if</span> j &lt; n:                    <span class="keyword">if</span> i == j:                        T[i][j] = <span class="number">1</span>                        res += <span class="number">1</span>                        <span class="keyword">continue</span>                    <span class="keyword">if</span> s[i] == s[j]:                        <span class="keyword">if</span> j<span class="number">-1</span> &lt;= i+<span class="number">1</span> <span class="keyword">or</span> T[i+<span class="number">1</span>][j<span class="number">-1</span>] == <span class="number">1</span>:                             T[i][j] = <span class="number">1</span>                            res += <span class="number">1</span>        <span class="keyword">return</span> res</code></pre><hr><h3 id="877-M"><a href="#877-M" class="headerlink" title="877-M"></a>877-M</h3><p><a href="https://leetcode.com/problems/stone-game/discuss/" target="_blank" rel="noopener">877. Stone Game</a>  </p><blockquote><p>Difficulty：★★★☆☆<br>Beats: %<br>Time Complexity: O(n)<br>Remark: 可以说没有意义。  </p></blockquote><p>Alex永远不会输。</p><hr><h2 id="Day3"><a href="#Day3" class="headerlink" title="Day3"></a>Day3</h2><p><strong>Date: 180915</strong>  </p><h3 id="413-M"><a href="#413-M" class="headerlink" title="413-M"></a>413-M</h3><p><a href="https://leetcode.com/problems/arithmetic-slices/description/" target="_blank" rel="noopener">413. Arithmetic Slices</a>  </p><blockquote><p>Difficulty：★★★☆☆<br>Beats: 97.54%<br>Time Complexity: O(n)<br>Remark: 有几个点需要注意一下，按照DP的解题思路，想通了注意点就ok了。  </p></blockquote><p>Explanation:  </p><ul><li><p><em>Step1: 判断</em><br>满足重叠子问题、最优子结构性质。即如果某个位置与之前连续的若干个元素满足题意，那么其下一个位置是否满足呢？  </p></li><li><p><em>Step2: 状态</em><br>假设<code>A[i]</code>与之前若干个连续元素满足arithmetic slices的性质 (i&gt;=2)，我们将之前的满足条件的连续元素存到数组中。<br>那么元素<code>A[i+1]</code>是否满足，只需要比较它和它之前的两个元素即可。<br>如果<code>A[i+1]</code>满足，会多出多少个满足条件的arithmetic slices呢？<br>如果<code>A[i+1]</code>不满足，又要怎么算呢？</p></li></ul><ul><li><p><em>Step3: 状态方程</em><br>接上面的状态分析。<br>举个简单的例子，<code>1,3,5,7</code>是满足性质的一个slice，判断元素<code>9</code>，<code>9-7==7-5</code>，<br>那么对于<code>1,3,5,7,9</code>而言，因为它整体是满足条件的，所有以<code>9</code>结尾的所有至少3个连续元素都可以满足题目条件，<br>即<code>3,5,7,9</code>，<code>5,7,9</code>均满足，整理一下：<br><pre><br>1,3,5,7,9<br>3,5,7,9<br>5,7,9<br></pre><br>所以当多出一个元素<code>9</code>满足条件的时候，就有多出<code>5-3+1</code>个元素。 </p><p>注意点，如果<code>A[i+1]</code>不满足，我们也不能从<code>A[i+1]</code>重新开始算，而是需要从<code>A[i]</code>开始重新算。  </p></li><li><p><em>Step4: Tabulation or Memorizatio</em>   </p></li></ul><p>Code:</p><pre><code class="py"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">numberOfArithmeticSlices</span><span class="params">(self, A)</span>:</span>        <span class="string">"""</span><span class="string">        :type A: List[int]</span><span class="string">        :rtype: int</span><span class="string">        """</span>        cur = []        res = <span class="number">0</span>        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(A)):            <span class="keyword">if</span> len(cur) &lt; <span class="number">2</span>:                cur.append(A[i])            <span class="keyword">else</span>:                <span class="keyword">if</span> A[i] - cur[<span class="number">-1</span>] == cur[<span class="number">-1</span>] - cur[<span class="number">-2</span>]:                    cur.append(A[i])                    res += len(cur) - <span class="number">3</span> + <span class="number">1</span>                <span class="keyword">else</span>:                    tmp = cur[<span class="number">-1</span>]                    cur = [tmp, A[i]]        <span class="keyword">return</span> res</code></pre><hr><h2 id="Day2"><a href="#Day2" class="headerlink" title="Day2"></a>Day2</h2><p><strong>Date: 18-09-14</strong>  </p><h3 id="338-M"><a href="#338-M" class="headerlink" title="338-M"></a>338-M</h3><p><a href="https://leetcode.com/problems/counting-bits/description/" target="_blank" rel="noopener">338. Counting Bits</a>  </p><blockquote><p>Difficulty：★★★☆☆<br>Beats: 63.94%<br>Time Complexity: O(n)<br>Remark: 考察二进制的时候，多向左移右移的方向考虑。  </p></blockquote><p>Explanation:  </p><ul><li><p><em>Step1: 判断</em><br>朝<code>O(n)</code>的时间复杂度方向考虑，肯定需要用到子问题的解，不然不太可能。  </p></li><li><p><em>Step2: 状态</em><br>状态自然是数<code>i</code>的二进制中包含1的个数<code>count[i]</code>。<br>难度是如何找寻它与子问题的关系。  </p></li><li><p><em>Step3: 状态方程</em><br><pre><br>0: 0000 0000   0<br>1: 0000 0001   1<br>2: 0000 0010   1<br>3: 0000 0011   2<br>4: 0000 0100   1<br>5: 0000 0101   2<br>6: 0000 0110   2<br>7: 0000 0111   3<br>8: 0000 1000   1<br></pre><br>观察<code>0-8</code>的二进制，会比较自然的朝左移右移的角度去想。一个数的二进制左移一位相当于翻倍，反之减小一般。奇数比较特别的地方在于左移的时候末尾补<code>0</code>，右移的时候原来末尾的<code>1</code>会丢失。基于这个想法，对于数<code>i</code>，在不考虑原本末位的情况下，我们不难想到右移后<code>i</code>与<code>i&gt;&gt;1</code>的二进制中含有相同个数的<code>1</code>。再加上末位可能有的<code>1</code>，就可以得到<code>i</code>中含有<code>1</code>的个数了。<br>得到状态方程：<code>count[i] = count[i&gt;&gt;1] + (i &amp; 1)</code></p></li><li><p><em>Step4: Tabulation or Memorizatio</em><br>两种方法都可以。  </p></li></ul><p>Code:</p><pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">countBits</span><span class="params">(self, num)</span>:</span>        <span class="string">"""</span><span class="string">        :type num: int</span><span class="string">        :rtype: List[int]</span><span class="string">        """</span>        array = [<span class="number">0</span>]*(num+<span class="number">1</span>)        <span class="keyword">for</span> i <span class="keyword">in</span> range(num+<span class="number">1</span>):            array[i] = array[i&gt;&gt;<span class="number">1</span>] + (i &amp; <span class="number">1</span>)         <span class="keyword">return</span> array</code></pre><hr><h3 id="053-E"><a href="#053-E" class="headerlink" title="053-E"></a>053-E</h3><p><a href="https://leetcode.com/problems/maximum-subarray/description/" target="_blank" rel="noopener">053 Maximum Subarray</a>  </p><blockquote><p>Difficulty：★★☆☆☆<br>Beats: 99.53%<br>Time Complexity: O(n)<br>Remark: <code>O(n^2)</code>是不行的，从解DP问题的一般思路入手，一步一步来。同样的Beats存在问题，以后除了低于30%的就不写了，另外两个数比较大小，python的<code>max</code>函数比直接比较要慢。  </p></blockquote><p>Explanation:  </p><ul><li><p><em>Step1: 判断</em><br>最大子串问题，属于DP问题。  </p></li><li><p><em>Step2: 状态</em><br>我们希望得到的<code>Maximum Subarray</code>，这个子串的最后一个元素可能在原数组中的任意位置，因此自然联想到用<strong>以<code>i</code>结尾的子串的最大和<code>res[i]</code></strong> 作为状态，当然，这个子串可能不是以<code>0</code>作为首元素。  </p></li><li><p><em>Step3: 状态方程</em><br>探索<code>res</code>的前后序列关系，如果<code>res[i-1]</code>是前<code>i-1</code>个元素的最大和，那么在第<code>i</code>个元素的位置，我们需要计算以它结尾的最大和，如果<code>res[i-1] &lt; 0</code>，那就没有累加的必要，反之，累加。即状态方程为：<br><code>res[i] = max(0, res[i-1]) + nums[i]</code><br>更新最大值。</p></li><li><p><em>Step4: Tabulation or Memorizatio</em><br>两种方法都可以，为了节约空间，我们只使用常数数量的空间。</p></li></ul><p>Code:</p><pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums)</span>:</span>        <span class="string">"""</span><span class="string">        :type nums: List[int]</span><span class="string">        :rtype: int</span><span class="string">        """</span>        res = cur = nums[<span class="number">0</span>]        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(nums)):            <span class="keyword">if</span> cur &lt;= <span class="number">0</span>:                cur = nums[i]            <span class="keyword">else</span>:                cur += nums[i]            <span class="keyword">if</span> cur &gt; res:                res = cur        <span class="keyword">return</span> res</code></pre><hr><h3 id="303-E"><a href="#303-E" class="headerlink" title="303-E"></a>303-E</h3><p><a href="https://leetcode.com/problems/range-sum-query-immutable/description/" target="_blank" rel="noopener">303. Range Sum Query - Immutable</a>  </p><blockquote><p>Difficulty：★☆☆☆☆<br>Beats: 87.5%<br>Time Complexity: O(n)<br>Remark: 简单题，基于一个简单的发现。同样的Beats存在问题。  </p></blockquote><p>Explanation:  </p><ol><li><p><em>Step1: 判断</em><br>求从位置i到位置j的值的和，i和j任意，具有重叠子问题、最优子结构两个性质。  </p></li><li><p><em>Step2: 状态</em><br>如果暴力把所有的i,j都算一遍，那么无论时间还是空间复杂度都会很高。<br>换个思路，我们算一下从0到1，两个数的和<code>sum[1]</code>是<code>nums[0]+nums[1]</code>，<br>从0到2的和<code>sum[2]</code>是<code>nums[0] + nums[1] + nums[2]</code>，<br>从0到3的和<code>sum[3]</code>是<code>nums[0] + nums[1] + nums[2] + nums[3]</code>。<br>我们发现从0开始，加到<code>i-1</code>的和是<code>sum[i-1]</code>，到<code>i</code>的时候，只需要在<code>sum[i-1]</code>的基础上加上<code>nums[i]</code>，<br>在<code>sum[i-2]</code>的基础上加上<code>nums[i-1] + nums[i]</code>……  </p></li><li><p><em>Step3: 状态方程</em><br>那么我们的状态就可以设置为从0到i的和是<code>sum[i]</code>。<br>从<code>i</code>到<code>j</code>的话，<code>sum[j]</code>就等于<code>sum[i] + nums[i+1] + ... + nums[j]</code>。<br>从而得到<code>res[i,j] = sum[j] - sum[i]</code>。</p></li><li><p><em>Step4: Tabulation or Memorizatio</em><br>根据题目的设置，可以选用<code>list</code>或者<code>dict</code>。</p></li></ol><p>Code:</p><pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, nums)</span>:</span>        <span class="string">"""</span><span class="string">        :type nums: List[int]</span><span class="string">        """</span>        self.val = {<span class="number">-1</span>:<span class="number">0</span>}        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):            self.val[i] = self.val[i<span class="number">-1</span>] + nums[i]    <span class="function"><span class="keyword">def</span> <span class="title">sumRange</span><span class="params">(self, i, j)</span>:</span>        <span class="string">"""</span><span class="string">        :type i: int</span><span class="string">        :type j: int</span><span class="string">        :rtype: int</span><span class="string">        """</span>        <span class="keyword">return</span> self.val[j] - self.val[i<span class="number">-1</span>]</code></pre><hr>  <h3 id="198-E"><a href="#198-E" class="headerlink" title="198-E"></a>198-E</h3><p><a href="https://leetcode.com/problems/house-robber/description/" target="_blank" rel="noopener">198. House Robber</a>  </p><blockquote><p>Difficulty：★☆☆☆☆<br>Beats: 50% ? 100%<br>Time Complexity: O(n)<br>Remark: 同样是Python，时间复杂度相同，常数空间复杂度的解居然也只有50%，对比了其他人的解法，感觉leetcode的评判有点问题。  </p></blockquote><p>Explanation:  </p><ol><li><p><em>Step1: 判断</em><br>最大化数值，是DP问题  </p></li><li><p><em>Step2: 状态</em><br>在第i家可以获得的最大利润P[i]，不一定要取nums[i]</p></li><li><p><em>Step3: 状态方程</em><br>P[i] 和同序列之前的数有什么关系呢？<br>我们知道为了在第i家的时候，有两种选择：  </p><ul><li>一是偷取第i家，此时最大利润是<code>P[i-2] + nums[i]</code>  </li><li>二是不取第i家，此时最大利润就是<code>P[i-1]</code>  </li></ul><p>为了使得在第i家时的利润最大，我们取二者较大的。因此可以求得状态方程：<br><code>P[i] = max(P[i-1], P[i-2] + nums[i])</code>。</p></li><li><p><em>Step4: Tabulation or Memorizatio</em><br>这里结合<code>746-E</code>里的做法，可以节约空间，只使用常数空间复杂度。 </p></li></ol><p>Code:  </p><pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>        <span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, nums)</span>:</span>        <span class="string">"""</span><span class="string">        :type nums: List[int]</span><span class="string">        :rtype: int</span><span class="string">        """</span>        length = len(nums)        <span class="keyword">if</span> <span class="keyword">not</span> nums:             <span class="keyword">return</span> <span class="number">0</span>        <span class="keyword">if</span> length == <span class="number">1</span>:            <span class="keyword">return</span> nums[<span class="number">0</span>]        pre, cur = nums[<span class="number">0</span>], max(nums[<span class="number">0</span>], nums[<span class="number">1</span>])        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, length):            pre, cur = cur, max(cur, pre + nums[i])        <span class="keyword">return</span> cur</code></pre><hr><h2 id="Day1"><a href="#Day1" class="headerlink" title="Day1"></a>Day1</h2><p><strong>Date: 18-09-13</strong>  </p><h3 id="746-E"><a href="#746-E" class="headerlink" title="746-E"></a>746-E</h3><p><a href="https://leetcode.com/problems/min-cost-climbing-stairs/description/" target="_blank" rel="noopener">746. Min Cost Climbing Stairs</a>  </p><blockquote><p>Difficulty：★☆☆☆☆<br>Beats: 52% / 100%<br>Time Complexity: O(n)<br>Remark: 简单题，斐波那契的拓展，但是同样是BottomUp，用了O(n)的空间，和O(1)的空间是不同的！  </p></blockquote><p>Explanation:<br>参考070题，再加上cost的条件，注意要踏到最顶端，容易得出状态是<strong>迈上</strong>第i层的最小代价T[i]。<br>要踏上第<code>i</code>层，可能是从<code>i-1</code>或者<code>i-2</code>层上来的，要使得代价最小，那么二者取较小者。<br>因此有状态方程：<code>T[i] = min(T[i-1], T[i-2]) + cost[i]</code>。<br>时间复杂度都是<code>O(n)</code>，不难写出代码。下面分享的是两种用不同空间复杂度的代码。  </p><p><strong>空间复杂度 O(n)</strong> - 这是比较常规的做法  </p><pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">minCostClimbingStairs</span><span class="params">(self, cost)</span>:</span>        <span class="string">"""</span><span class="string">        :type cost: List[int]</span><span class="string">        :rtype: int</span><span class="string">        """</span>        <span class="keyword">if</span> <span class="keyword">not</span> cost:            <span class="keyword">return</span> <span class="number">0</span>        n = len(cost) + <span class="number">2</span>        T = [<span class="number">0</span>]*n        T[<span class="number">0</span>] = <span class="number">0</span>        T[<span class="number">1</span>] = <span class="number">0</span>        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n):            T[i] = min(T[i<span class="number">-1</span>], T[i<span class="number">-2</span>]) + cost[i<span class="number">-2</span>]        print(T)        <span class="keyword">return</span> min(T[n<span class="number">-1</span>], T[n<span class="number">-2</span>])</code></pre><p><strong>空间复杂度 O(1)</strong>   </p><pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">minCostClimbingStairs</span><span class="params">(self, cost)</span>:</span>        <span class="string">"""</span><span class="string">        :type cost: List[int]</span><span class="string">        :rtype: int</span><span class="string">        """</span>        <span class="keyword">if</span> <span class="keyword">not</span> cost:            <span class="keyword">return</span> <span class="number">0</span>        pre, cur = cost[<span class="number">0</span>], cost[<span class="number">1</span>]        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, len(cost)):            pre, cur = cur, min(pre, cur) + cost[i]        <span class="keyword">return</span> min(pre,cur)</code></pre><p>注意这里的<code>pre, cur = cur, min(pre, cur) + cost[i]</code>，其作用等价于：  </p><pre><code class="python">tmp = curcur = min(pre, cur) + cost[i]pre = tmp</code></pre><hr><h3 id="121-E"><a href="#121-E" class="headerlink" title="121-E"></a>121-E</h3><p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/" target="_blank" rel="noopener">121. Best Time to Buy and Sell Stock</a>  </p><blockquote><p>难易程度：★★☆☆☆<br>Beats: 73.94%<br>时间复杂度：O(n)<br>Remark: 简单题，有助于DP基本概念的理解。</p></blockquote><p>Explanation:<br>暴力：<br>每一天都和前面所有天的股价计算差值，保留最大值，那么时间复杂度就是 n的平方。不出意外就是TLE了。</p><p>问题在于如何确定哪天是股价最小的，再确定差价最高的。</p><p><strong>DP Steps</strong>  </p><ul><li><p><em>Step1: 判断</em><br>最大化利润，是DP问题  </p></li><li><p><em>Step2: 状态</em><br>第i天可以获得的最大利润P[i]（不一定是第[i]天卖出）</p></li><li><p><em>Step3: 状态方程</em><br>P[i] 和 P[i-1]有什么关系呢？<br>如果s[i] 比s[i-1]小，那么P[i] = P[i-1]，同时这两天最小价格至少会是s[i]，更新minPrice；<br>如果s[i] 比s[i-1]大，那么第s[i] - minPrice 是要比s[i-1] - minPrice大的，因此更新当前差价，和最大差价比较，如果比最大差价大，那么P[i] = nowMax</p></li><li><p><em>Step4: Tabulation or Memorizatio</em><br>Code:  </p><pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>  <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices)</span>:</span>      <span class="string">"""</span><span class="string">      :type prices: List[int]</span><span class="string">      :rtype: int</span><span class="string">      """</span>      <span class="keyword">if</span> <span class="keyword">not</span> prices:          <span class="keyword">return</span> <span class="number">0</span>      n = len(prices)      T = [<span class="number">0</span>]      minPrice = prices[<span class="number">0</span>]      maxPrice = T[<span class="number">0</span>]      <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):          <span class="keyword">if</span> prices[i] &lt; prices[i<span class="number">-1</span>]:              T.append(T[i<span class="number">-1</span>])              minPrice = prices[i] <span class="keyword">if</span> prices[i] &lt; minPrice <span class="keyword">else</span> minPrice          <span class="keyword">else</span>:              cur = prices[i] - minPrice              maxPrice = cur <span class="keyword">if</span> cur &gt; maxPrice <span class="keyword">else</span> maxPrice              T.append(maxPrice)      <span class="keyword">return</span> T[n<span class="number">-1</span>]</code></pre></li></ul><!-- <hr style="border:none; border-top:1px dashed ; height:1px"/> --><hr><h3 id="070-E"><a href="#070-E" class="headerlink" title="070-E"></a>070-E</h3><p><a href="https://leetcode.com/problems/climbing-stairs/description/" target="_blank" rel="noopener">070. Climbing Stairs</a>  </p><blockquote><p>难易程度：★☆☆☆☆<br>TopDown Beats: 100%<br>BottomUp Beats: 45.20%<br>时间复杂度：O(n)<br>Remark: 简单题，理解TopDown和BottomUp概念，<a href="https://www.geeksforgeeks.org/tabulation-vs-memoizatation/" target="_blank" rel="noopener">区别</a>。  </p></blockquote><p>DP问题中有一些典型的情况。<br>本题属于其中一种，即斐波那契数列。<br>那么不难想到状态方程<code>T[n] = T[n-1] + T[n-2]</code>。  </p><p>假设我们没看出这是一个斐波那契问题，我们来推理看看。</p><p>(层数)：方式。解释<br> (1)： 1。只有一种方式<br> (2)： 2。两种方式，11，2。<br> (3)： 3。111，12，21。<br> (4)： 5。1111，112， 121，211，22。  </p><p>思考一下4层的情况，如果先迈出了一步，那么总的情况就是1(3)，括号里是剩下的总层数，3层的情况我们已经算过了，把3层的情况填到括号中，1(111)，1(12)，1(21)；同理如果先迈出两步，总的情况就是2(2)，(2)又有2种。那么(4)可以写成<code>(4) = 1(3) + 2(2)</code>。下面验证一下(5)。<br>(5) =&gt; 1(4)，2(3) =&gt; 1(1111，112， 121，211，22)，2(111，12，21)。  </p><p>这个时候我们就可以得出相同的结论了。</p><p>这道题的价值在于练习<code>TopDown</code> 和 <code>BottomUp</code> 两种方式。    </p><p><strong>Top Down</strong>  </p><pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(self, n)</span>:</span>        <span class="string">"""</span><span class="string">        :type n: int</span><span class="string">        :rtype: int</span><span class="string">        """</span>        f = [<span class="number">0</span>] * (n+<span class="number">1</span>)        f[<span class="number">0</span>] = f[<span class="number">1</span>] = <span class="number">1</span>        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n+<span class="number">1</span>):            f[i] = f[i<span class="number">-1</span>] + f[i<span class="number">-2</span>]        print(f)        <span class="keyword">return</span> f[n]</code></pre><p><strong>Bottom Up</strong></p><pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(self, n)</span>:</span>        <span class="string">"""</span><span class="string">        :type n: int</span><span class="string">        :rtype: int</span><span class="string">        """</span>        lookup = [<span class="keyword">None</span>]*(n+<span class="number">1</span>)        <span class="comment"># Memoization -&gt; Bottom Up</span>        <span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(n)</span>:</span>            <span class="keyword">if</span> n == <span class="number">0</span> <span class="keyword">or</span> n == <span class="number">1</span>:                lookup[n] = <span class="number">1</span>            <span class="keyword">if</span> lookup[n] <span class="keyword">is</span> <span class="keyword">None</span>:                lookup[n] = fib(n<span class="number">-1</span>) + fib(n<span class="number">-2</span>)            <span class="keyword">return</span> lookup[n]        res = fib(n)        <span class="comment"># print(lookup)</span>        <span class="keyword">return</span> res</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;center&gt; LeetCode Challenge 🏆 &lt;/center&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;挑战目标🎖: 100道DP题&lt;br&gt; &lt;span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;时间&lt;span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;🗓: &lt;span&gt;&amp;nbsp;&lt;/span&gt;70天 （2018-09-13 👉🏻 2018-11-15）&lt;br&gt; &lt;span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;进度&lt;span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;🛴: &lt;span&gt;&amp;nbsp;&lt;/span&gt;12/100&lt;br&gt; 成功奖励🍭: ██████████&lt;br&gt; 失败惩罚🙈: ██████████  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Solved: 🥈🥉🥉&lt;br&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="http://blog.x-fei.me/tags/leetcode/"/>
    
      <category term="dynamic programming" scheme="http://blog.x-fei.me/tags/dynamic-programming/"/>
    
      <category term="python" scheme="http://blog.x-fei.me/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>PyTorch Api Notes 📙</title>
    <link href="http://blog.x-fei.me/2018/09/13/PyTorch-Notes/"/>
    <id>http://blog.x-fei.me/2018/09/13/PyTorch-Notes/</id>
    <published>2018-09-12T17:14:38.000Z</published>
    <updated>2018-09-13T07:45:40.226Z</updated>
    
    <content type="html"><![CDATA[<p><center>Simple Api Notes ✍🏼 For Beginners！</center><br>记录并尝试解释一些常见的Api，并部分介绍它们的原理、实战运用。<br><a id="more"></a></p><h1 id="torch"><a href="#torch" class="headerlink" title="torch"></a>torch</h1><h2 id="Serialization"><a href="#Serialization" class="headerlink" title="Serialization"></a>Serialization</h2><h3 id="torch-save"><a href="#torch-save" class="headerlink" title="torch.save"></a>torch.save</h3><p><code>torch.save(obj, f, pickle_module=&lt;module ‘pickle’ from ‘/homes/alexandrov/.pyenv/versions/3.6.5/lib/python3.6/pickle.py’&gt;, pickle_protocol=2)</code> 存储对象到硬盘中。</p><h3 id="torch-load"><a href="#torch-load" class="headerlink" title="torch.load"></a>torch.load</h3><p><code>torch.load(f,map_location=None,pickle_module=&lt;module ‘pickle’ from ‘/homes/alexandrov/.pyenv/versions/3.6.5/lib/python3.6/pickle.py’&gt;)</code><br>从文件中加载由<code>torch.save()</code>方法存储的对象。<br>序列化存储调用。</p><h1 id="torch-nn"><a href="#torch-nn" class="headerlink" title="torch.nn"></a>torch.nn</h1><h2 id="Containers"><a href="#Containers" class="headerlink" title="Containers"></a>Containers</h2><h3 id="torch-nn-Module"><a href="#torch-nn-Module" class="headerlink" title="torch.nn.Module"></a>torch.nn.Module</h3><p>所有网络模型的基类，即所有自定义的网络都要继承该类。<br><code>Modules</code>可以包含其他<code>Modules</code>， 允许嵌套成树形结构。<br>当我们调用<code>xxmodel.cuda()</code>的时候，模型的参数也会转化为<code>cuda Tensor</code>。  </p><h4 id="cuda"><a href="#cuda" class="headerlink" title="cuda"></a>cuda</h4><p><code>cuda(device=None)</code><br>这个方法帮助我们把所有的模型参数和<code>buffers</code>转移到GPU。<br>注意，这会使得参数和<code>buffers</code>变成不同的对象（<code>cuda Tensor</code>）。所以如果<br>优化时模型存在于GPU上时，本方法需要 <strong>在构造优化器之前被调用</strong>。  </p><p>与之对应的有个方法<code>cpu()</code>。  </p><h4 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h4><p><code>eval()</code><br>使模型处于<code>evaluation</code>模式。 对特定的模块(层)有效，比如<code>Dropout</code>,<code>BatchNorm</code>等，<br>在遇到更具体的模块的时候注意它们的文档。  </p><h4 id="train"><a href="#train" class="headerlink" title="train"></a>train</h4><p><code>train()</code><br>使模型处于<code>training</code>模式，同<code>eval()</code>方法，对特点模块有效。</p><h4 id="forward"><a href="#forward" class="headerlink" title="forward"></a>forward</h4><p><code>forward(*input)</code><br>定义每次调用时的计算过程。 <strong>所有的子类都需要覆盖这个方法</strong>。  </p><h4 id="to"><a href="#to" class="headerlink" title="to"></a>to</h4><p><code>to(*args, **kwargs)</code><br>移动或者映射所有的参数、<code>buffers</code>。  </p><p>可以这么调用:  </p><ul><li><code>to(device=None, dtype=None, non_blocking=False)</code>  </li><li><code>to(dtype, non_blocking=False)</code>  </li><li><code>to(tensor, non_blocking=False)</code>  </li></ul><p>这里的<code>dtype</code>是此模块中浮点参数和缓冲区的所需浮点类型.  </p><h4 id="modules"><a href="#modules" class="headerlink" title="modules"></a>modules</h4><p><code>modules()</code><br>返回可以迭代模型所有模块的迭代器(<code>yields</code>)。  </p><h4 id="load-state-dict"><a href="#load-state-dict" class="headerlink" title="load_state_dict"></a>load_state_dict</h4><p><code>load_state_dict(state_dict,strict=True)</code><br>从<code>state_dict</code>中拷贝参数和缓冲区。<br>如果<code>strict</code>为真，那么<code>state_dict</code>就必须和模型<code>state_dict()</code>方法返回的key完全匹配。<br>这个方法可以用来调用<code>pretrain</code>的model。  </p><h4 id="state-dict"><a href="#state-dict" class="headerlink" title="state_dict"></a>state_dict</h4><p><code>state_dict(destination=None,prefix=&#39;&#39;,keep_vars=False)</code><br>返回包含模块完整状态的词典。<br>所有的参数和缓冲区都被包含进去。key对应参数和缓冲区的名字。</p><h4 id="named-modules"><a href="#named-modules" class="headerlink" title="named_modules"></a>named_modules</h4><p><code>named_modules(memo=None,prefix=&#39;&#39;)</code><br>返回网络中所有模块的迭代器<code>yields</code>，同时包含模块的名称以及模块本身。  </p><hr><h3 id="torch-nn-ModuleList-modules-None"><a href="#torch-nn-ModuleList-modules-None" class="headerlink" title="torch.nn.ModuleList(modules=None)"></a>torch.nn.ModuleList(modules=None)</h3><p>在<code>list</code>中持有若干子模块。<br>可以像python自带的<code>list</code>一样，调用下标。但是它包含的模块均是正确注册<br>过的，可以通过调用<code>modules</code>方法可视化。 </p><h4 id="append"><a href="#append" class="headerlink" title="append"></a>append</h4><p><code>append(module)</code><br>添加一个。  </p><h4 id="extend"><a href="#extend" class="headerlink" title="extend"></a>extend</h4><p><code>extend(modules)</code><br>添加多个。  </p><hr><h3 id="torch-nn-Sequential-args"><a href="#torch-nn-Sequential-args" class="headerlink" title="torch.nn.Sequential(*args)"></a>torch.nn.Sequential(*args)</h3><p>一个队列容器，模块传递进构造器的顺序就是它们添加到模型的顺序，因此一个有序的模块字典<code>OrderedDict</code>也可以传入构造器中。  </p><hr><h2 id="Pooling-layers"><a href="#Pooling-layers" class="headerlink" title="Pooling layers"></a>Pooling layers</h2><h3 id="AdaptiveMaxPool2d"><a href="#AdaptiveMaxPool2d" class="headerlink" title="AdaptiveMaxPool2d"></a>AdaptiveMaxPool2d</h3><p><code>torch.nn.AdaptiveMaxPool2d(output_size,return_indices=False)</code><br>在由多个输入平面组成的输入信号上应用2D自适应最大池化。<br>对于任何输入尺寸，输出的大小为H x W. 输出特征的数量等于输入平面的数量。  </p><p>参数：  </p><ul><li><code>output_size</code>- 目标输出尺寸。可以是一个<code>tuple</code>，也可以是单个值（表示宽和高相同）。<br>除了<code>int</code>也可以是<code>None</code>，代表输出和输入尺寸相同。  </li><li><code>return_indices</code>- 默认<code>False</code>。如果是<code>True</code>，和输出一起返回切片。对<code>nn.MaxUnpool2d</code>有用。  </li></ul><hr><h2 id="Normalization-layers"><a href="#Normalization-layers" class="headerlink" title="Normalization layers"></a>Normalization layers</h2><h3 id="BatchNorm2d"><a href="#BatchNorm2d" class="headerlink" title="BatchNorm2d"></a>BatchNorm2d</h3><p><code>BatchNorm2d(num_features, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</code><br>未完。。  </p><hr><h2 id="Non-linear-activations"><a href="#Non-linear-activations" class="headerlink" title="Non-linear activations"></a>Non-linear activations</h2><h3 id="ReLU"><a href="#ReLU" class="headerlink" title="ReLU"></a>ReLU</h3><ul><li>Input: (N,∗) where * means, any number of additional dimensions</li><li>Output: (N,∗), same shape as the input  </li></ul><hr><h2 id="Dropout-layers"><a href="#Dropout-layers" class="headerlink" title="Dropout layers"></a>Dropout layers</h2><h3 id="Dropout"><a href="#Dropout" class="headerlink" title="Dropout"></a>Dropout</h3><p><code>torch.nn.Dropout(p=0.5, inplace=False)</code><br>在训练期间，使用来自伯努利分布的样本以概率p随机地将输入张量的一些元素归零。 在每个前向传播中随机化零个元素。<br>此外，输出按1/(1-p)的比例缩放.  </p><ul><li>p – probability of an element to be zeroed. Default: 0.5</li><li>inplace – If set to True, will do this operation in-place. Default: False</li></ul><hr><h1 id="torch-nn-functional"><a href="#torch-nn-functional" class="headerlink" title="torch.nn.functional"></a>torch.nn.functional</h1><h2 id="Convolution-functions"><a href="#Convolution-functions" class="headerlink" title="Convolution functions"></a>Convolution functions</h2><h3 id="conv2d"><a href="#conv2d" class="headerlink" title="conv2d"></a>conv2d</h3><p><code>conv2d(input, weight, bias=None, stride=1, padding=0, dilation=1, groups=1) → Tensor</code>  </p><ul><li>input – 输入张量的形状 (minibatch×in_channels×iH×iW)  </li><li>weight – filters of shape (out_channels × (in_channels/groups) × kH × kW)  </li><li>bias – optional bias tensor of shape (out_channels). Default: None  </li><li>stride – 卷积核的步长. 可以是一个数，也可以是一个tuple (sH, sW). 默认为1  </li><li>padding – 输入边缘的隐式零填充，可以是一个数或者一个tuple (padH, padW). 默认为0  </li><li>dilation – 内核元素之间的间距. 可以是一个数或者一个tuple (dH, dW). 默认为1  </li><li>groups – split input into groups, in_channels should be divisible by the number of groups. Default: 1</li></ul><h2 id="Pooling-functions"><a href="#Pooling-functions" class="headerlink" title="Pooling functions"></a>Pooling functions</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;center&gt;Simple Api Notes ✍🏼 For Beginners！&lt;/center&gt;&lt;br&gt;记录并尝试解释一些常见的Api，并部分介绍它们的原理、实战运用。&lt;br&gt;
    
    </summary>
    
    
      <category term="PyTorch" scheme="http://blog.x-fei.me/tags/PyTorch/"/>
    
  </entry>
  
  <entry>
    <title>Lazy Tricks🙈</title>
    <link href="http://blog.x-fei.me/2018/08/26/Lazy-Tricks/"/>
    <id>http://blog.x-fei.me/2018/08/26/Lazy-Tricks/</id>
    <published>2018-08-26T05:43:31.000Z</published>
    <updated>2018-08-26T07:11:57.992Z</updated>
    
    <content type="html"><![CDATA[<p>🍻 高效率 <del>懒人</del> 养成Tricks！🍻<br><a id="more"></a><br>持续收集中～ 🛰  </p><p>抱歉，部分只提供建议，教程什么的，google不到算我输。</p><h2 id="工具-🔧"><a href="#工具-🔧" class="headerlink" title="工具 🔧"></a>工具 🔧</h2><h3 id="ubuntu-desktop-with-openssh-server"><a href="#ubuntu-desktop-with-openssh-server" class="headerlink" title="ubuntu desktop with openssh-server"></a>ubuntu desktop with openssh-server</h3><p>主力机还是自己的笔记本，实验室的 <del>laji</del> 主机怎么办？🐶<br>👇 👇 👇 👇<br>给你的Ubuntu桌面版主机安装<a href="https://help.ubuntu.com/lts/serverguide/openssh-server.html.en" target="_blank" rel="noopener"><code>openssh-server</code></a>，像访问服务器那样访问自己的主机吧！</p><h3 id="tmux"><a href="#tmux" class="headerlink" title="tmux"></a>tmux</h3><p>开启脚本的命令不能关！难道我的笔记本要一直放在实验室吗？🙊<br>怎么把命令挂在后台啊！太难了，学不会🙃<br><a href="https://hackernoon.com/a-gentle-introduction-to-tmux-8d784c404340" target="_blank" rel="noopener"><code>tmux</code></a>你值得拥有！不关机，不kill，关掉命令行都可以！<br>配合<a href="https://help.ubuntu.com/lts/serverguide/openssh-server.html.en" target="_blank" rel="noopener"><code>openssh-server</code></a>，主力机不动，ssh到ubuntu主机上，访问服务器，把脚本挂到tmux上。理论上可以随便玩。</p><h2 id="Tricks-🚲"><a href="#Tricks-🚲" class="headerlink" title="Tricks 🚲"></a>Tricks 🚲</h2><h3 id="shell脚本"><a href="#shell脚本" class="headerlink" title="shell脚本"></a>shell脚本</h3><p>训练CNNs的时候，最初的使用姿势可能是 <code>python cnn.py</code>。  </p><p>但是，要调整网络参数的时候怎么办，还需要到源码中找到然后一个一个修改吗？<strong>No!</strong>  </p><p><code>pytorch</code>里有<code>argparse</code>，<code>tf</code>有<code>FLAGS</code>，我可以这样 <code>python cnn.py -g 0 -param1 val1 -param2 val2 -param3 val3 -param4 val4 -param5 val5 -param6...</code>，  想接多少就。。。接多少！👀 👀 👀  </p><p>推荐写入到shell脚本中，可以顺序执行多个py文件，一个实验一个shell做到底，不用盯着显卡了。</p><p><img src="/images/shell-ml.png" width="50%" height="50%" title="Shell"></p><h3 id="log的生成"><a href="#log的生成" class="headerlink" title="log的生成"></a>log的生成</h3><p>log生成配合shell脚本使用。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh myscript.sh 2&gt;&amp;1 | tee logs/myscript.log</span><br></pre></td></tr></table></figure></p><p>原理：<br><img src="/images/output_redirect.png" alt="Output Redirect">  </p><hr><p><center><strong>持续收集中～ 🛰</strong></center>  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;🍻 高效率 &lt;del&gt;懒人&lt;/del&gt; 养成Tricks！🍻&lt;br&gt;
    
    </summary>
    
    
      <category term="trick" scheme="http://blog.x-fei.me/tags/trick/"/>
    
      <category term="tool" scheme="http://blog.x-fei.me/tags/tool/"/>
    
  </entry>
  
  <entry>
    <title>训练网络管理实验的科学探索💪🏼</title>
    <link href="http://blog.x-fei.me/2018/08/26/%E8%AE%AD%E7%BB%83%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86%E5%AE%9E%E9%AA%8C%E7%9A%84%E7%A7%91%E5%AD%A6%E6%8E%A2%E7%B4%A2/"/>
    <id>http://blog.x-fei.me/2018/08/26/训练网络管理实验的科学探索/</id>
    <published>2018-08-26T03:26:49.000Z</published>
    <updated>2018-08-26T06:12:27.024Z</updated>
    
    <content type="html"><![CDATA[<p>👏🏼 Some tips about how to manage your experiments！👏🏼  </p><blockquote><p>无论是打比赛还是写论文，我们都需要做大量的实验。有人说深度调参是“玄学”，为了有效探索这门玄学，需要对模型的结构、参数、结果做全面详尽的记录，对实验结果、模型参数进行合理保存。这里，分享一些我以及我的师兄教给我的在训练网络并科学管理实验方面的一些心得体会。✍🏼  </p></blockquote><a id="more"></a><h2 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h2><p>我们在实验过程中对数据集会遇到两种情况 👉🏻 一是实验需要尝试多个不同的数据集；二是对同一数据集作了不同的预处理操作从而产生了多个“不同”的数据集。为了避免后期总结或者做对比实验的时候找不到对应的数据集，需要我们对数据集进行记录，可以根据数据集的各项特征进⾏区分。这时我们就可以写一个<code>readme_dateset.txt</code>来记录对应特征的数据集文件夹。  </p><p><img src="/images/dataset.png" alt="datasets"><br><img src="/images/dataset_record.png" alt="readme"></p><h2 id="实验记录"><a href="#实验记录" class="headerlink" title="实验记录"></a>实验记录</h2><p>实验记录，一方面有助于自己了解模型在当前数据集、epoch、参数等条件下的性能，另一方面分析本条实验记录的结果可以帮助我们确定下一步的优化方向，最后在自己写report或者paper的时候，有丰富的图文数据支持。这里我们使用Excel表格来记录我们的实验。  </p><h3 id="基本实验记录"><a href="#基本实验记录" class="headerlink" title="基本实验记录"></a>基本实验记录</h3><p>针对单一实验，有很多实验的基本属性，比如序号id，数据集，网络，存储位置，参数，log文件，状态，结果分析等。<br>我们的列表的Head的整体框架基本上可以确定下来了，例如：</p><table><thead><tr><th>status</th><th>date</th><th>id</th><th>net</th><th>dataset</th><th>params</th><th>save_folder</th><th>analysis</th></tr></thead><tbody><tr><td>training</td><td>0901</td><td>a1</td><td>u-net</td><td>trainset</td><td>…</td><td>./Results/a1</td><td>300x400优于200x300</td></tr></tbody></table><h3 id="参数及其它"><a href="#参数及其它" class="headerlink" title="参数及其它"></a>参数及其它</h3><p>我们可以针对自己的需要，先确定一些可能需要修改、做对比实验的参数或者条件，比如不同预处理的数据集，图片的size等，之后可以添加更多的参数，对于已确定的参数可以放到靠后一点的列。同一实验，我们要对比某一参数的表现，最为直接的度量衡就是<code>Loss Function</code>，因此也要将其记录下来。有时，我们可能需要对网络的架构进行调整，这就不是参数了，需要我们用文字或者图片描述。    </p><h3 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h3><p>做文字记录的同时，需要对我们相关实验的数据进行整理保存。<br>训练完网络，产生了很多实验相关的output，我们的report取材都是来源于这些数据。这里注意两点：</p><ul><li><strong>单一实验保存</strong>：我们需要保存的文件可能有训练时产生的很多的checkpoint文件，网络权重，网络参数，日志，样例输出，对应的脚本等。根据自己的需求来保存。例如：  </li></ul><p><img src="/images/single_exp.png" alt="Single Exp">  </p><ul><li><strong>多个实验保存</strong>：注意命名的易读性、可辨别性以及规范性即可。   </li></ul><p><img src="/images/exps.png" alt="Exps"></p><h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><p>最后附一张我做Deeplabv3+的实验记录<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a> </sup>。   </p><p><img src="/images/deeplab_exp.png" alt="My Deeplabv3+ Exp"></p><h2 id="Tricks"><a href="#Tricks" class="headerlink" title="Tricks"></a>Tricks</h2><p>有几条用的上的tricks，包括：</p><ul><li>使用tmux；  </li><li>将需要调整的参数都写进命令行参数中，然后编写shell脚本  </li><li>输出并保存log<br>详情 👉🏻  <a href="/2018/08/26/Lazy-Tricks/" target="_blank">Lazy Tricks🙈</a></li></ul><div class="footnotes"><ol><br>    <li class="footnote" id="fn:1"><br>        <p>这时我第一次做实验的记录，有什么建议大家可以给我留言！欢迎👏 <a href="#fnref:1" title="Suggestions"> </a></p><p><br>    </p></li><br></ol></div> <script type="text/javascript">    $.bigfoot();</script><script type="text/javascript">    var bigfoot = $.bigfoot({        deleteOnUnhover: false,        preventPageScroll: false,        hoverDelay: 250,    });</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;👏🏼 Some tips about how to manage your experiments！👏🏼  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;无论是打比赛还是写论文，我们都需要做大量的实验。有人说深度调参是“玄学”，为了有效探索这门玄学，需要对模型的结构、参数、结果做全面详尽的记录，对实验结果、模型参数进行合理保存。这里，分享一些我以及我的师兄教给我的在训练网络并科学管理实验方面的一些心得体会。✍🏼  &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="trick" scheme="http://blog.x-fei.me/tags/trick/"/>
    
      <category term="Machine Learning" scheme="http://blog.x-fei.me/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>Summary: MICCAI 2018 Skin Lesion Contest</title>
    <link href="http://blog.x-fei.me/2018/08/26/Summary-MICCAI-2018-Skin-Lesion-Contest/"/>
    <id>http://blog.x-fei.me/2018/08/26/Summary-MICCAI-2018-Skin-Lesion-Contest/</id>
    <published>2018-08-25T17:31:37.000Z</published>
    <updated>2018-08-26T06:00:56.986Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Time：6.26-7.27<br>Location: SYSU<br>Contest: MICCAI 2018 SKIN Lesion Analysis Towards Melanoma Detection<br>Task: Lesion Segmentation<br>Rank: 29/66</p></blockquote><p>严格意义上我第一次打这种比赛。除了做白日梦，无用功，大概就只能搬搬砖了。有很多经验教训，只能说<code>too old, too naive</code>。下面从数据预处理，模型选择与实现，后处理，以及模型集成这几个方面总结一下这次比赛。  </p><a id="more"></a><h2 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h2><p>预处理需要分析训练集本身的特性，结合任务的特点。分割给了2594张图片作为训练集，尺寸差异很大。  </p><h3 id="Resize"><a href="#Resize" class="headerlink" title="Resize"></a>Resize</h3><p>由于GPU显存、CNNs以及本身scale不统一的问题，需要对数据做resize。 </p><p><em>Q1: resize到什么大小？</em><br><strong>A1</strong>: 一般300x400, 256x256, 512x512   </p><p><em>Q2: resize的时候需要保持比例吗？</em><br><strong>A2</strong>: 借鉴往年的经验，保持了大部分图片的宽高比为4:3。但是最后Top1的MT并没有保持比例，而是直接Resize，因此这一点存在争议，我觉得一组对比实验确定一下就可以了。</p><h3 id="Preprocessing"><a href="#Preprocessing" class="headerlink" title="Preprocessing"></a>Preprocessing</h3><p>对图像归一化;<br>尝试了使用或者添加<code>HSV</code>通道；(崔哥看H通道结果并不好，弃；最后MT添加了SV通道);<br>尝试了<code>Color Constancy</code> (没有提升);<br>尝试了<code>Gamma</code>校正，然并卵……  </p><h3 id="Augmentation"><a href="#Augmentation" class="headerlink" title="Augmentation"></a>Augmentation</h3><p>数据量偏少，需要做增强。这个比较实用，但是过于保守，应当考虑到皮肤病的病灶区域形状多变性，所以<code>Flip</code>,<code>Rotate</code>, <code>Zoom</code>可以都做一些，尺度也可以大一些。  </p><h3 id="Kth-folder-Cross-Validation"><a href="#Kth-folder-Cross-Validation" class="headerlink" title="Kth folder Cross Validation"></a>Kth folder Cross Validation</h3><p>多折交叉验证<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a> </sup>。 在<code>Local Validation Set</code>以及<code>Public Validation Set</code>上的性能并不能完全代表在<code>Private Validation Set</code>上的性能，所以做多折交叉验证一方面增强模型的鲁棒性，一方面相当于做了模型的集成。<br>这个时候需要我们去shuffle数据集，划分成5份。<br><em>Q3: 先做<code>augmentation</code>还是先划分数据集?</em><br><strong>A3</strong>: 先做<code>augmentation</code>。保证增强后的数据集足够大。  </p><p>我和崔哥两个人主要负责这个task，但是我俩数据预处理一开始就没有统一，无论是resize到什么尺寸还是normalization，间接导致我俩模型性能不能比较，这个问题还是相当严重的，不能及时发现某一网络的性能，从而快速调整，影响整体进度及结果。因此到最后一周多，统一了预处理但没有时间去做交叉验证了。模型的target function更接近<code>Public Validation Set</code>。</p><h2 id="模型选择与实现"><a href="#模型选择与实现" class="headerlink" title="模型选择与实现"></a>模型选择与实现</h2><p>比赛和平时科研的最大不同在于，比赛更看重模型最终的性能，而不是很在意其创新性。对于比赛而言，做baseline的最好方法就是选一个当前top的模型，不做别的动作，直接调整至输出一个不错的结果。  </p><h3 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h3><p>这个就需要依赖平时的积累了，读最新的顶会或者A类期刊的论文，关注新的高性能高表现的网络，这些模型都可以作为备选，以及一些模型中某一组件（tech），比如CRF，multi-scale，ASPP等，通过做实验去证明这些结构的有效性。  </p><h3 id="模型实现"><a href="#模型实现" class="headerlink" title="模型实现"></a>模型实现</h3><p>这就要讨论到用啥主流框架的问题了，我们都是<code>tf</code>的‘脑残粉’，因此一直可怜巴巴痛并快乐地debug。但是遇到改一些架构问题的时候，因为对<code>tf</code>的掌控有限，所以并不得心应手。被老板诟病过很多次，要么换<code>pytorch</code>，要么<code>keras</code>。  </p><h3 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h3><p>训练的时候，做好实验记录！<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a> </sup> 模型参数初始化，最好还是把训练好的网络的权重拿过来直接用。</p><p>打比赛，用<code>pytorch</code>或者<code>keras</code>能快速实现网络、我们的一些想法，把注意力集中到如何提升性能这一方面来，而不是某些技术细节。但是技术细节却是我们比较看重的长期的个人能力，因此之后估计也是走双修的路线吧。</p><h2 id="后处理Post-Processing"><a href="#后处理Post-Processing" class="headerlink" title="后处理Post_Processing"></a>后处理Post_Processing</h2><p>是否需要后处理取决于模型的结果，根据predict的结果，分析模型有哪些做的不够好的地方，是模型本身的缺陷还是数据的问题，为了最终的得分的话，都可以做后处理，去除一些共性的问题。  </p><p>比如Task1规定的，每个图片可能有不止一块lesion区域，但是label只标记了最中间、最主要的那一块。这就导致模型识别出了小块的lesion，但是label没有标记，反而会影响得分。因此我们后处理做了求最大连通区域，去洞操作。</p><h2 id="模型集成"><a href="#模型集成" class="headerlink" title="模型集成"></a>模型集成</h2><p>为了综合提升模型的性能，最终提交的结果需要对单个、多个模型做集成。  </p><h3 id="单模型集成"><a href="#单模型集成" class="headerlink" title="单模型集成"></a>单模型集成</h3><p>单模型的集成分为两大类。  </p><ul><li>多层特征融合：比如尝试改进U-Net的结构，将Encoder层的特征通过卷积再融合到Decoder的最后一层；或者采用简单的multi-scale，将输入数据调整为不同的scale，分别提取特征，最后做融合。  </li><li>网络快照集成法：利用了网络解空间中的局部最优解来对单个网络做模型集成。通过循环调整网络学习率可使网络依次收敛到不同的局部最优解处，取不同epoch处的模型进行融合。  </li></ul><p>但是这里我们做的不够好，比较合理的做法是将不同scale的特征融合到一起的，但是囿于自身技术，没能实现。</p><h3 id="多模型集成"><a href="#多模型集成" class="headerlink" title="多模型集成"></a>多模型集成</h3><p>多模型集成的方法相对较多，看方法名就可以知道大概做法了。需要注意的是，前面的个别单模型集成方法也可以运用到多模型当中，多模型的一些方法也可以看作是单模型的。  </p><h4 id="多模型生成策略"><a href="#多模型生成策略" class="headerlink" title="多模型生成策略"></a>多模型生成策略</h4><p>同一模型不同初始化；<br>同一模型不同训练轮数；<br>不同目标函数；<br>不同网络结构。  </p><h4 id="多模型集成方法"><a href="#多模型集成方法" class="headerlink" title="多模型集成方法"></a>多模型集成方法</h4><p>直接平均法；<br>加权平均法；<br>投票法；<br>留一法。  </p><p>在网络训练的过程中使用dropout也算是多模型集成的一种。  </p><p>实际操作中单模型，多模型集成相结合！  </p><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>我研究了3个星期的deeplabv3+，最后表现并不好，因此最后一周meeting的时候，这个model被kill掉了，最后熬了一夜只做了U-Net的各种集成。<br>虽然没有取得靠前的名次，但是收获了很多宝贵的经验。从如何打比赛到如何做实验、保存实验记录，以及总结了一套个人感觉比较完善的工作流程，一些Tips<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a> </sup>。</p><div class="footnotes"><ol><br>    <li class="footnote" id="fn:1"><br>        <p>这个在台大李宏毅老师的机器学习视频中有详细的介绍。 <a href="#fnref:1" title="Cross Validation"> </a></p><p><br>    </p></li><br>    <li class="footnote" id="fn:2"><br>        <p>实验整理请看👉🏻 <a href="/2018/08/26/训练网络管理实验的科学探索/" target="_blank">训练网络管理实验的科学探索💪🏼</a> <a href="#fnref:2" title="Cross Validation"> </a></p><p><br>    </p></li><br>     <li class="footnote" id="fn:3"><br>        <p>实验整理请看👉🏻 <a href="/2018/08/26/训练网络管理实验的科学探索/" target="_blank">训练网络管理实验的科学探索💪🏼</a> <a href="#fnref:3" title="Cross Validation"> </a></p><p><br>    </p></li><br></ol></div> <script type="text/javascript">    $.bigfoot();</script><script type="text/javascript">    var bigfoot = $.bigfoot({        deleteOnUnhover: false,        preventPageScroll: false,        hoverDelay: 250,    });</script>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Time：6.26-7.27&lt;br&gt;Location: SYSU&lt;br&gt;Contest: MICCAI 2018 SKIN Lesion Analysis Towards Melanoma Detection&lt;br&gt;Task: Lesion Segmentation&lt;br&gt;Rank: 29/66&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;严格意义上我第一次打这种比赛。除了做白日梦，无用功，大概就只能搬搬砖了。有很多经验教训，只能说&lt;code&gt;too old, too naive&lt;/code&gt;。下面从数据预处理，模型选择与实现，后处理，以及模型集成这几个方面总结一下这次比赛。  &lt;/p&gt;
    
    </summary>
    
    
      <category term="summary" scheme="http://blog.x-fei.me/tags/summary/"/>
    
      <category term="think" scheme="http://blog.x-fei.me/tags/think/"/>
    
  </entry>
  
  <entry>
    <title>Hackx上海</title>
    <link href="http://blog.x-fei.me/2017/11/06/Hackx%E4%B8%8A%E6%B5%B7/"/>
    <id>http://blog.x-fei.me/2017/11/06/Hackx上海/</id>
    <published>2017-11-06T03:49:33.000Z</published>
    <updated>2017-11-06T05:10:10.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="东方明珠"><a href="#东方明珠" class="headerlink" title="东方明珠"></a>东方明珠</h3><p><img src="/images/OrientalPearlTower.png" alt="The Oriental Pearl Tower">  </p><a id="more"></a><h3 id="HACKxFDU"><a href="#HACKxFDU" class="headerlink" title="HACKxFDU"></a>HACKxFDU</h3><p><img src="/images/HACKxFDU.png" alt="HACKxFDU"></p><blockquote><p>Idea很重要！做一个有力的C位很重要！  </p></blockquote><p>人和动物的根本区别是会不会制造和使用工具。<br>人是一支有思想的芦苇。  </p><p>周五NodeX四人乘高铁到了上海，在那里度过了一个值得吐槽的周末。<br>对我个人而言，有很多收获。  </p><h3 id="Idea"><a href="#Idea" class="headerlink" title="Idea"></a>Idea</h3><blockquote><p>人是一支有思想的芦苇。  </p></blockquote><p>这次去上海主要是参加 <em>2017 HACKx FDU</em> <sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a> </sup> 。主题是人工智能、金融科技、云服务和物联网。我们去的四个人，两个前端，我一个客户端，天天全可以。做应用不存在什么问题，但是AI算法是短板了，没有可以做的。但是这是黑客松啊，我理解的黑客松是 <em>现场idea</em> + <em>已有或现学的技术</em> ，所以周五就准备好鸽了，周末出去玩。  </p><p>还是想聊聊关键，A good idea！  </p><p>Without an idea, you are nothing at all.这话是有些夸张的，就是想突出idea的重要性。是的，没有好的Idea，一切都是扯淡。技术是优势，但不是全部！  </p><p>去现场的时候，认识了Luv Letter，然后后面两天看也稍微帮助他们做了一些事情。最开始的时候，他们有了想法，后面实施的时候，现学的nodejs写了后端。实际上，我们这边前后端写起来就是分分钟的事情。但是我们没有想法。<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a> </sup>  </p><p>所以想法啊，真的很重要。人是一支有思想的芦苇，没有idea就是一台掌握了具体技术的机器。  </p><p>那么如何，有一个异于常人的新颖的想法？我也要去寻找答案。  </p><h3 id="打好C位，单C难赢"><a href="#打好C位，单C难赢" class="headerlink" title="打好C位，单C难赢"></a>打好C位，单C难赢</h3><blockquote><p>看新闻才知道S7总决赛SKT输了，Faker哭了，ADC Bang要背锅。</p></blockquote><p>SKT打兔子队的时候，1:2落后拿出瑞兹稳住Carry；打RNG的时候，拿出加里奥疯狂支援。一人扛起了一支队。但是打SSG的时候，Carry不动了，Bang失误太多。  </p><p>之前看一个主播xiaoxin玩《绝地求生大逃杀》的时候，带了三个队友，很菜的那种，最后加上他们共两支队伍6个人。xiaoxin不小心对枪死了，但是知道了对方的位置，然后指挥三个队友打。队友连枪都没对上，全跪了。  </p><p>打游戏的时候是这样的，想赢，别坑，该自己做的做好，Carry起来，一个人很难带的动的。<br>游戏之外也是这样。为什么说的是强强联合，而不是强弱联合？因为绝大多数的弱者没有合作的资格。从强者的角度来说，自然也是希望自己的合作对象是旗鼓相当的强者。（当然，互补是另外的说法，这里的强弱比较视具体情况看）  </p><p>所以，做好自己的C位，不是总有人来带你飞。  </p><h3 id="大道朝天"><a href="#大道朝天" class="headerlink" title="大道朝天"></a>大道朝天</h3><p>除了没有写自己的项目之外，在现场听到IBM，上汽，图森，高盛的人员和复旦教授谈AI。收获还是蛮大的。  </p><blockquote><p>核心的竞争力还是算法。只有掌握了道的本质和精髓才能永远游刃有余。  </p></blockquote><p>所以，更加坚定而且有了足够的鸡汤陪我走下一程了。</p><div class="footnotes"><ol><br>    <li class="footnote" id="fn:1"><br>        <p>第二届复旦大学创客马拉松 <a href="#fnref:1" title="hackx FDU"> </a></p><p><br>    </p></li><br>    <li class="footnote" id="fn:2"><br>        <p>然后周五晚上鸽了之后去吃海底捞的路上，我吐槽说，你们这些都是BAT的败类 🙃。 <a href="#fnref:2" title="hackx FDU"> </a></p><p><br>    </p></li><br></ol></div> <script type="text/javascript">    $.bigfoot();</script><script type="text/javascript">    var bigfoot = $.bigfoot({        deleteOnUnhover: false,        preventPageScroll: false,        hoverDelay: 250,    });</script>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;东方明珠&quot;&gt;&lt;a href=&quot;#东方明珠&quot; class=&quot;headerlink&quot; title=&quot;东方明珠&quot;&gt;&lt;/a&gt;东方明珠&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/images/OrientalPearlTower.png&quot; alt=&quot;The Oriental Pearl Tower&quot;&gt;  &lt;/p&gt;
    
    </summary>
    
    
      <category term="出行" scheme="http://blog.x-fei.me/tags/%E5%87%BA%E8%A1%8C/"/>
    
      <category term="HACKx" scheme="http://blog.x-fei.me/tags/HACKx/"/>
    
  </entry>
  
  <entry>
    <title>技术分为术和道两种</title>
    <link href="http://blog.x-fei.me/2017/10/01/%E6%8A%80%E6%9C%AF%E5%88%86%E4%B8%BA%E6%9C%AF%E5%92%8C%E9%81%93%E4%B8%A4%E7%A7%8D/"/>
    <id>http://blog.x-fei.me/2017/10/01/技术分为术和道两种/</id>
    <published>2017-10-01T07:07:21.000Z</published>
    <updated>2017-10-01T08:29:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>2017年9月回顾。<br><a id="more"></a></p><blockquote><p>技术分为术和道两种，具体的做事方法是术，做事的原理和原则是道。术会从独门绝技到普及再到落伍，追求术的人会很辛苦，只有掌握了道的本质和精髓才能永远游刃有余。 ​</p></blockquote><p>上面这句话引用自吴军先生的《数学之美》。思索了很久，然后17年整个9月就在二者之间作出了我目前认为的最合适的决定。  </p><h3 id="方向"><a href="#方向" class="headerlink" title="方向"></a>方向</h3><p>7月25号，拖了很久的一个项目写完了。然后准备秋招。还是想做移动应用开发。而对于Android而言，虽然Java算比较熟悉的了，但是看了一下面经，要看的书太多了，而且入门门槛低，现在基本饱和了吧。正式转iOS开发。  </p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>一周看了两本书，OC以及iOS编程，但是没有真机，只能在模拟器上运行。<br>8月开始，花了7-10天吧，实践加学习Swift3。<br>13号去上海，学校安排的实习。期间又写了一段时间的Java，感觉很浪费时间。所以这段时间算是一直咸鱼了，想做的事没有做好的，就断断续续地刷剑指Offer，然后完美错过阿里秋招！！！！！<br>就很迷，不知道去哪里找这些公司的校招信息，后面才了解到牛客网有一个专门的板块做这个的。<br>8月30号回长沙，开始读《Effective Objective-C》和《Objective-C 高级编程》，继续刷《剑指Offer》。<br>月末的时候写了自己的简历。</p><h3 id="笔试"><a href="#笔试" class="headerlink" title="笔试"></a>笔试</h3><p>从9月8号开始，一直笔试到14号，每天在1到2场之间。重点关注的是京东、新美大、网易、头条以及腾讯。其余的公司全当练手。笔试过程中三点不爽。一是网络和操作系统我看的太少了，准备太不充分，而且一开始看书实在是太慢了，应该看快一点，多看几遍。二是我投递的iOS岗，不得不去答一堆C++的题目，然后就被虐的很惨。三是编程，弱鸡还是弱鸡。不过还好，基本2题的话，1.5A，3题有2A。  </p><h3 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h3><p>网申的速度都比较慢。第一家面试的公司（富途证券），算是腾讯系的公司，技术团队挺好的。前一天晚上参加完线下笔试，第二天就去面试了。一上午两轮技术+HR面结束。感觉很糟糕，毕竟第一次面。然而就是这家公司，在后来给我发了offer。<br>面试的第二家公司，百度。。。。没错，就是百度了，霸面的。前文提到过，这里就不说了。<br>趋势科技面试。由于不太了解，而且说好的视频面试，面试官自己的摄像头一片黑。就很尴尬，然后面了一面就结束了。<br>面试的第四家公司，今日头条。头条给我面试邀请的邮件还是意料之外的，因为头条的笔试题我记得我做的一般，花了比较多的功夫在拓展题上，然后编程题就sb了。面了两轮技术面，面试官都是比较年轻的帅小哥，二面感觉不太好吧，提到很多我没来得及深入研究的东西。所以我只能说一点半点。然后我问了头条现在是用什么来写的，还是OC，还是Swift，还是混编。最重要的一点没有问，什么时候给回复。所以二面结束，他说让我等HR通知。等到现在，估计没戏了。<br>最后27号，网易面试，但是我后面由于时间和票的原因，通知校招组，我放弃了面试，官网的招聘状态也变成了灰色的放弃面试状态。  </p><p>我本科的面试之旅大概就到这里了。当然后面腾讯来长沙的话，通知面试的话去面一下，笔试没过就去霸面～</p><h3 id="推免"><a href="#推免" class="headerlink" title="推免"></a>推免</h3><p>面试头条的时候，莫名其妙有了推免资格（中间发生了一些“有趣”的故事），但是还处于可以放弃的阶段，这时候还没有Offer，比较着急，就没有放弃推免的名额。然后先投了中山和哈工大深研院。后面想了很多，做技术，做学术，赚钱，女朋友。。。等等等等，然后我就文章开头的话做了一番思想斗争后，决定为了更多的💰，去读研。  </p><h3 id="中山"><a href="#中山" class="headerlink" title="中山"></a>中山</h3><p>之后去了中山参加复试，联系了导师，然后基本上就定下来了。但是报名比较晚了，复试成绩也一般，只有专硕了。学费贵，奖学金少。  </p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>这个月，一开始路越走越窄，后面路越走越宽。但是，即使路宽了，还是只能选一条。选一条，否定了别的路，感觉就否定了别的自己。就很难受，很失落。但是长远来看，本科毕业，工作强度高，拿到的年薪一般（除了头条），两年后的成长空间，一般而言，大概涨不到50%，遇到瓶颈可能早一点。花两年，做一笔投资，学历+高起薪，发展前景还是可观的。其实所有的发展都是看个人能力的，能力到了，瓶颈便不复存在。能力不够，投资再多也是有去无回。所以，大四&amp;后两年。过上高三的生活吧！既然否定了其他的自己，决定走这条路，那就全力以赴，奔跑下去～  </p><p><strong>Flag：三年后不后悔。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2017年9月回顾。&lt;br&gt;
    
    </summary>
    
    
      <category term="思考" scheme="http://blog.x-fei.me/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>Canton Tower</title>
    <link href="http://blog.x-fei.me/2017/09/26/Canton-Tower/"/>
    <id>http://blog.x-fei.me/2017/09/26/Canton-Tower/</id>
    <published>2017-09-26T14:53:13.000Z</published>
    <updated>2017-10-01T06:01:05.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="广州塔"><a href="#广州塔" class="headerlink" title="广州塔"></a>广州塔</h3><p><img src="/images/tower.png" alt="Canton Tower"><br><a id="more"></a>  </p><h3 id="初见-广州"><a href="#初见-广州" class="headerlink" title="初见-广州"></a>初见-广州</h3><p>23号去广州参加中山大学的研究生推免复试。之前请崔哥帮我把申请材料都寄过去了。但是没有参加夏令营，所以只能现在去参加复试。<br>不过听同学介绍面试很水，而且我并没有做什么准备，所以也就随缘了。<br>从长沙坐了一夜的火车，早上7点20左右到的广州。离家越来越远了。<br>广州地处亚热带，比长沙还要热上几分。虽然才7点多，但是已经感受到广州的热情了。<br>体验了一下一线城市的发达地铁交通，进站可刷支付宝买地铁票，要方便很多。<br>地铁来了之后，提着箱子的我有点傻眼，比我们的校车要挤上很多。我担心提着箱子不好上车，后面发现想多了，等我站到门口的位置，自动被后面的人挤上了车。<br>坐上地铁感觉比较新鲜的是，广州地铁上播放着三种语言：普通话、粤语以及英语。然后自己心里跟着默默学了几句，“下一站……”，蛮有趣的哈哈哈。<br>倒了三班地铁到番禺区大学城北站，一路边走边在手机上找了一个旅店。  </p><h3 id="机试与面试"><a href="#机试与面试" class="headerlink" title="机试与面试"></a>机试与面试</h3><p>23号晚上6点去中山签到，做了机试两道模拟题然后回去休息了。<br>24号正式机试，然后很惨。下午面试，又被怼了一波算法，图像处理和概率论。  </p><h3 id="小蛮腰"><a href="#小蛮腰" class="headerlink" title="小蛮腰"></a>小蛮腰</h3><p>晚上去小蛮腰那边逛了逛，穷，所以没上去。只在下面拍了许多照片。<br>近处要拍只能拍塔，拍人物照比较难，只能很尴尬地自拍，照片就不放上来了。  </p><h3 id="岭南（大学）学院"><a href="#岭南（大学）学院" class="headerlink" title="岭南（大学）学院"></a>岭南（大学）学院</h3><p>中山一个很奇特的院，搞经济的，很有钱。<br>上一届的一个学长，跨专业来了岭南读金融。带我们参观中山北校区，主要是岭南学院的诸多建筑，以及真的很有钱，真的很牛X。<br>其实这些我并不在意，因为阶级差距比较大了，扯不到一起。<br>聊到IT与赚钱，学长提到他在广州的一个同学，本科毕业7000，在广州只能满足基本的衣食住行。买房什么不存在的。<br>我想到自己拿到的一份offer，深圳的，12000，大概每个月有三四千的结余吧。呵呵。<br>所以想赚钱，套路很多，靠自己去发掘了，这个不好分享也无法再现。<br>然后坚定了我读研的一个信心，为了毕业了能有一份30W+的年薪。不能说爱💰或者不爱💰，因为这个社会生存的物质水平提高了，想去做自己喜欢的事，想做贡献，先满足自己。  </p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;广州塔&quot;&gt;&lt;a href=&quot;#广州塔&quot; class=&quot;headerlink&quot; title=&quot;广州塔&quot;&gt;&lt;/a&gt;广州塔&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/images/tower.png&quot; alt=&quot;Canton Tower&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="出行" scheme="http://blog.x-fei.me/tags/%E5%87%BA%E8%A1%8C/"/>
    
  </entry>
  
  <entry>
    <title>武汉一行</title>
    <link href="http://blog.x-fei.me/2017/09/20/%E6%AD%A6%E6%B1%89%E4%B8%80%E8%A1%8C/"/>
    <id>http://blog.x-fei.me/2017/09/20/武汉一行/</id>
    <published>2017-09-20T02:57:05.000Z</published>
    <updated>2017-10-01T04:59:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>9月17号，和宏伟去武汉工程大学流芳校区考PAT（Programming Ability Test），以及宏伟傍晚去百度的面试，然后赶晚上的火车，应该可以在18号凌晨回到寝室～。<br>然而，计划始终赶不上变化。<br><a id="more"></a><br>16号宏伟接到百度的面试通知，想多点时间复习，然后我们退了火车改坐高铁。晚上我背Dijkstra到1点多，然后睡觉。  </p><hr><h3 id="9-17-PAT不及格的菜🐔"><a href="#9-17-PAT不及格的菜🐔" class="headerlink" title="9.17-PAT不及格的菜🐔"></a>9.17-PAT不及格的菜🐔</h3><p>早上8点出发去长沙南站，中午到武汉站。然后武汉站距离那个流芳校区挺远的，坐公交地铁要转两三次，估计时间有点玄，二人打的到流芳校区。吃完午饭，大概1点10分，等开场。  </p><p>一直到开考前1分钟才开的门，那时候就有预感可能会延迟。<br>但是没想到，预计1点30开考，先推迟到1点45。1800+人，加上弃考的很多，它们的服务器就承受不了了，刷一个页面刷两三分钟都刷不出来。<br>从1点45推迟到2点45分，我闲着没事，把Dijkstra写了出来备用。<br>开考后三题，第一题20分，拿了17分；两题25分，一道16分，一道2分；最后一道30分，21分。最终得分：56分。<br>。。。。。。<br>末了看了一下Rank，100分的一堆了。于是再次证明自己的算法是如何的菜了。  </p><p>宏伟为了赶百度的面试，做了一半时间就提前走了，67分。 </p><p>我到光谷广场，等到了面完回来的宏伟以及前一天到武汉的崇哥。三人去吃了晚饭，后面在小猪短租上找了一家民宿住了一晚。<br>悲伤的是，我除了带了一个外套防止冷，别的衣物都没有带。所以只是洗了个澡，衣服没有换。  </p><hr><h3 id="9-18-尝试"><a href="#9-18-尝试" class="headerlink" title="9.18-尝试"></a>9.18-尝试</h3><p>宏伟昨天走的急，我陪他回流芳校区取落下的身份证。取完到洪山广场已经11点多了。<br>随便找了一家东北饺子馆，点了三两饺子，太咸，吃了二两。<br>吃完到地铁站找了个KFC，点了两杯可乐，打算坐一下午。<br>崇哥下午一点多的时候找到我们，然后准备3点到5点参加凡普金科的在线笔试。<br>笔试就很顺利，大概50分钟，算法题全A交卷。<br>4点多，到洪广大酒店。我去附近打印店打印简历。然后鼓足了勇气，把自己简陋的简历交给了百度的HR。  </p><p>和HR的简短的谈话也很有意思（写这个的时候20号，突然收到今日头条的面试邀请）。<br>百度HR问我要投递什么岗位，我说移动应用开发。之前我在百度招聘网站上看到招的确实少。然后HR小姐姐就委婉地告诉我，这个职位招的比较少。所以招的人都是比较TOP的。（我内心独白：。。。我这菜鸡没什么机会了）。问我能不能转别的职位，我说我试试。交了简历道了声谢谢。出门等宏伟面试结束。期间接到百度电话，通知我说第二天面试，具体时间晚点短信邮件通知。  </p><p>在小猪短租上又找了一家民宿住了一晚。依旧没有换衣服，我把T恤洗了，换了小褂子。<br>和宏伟、崇哥讨论了一晚上的计算机网络、操作系统，涨了一波知识。<br>先是接到邀请面试的电话，晚上睡着之后收到通知面试的短信和邮件，帮我转了开发测试岗。时间安排在第二天下午1点30分，下午第一个。  </p><hr><h3 id="9-19-霸面百度"><a href="#9-19-霸面百度" class="headerlink" title="9.19-霸面百度"></a>9.19-霸面百度</h3><p>上午在民宿待到11点，出门后吃了简餐，直奔洪广大酒店。<br>签完时，前台让我1点20再上去。<br>我等到1点16分的时候坐电梯先上去。上电梯的时候，前面一个30左右的男子，按了去12楼的电梯。<br>问我去几楼，我说12楼。<br>问我是不是去面试的，我说是的。<br>问我叫什么名字，我说。。。<br>然后他笑了一下，说我是你面试官。<br>我。。。。。。<br>然后因为没有到时间，所以他说1点30再开始。<br>等到1点29，进门。<br>开始怼问题。面的是测试岗，但是显然我没有做这方面的准备。<br>我以为一面就是算法+基础知识。但是这个面试官问了我一堆项目。<br>算法还是太虚，在面试官引导下才做出来。<br>有一个我印象比较深的问题：如何获得APP的启动时间。<br>我想的是尽可能准确。于是提了两个方案，一是在时间戳，二是利用Instruments里的timer工具。<br>一直让我扩散思维。<br>结果最后他自己举例：打秒表，多次取平均值；录屏，可以精确到帧。<br>ORZ。  </p><p>不是特别愉快，感觉自己像个SB。   </p><p>之后和宏伟分手，我先回长沙，他还有一面。  </p><hr><h3 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h3><p>第一次霸面，没有底气没有信心，有点傻里傻气的不知天高地厚的勇气。想着不能白来一趟武汉啊，总得有点收获！挺卑微的。但是一想到自己已经一无所有了，机会是自己争取的，被刷也没有什么遗憾，毕竟尝试过了，知道自己还有很多需要提高的地方，以后再来过。想到这辈子还有好多事情没有做，好多地方没有去，好多风景没有看，好多有趣的人等着我去认识，以及，更好的我在未来等我一步一步靠近。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;9月17号，和宏伟去武汉工程大学流芳校区考PAT（Programming Ability Test），以及宏伟傍晚去百度的面试，然后赶晚上的火车，应该可以在18号凌晨回到寝室～。&lt;br&gt;然而，计划始终赶不上变化。&lt;br&gt;
    
    </summary>
    
    
      <category term="面试" scheme="http://blog.x-fei.me/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="感想" scheme="http://blog.x-fei.me/tags/%E6%84%9F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>Swift 3 Algorithm: 二叉搜索树</title>
    <link href="http://blog.x-fei.me/2017/09/04/Swift-3-Algorithm-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <id>http://blog.x-fei.me/2017/09/04/Swift-3-Algorithm-二叉搜索树/</id>
    <published>2017-09-04T07:02:56.000Z</published>
    <updated>2017-09-05T10:28:39.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>有趣的 <code>Swift 3</code> 算法。  </p></blockquote><p><em>今天分享用swift3实现在二叉搜索树中递归搜索某一个特定的值！</em><br>这个算法没有什么难度，了解二叉搜索树的性质 + 递归搜索 + swift基础语法 即可完成！  </p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>打开XCode，新建Playground，创建searchBinaryTreeDemo。  </p><h3 id="样例树"><a href="#样例树" class="headerlink" title="样例树"></a>样例树</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//              9</span></span><br><span class="line"><span class="comment">//            /   \</span></span><br><span class="line"><span class="comment">//           6     10</span></span><br><span class="line"><span class="comment">//          / \     \</span></span><br><span class="line"><span class="comment">//         5   7     11</span></span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="创建结点"><a href="#创建结点" class="headerlink" title="创建结点"></a>创建结点</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> value: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> leftChild: <span class="type">Node</span>?</span><br><span class="line">    <span class="keyword">var</span> rightChild: <span class="type">Node</span>?</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(value: <span class="type">Int</span>, leftChild: <span class="type">Node</span>?, rightChild:<span class="type">Node</span>?) &#123;</span><br><span class="line">        <span class="keyword">self</span>.value = value</span><br><span class="line">        <span class="keyword">self</span>.leftChild = leftChild</span><br><span class="line">        <span class="keyword">self</span>.rightChild = rightChild</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子结点为可选类型！   </p><h3 id="构建样例树"><a href="#构建样例树" class="headerlink" title="构建样例树"></a>构建样例树</h3><p>下面利用上面的<code>Node</code>结构创建样例树<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// left branch</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fiveNode = <span class="type">Node</span>(value: <span class="number">5</span>, leftChild: <span class="literal">nil</span>, rightChild: <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">let</span> sevenNode = <span class="type">Node</span>(value: <span class="number">7</span>, leftChild: <span class="literal">nil</span>, rightChild: <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">let</span> sixNode = <span class="type">Node</span>(value: <span class="number">6</span>, leftChild: fiveNode, rightChild: sevenNode)</span><br><span class="line"></span><br><span class="line"><span class="comment">// right branch</span></span><br><span class="line"><span class="keyword">let</span> elevenNode = <span class="type">Node</span>(value: <span class="number">11</span>, leftChild: <span class="literal">nil</span>, rightChild: <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> tenNode = <span class="type">Node</span>(value: <span class="number">10</span>, leftChild: <span class="literal">nil</span>, rightChild: elevenNode)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> nineRootNode = <span class="type">Node</span>(value: <span class="number">9</span>, leftChild: sixNode, rightChild: tenNode)</span><br></pre></td></tr></table></figure></p><h3 id="实现算法"><a href="#实现算法" class="headerlink" title="实现算法"></a>实现算法</h3><p>中序遍历～<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3 .</span></span><br><span class="line"><span class="comment">// 实现算法，在这棵树中寻找一个特定的值。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">search</span><span class="params">(<span class="number">_</span> node: Node?, <span class="number">_</span> searchValue: Int)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> node?.value == searchValue &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node?.value)! &gt; searchValue &#123;</span><br><span class="line">        <span class="keyword">return</span> search(node?.leftChild, searchValue)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> search(node?.rightChild, searchValue)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p>我们分别调用<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">search(inieRootNode, <span class="number">5</span>)</span><br><span class="line">search(inieRootNode, <span class="number">6</span>)</span><br><span class="line">search(inieRootNode, <span class="number">11</span>)</span><br><span class="line">search(inieRootNode, <span class="number">0</span>)</span><br></pre></td></tr></table></figure></p><p>可以观察到<code>playground</code>右侧面板中，函数的递归执行次数:<br>5-&gt;2次、6-&gt;1次、11-&gt;2次、0-&gt;3次。  </p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>我们知道二叉树搜索的效率是log(n)。<br>可以通过在上述二叉搜索树的中序列表中搜索来比较。  </p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// efficiency  </span></span><br><span class="line"><span class="keyword">let</span> list = [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]</span><br><span class="line"><span class="keyword">let</span> index0 = list.index(<span class="keyword">where</span>: &#123;$<span class="number">0</span> == <span class="number">0</span>&#125;)</span><br><span class="line"><span class="keyword">let</span> index5 = list.index(<span class="keyword">where</span>: &#123;$<span class="number">0</span> == <span class="number">5</span>&#125;)</span><br><span class="line"><span class="keyword">let</span> index6 = list.index(<span class="keyword">where</span>: &#123;$<span class="number">0</span> == <span class="number">6</span>&#125;)</span><br><span class="line"><span class="keyword">let</span> index11 = list.index(<span class="keyword">where</span>: &#123;$<span class="number">0</span> == <span class="number">11</span>&#125;)</span><br></pre></td></tr></table></figure><p>可以在右侧面板中看到对于不存在的元素，二叉搜索树需要搜索三次，而for循环则需要7次。对于元素11，二叉搜索树需要搜索2次，for循环依然需要11次。  </p><p>本文除了帮助理解二叉搜索树，它的效率之外，还需要了解swift可选值的解析～  </p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;有趣的 &lt;code&gt;Swift 3&lt;/code&gt; 算法。  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;em&gt;今天分享用swift3实现在二叉搜索树中递归搜索某一个特定的值！&lt;/em&gt;&lt;br&gt;这个算法没有什么难度，了解二叉搜索树的性质 + 递归搜索 + swift基础语法 即可完成！  &lt;/p&gt;
&lt;h3 id=&quot;准备&quot;&gt;&lt;a href=&quot;#准备&quot; class=&quot;headerlink&quot; title=&quot;准备&quot;&gt;&lt;/a&gt;准备&lt;/h3&gt;&lt;p&gt;打开XCode，新建Playground，创建searchBinaryTreeDemo。  &lt;/p&gt;
&lt;h3 id=&quot;样例树&quot;&gt;&lt;a href=&quot;#样例树&quot; class=&quot;headerlink&quot; title=&quot;样例树&quot;&gt;&lt;/a&gt;样例树&lt;/h3&gt;&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 1.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//              9&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//            /   \&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//           6     10&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//          / \     \&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//         5   7     11&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="algorithm" scheme="http://blog.x-fei.me/tags/algorithm/"/>
    
      <category term="swift" scheme="http://blog.x-fei.me/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift 3 Fun Algorithms: Filter, Map, Reduce Higher Order Functions</title>
    <link href="http://blog.x-fei.me/2017/09/04/Swift-3-Fun-Algorithms-Filter-Map-Reduce-Higher-Order-Functions/"/>
    <id>http://blog.x-fei.me/2017/09/04/Swift-3-Fun-Algorithms-Filter-Map-Reduce-Higher-Order-Functions/</id>
    <published>2017-09-04T02:01:52.000Z</published>
    <updated>2017-09-04T07:03:40.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>有趣的 <code>Swift 3</code> 算法。</p></blockquote><p>今天分享几个Swift Higher Order Functions 给大家。<br>主要是 <code>Filter</code>、<code>Map</code>、<code>Reduce</code>。<br><a id="more"></a></p><p>Higher Order Functions(高阶函数<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a> </sup>)。</p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>打开XCode，新建Playground，创建WordsWithCharCountDemo。  </p><h3 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h3><h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h4><p><strong>[1, 2, 3, 4, 3, 3]  -&gt; (filter into)  [3, 3, 3]  or  -&gt; [2, 4]（偶数）</strong>  </p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>我们当然可以通过For循环来完成这样的功能<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a> </sup>，但是有的时候，我们想要得到的是<code>let</code> 的 不可变的数组，这个时候，我们可以借助<code>filter</code>函数。  </p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> filtered = numbers.<span class="built_in">filter</span>(&#123; <span class="keyword">return</span> $<span class="number">0</span> == <span class="number">3</span>&#125;)</span><br><span class="line"></span><br><span class="line">filtered</span><br></pre></td></tr></table></figure><p>在filter函数中我们创建了一个<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Closures.html" target="_blank" rel="noopener">闭包表达式</a>，详细的闭包表达式知识就不在本文中多说了。该表达式完成的工作就是比较传递进来的参数和3的值，相等则返回<code>true</code>，而<code>filter</code>则根据判断返回合适的参数值。  </p><p>同样的，若想得到<code>[2,4]</code>的话，可以修改闭包表达式，<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> filtered = numbers.<span class="built_in">filter</span>(&#123;<span class="keyword">return</span> $<span class="number">0</span> % <span class="number">2</span> == <span class="number">0</span>&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><h4 id="目标-1"><a href="#目标-1" class="headerlink" title="目标"></a>目标</h4><p><strong>用map转换[1, 2, 3, 4] -&gt; [2， 4， 6， 8]</strong>  </p><h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> transformed = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>].<span class="built_in">map</span>(&#123;<span class="keyword">return</span> $<span class="number">0</span> * <span class="number">2</span>&#125;)</span><br><span class="line">transformed</span><br></pre></td></tr></table></figure><p>依然是利用简化的闭包表达式，返回参数*2。</p><h4 id="map-与-filter"><a href="#map-与-filter" class="headerlink" title="map 与 filter"></a>map 与 filter</h4><p>这里有必要提一下map与filter的区别。<br>map意为映射，就是将原有的参数通过某种方式映射成为另一个值；<br>而filter意为过滤，就是通过一定的条件，将满足该条件的值筛选出来。  </p><h3 id="Reduce"><a href="#Reduce" class="headerlink" title="Reduce"></a>Reduce</h3><h4 id="目标-2"><a href="#目标-2" class="headerlink" title="目标"></a>目标</h4><p><strong>用reduce实现累加数组 [1, 2, 3, 4]-&gt; 10</strong>  </p><h4 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sum = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>].<span class="built_in">reduce</span>(<span class="number">0</span>, &#123;sum, number <span class="keyword">in</span> sum+number&#125;)</span><br><span class="line">sum</span><br></pre></td></tr></table></figure><p>这里<code>reduce</code>函数的<a href="https://developer.apple.com/documentation/swift/uint8.words/2926485-reduce" target="_blank" rel="noopener">官方定义</a>：  </p><pre><code class="swift"><span class="function"><span class="keyword">func</span> <span class="title">reduce</span>&lt;Result&gt;<span class="params">(<span class="number">_</span> initialResult: Result, <span class="number">_</span> nextPartialResult: <span class="params">(Result, UInt)</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">Result</span>) <span class="keyword">rethrows</span> -&gt; <span class="type">Result</span></code></pre><p>联系reduce的意思可以知道，该方法从一序列的数创造出一个单一的值。例如，获取数组中数的和、乘积等。<br><code>initialResult</code>是一个初始化的值，类似于用<code>for</code>循环时先初始化<code>sum = 0</code>或者<code>produce = 1</code>。  </p><p>闭包表达式中：<br>两个参数，<code>Result</code> 与 调用<code>reduce</code>的数组元素，抛出的则是结果，因此是 <code>sum + number</code>而不是<code>sum = sum + number</code>。  </p><h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p>这三个函数在理解之后都不难，而且和<code>for循环</code>相比，相当简洁高效！<br>感谢看完本文！希望你有所收获！:)</p><div class="footnotes"><ol><br>    <li class="footnote" id="fn:1"><br>        <p>A higher-order functional language is one in which a function may be used as a value, just like an integer or a boolean. That is, the value of a variable may be a function, and a function may take a function as argument and may return a function as a result.<br>        一个高阶函数是指该函数可以被当作变量类型一样来使用。就是说变量可能是函数，一个函数可能会把另一个函数作为参数或者返回值是一个函数类型！ <a href="#fnref:1" title="Higher Order Functions"> </a></p><p><br>    </p></li><br>    <li class="footnote" id="fn:2"><br>        <p>For循环也可以完成下面要讲的map与reduce，下文就不再提及 <a href="#fnref:2" title="Powerful FOR LOOP "> </a></p><p><br>    </p></li><br></ol></div> <script type="text/javascript">    $.bigfoot();</script><script type="text/javascript">    var bigfoot = $.bigfoot({        deleteOnUnhover: false,        preventPageScroll: false,        hoverDelay: 250,        activateOnHover: true,    });</script>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;有趣的 &lt;code&gt;Swift 3&lt;/code&gt; 算法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今天分享几个Swift Higher Order Functions 给大家。&lt;br&gt;主要是 &lt;code&gt;Filter&lt;/code&gt;、&lt;code&gt;Map&lt;/code&gt;、&lt;code&gt;Reduce&lt;/code&gt;。&lt;br&gt;
    
    </summary>
    
    
      <category term="algorithm" scheme="http://blog.x-fei.me/tags/algorithm/"/>
    
      <category term="swift" scheme="http://blog.x-fei.me/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift 3 Fun Algorithms:Wrapping Array</title>
    <link href="http://blog.x-fei.me/2017/09/03/Swift-3-Fun-Algorithms-WrappingArray/"/>
    <id>http://blog.x-fei.me/2017/09/03/Swift-3-Fun-Algorithms-WrappingArray/</id>
    <published>2017-09-03T02:21:26.000Z</published>
    <updated>2017-09-04T07:03:54.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>有趣的 <code>Swift 3</code> 算法。</p></blockquote><p>在<code>Youtube</code>上看到Swift3 的一个小算法，觉得很有趣！介绍给大家～  </p><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>现在打开网易云音乐，选取一个歌单打开，从中选取一首歌，点击播放。若是循环模式，那么播放歌曲的顺序应该是：当前这首歌 -&gt; 下面的所有歌 -&gt; 当前这首歌上面的歌。<br>抽象出来就是： 对于数组<code>[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]</code>， 选取”c”，输出 <code>[ &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;a&quot;, &quot;b&quot;]</code> 。  </p><h4 id="实现1"><a href="#实现1" class="headerlink" title="实现1"></a>实现1</h4><p>新建Playground，GeneratePlayList<br><a id="more"></a></p><pre><code class="swift"><span class="comment">// 假设我们有一个歌单tracks</span><span class="keyword">let</span> tracks = [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>, <span class="string">"e"</span>]<span class="comment">// 如果我们选择了"d",算法应该返回下面这个播放列表  </span>[<span class="string">"d"</span>, <span class="string">"e"</span>, <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>]  <span class="comment">// 选中歌曲</span><span class="keyword">let</span> selectedTrack = <span class="string">"d"</span><span class="comment">// 新建播放列表</span><span class="keyword">var</span> playList = [<span class="type">String</span>]()  <span class="comment">// 所选歌曲之前的歌曲列表</span><span class="keyword">var</span> priorTracks = [<span class="type">String</span>]()<span class="comment">// for循环加入列表  </span><span class="keyword">for</span> track <span class="keyword">in</span> tracks {    <span class="built_in">print</span>(track)    <span class="keyword">if</span> track == selectedTrack || playlist.<span class="built_in">count</span> &gt; <span class="number">0</span>{        playlist.append(track)    } <span class="keyword">else</span> {        priorTracks.append(track)    }}playListpriorTracks<span class="comment">// 加在一起</span>playList + priorTracks</code></pre><h4 id="实现2"><a href="#实现2" class="headerlink" title="实现2"></a>实现2</h4><p>这次，不用<code>for循环</code>，利用Swift的<code>Array</code>的一些函数。<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a> </sup>   </p><p>这里联系应用场景，我们可能需要用的函数包括，找一个元素的index，获得子序列</p><pre><code class="swift"><span class="comment">// 假设我们有一个歌单tracks</span><span class="keyword">let</span> tracks = [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>, <span class="string">"e"</span>]<span class="comment">// 如果我们选择了"d",算法应该返回下面这个播放列表  </span>[<span class="string">"d"</span>, <span class="string">"e"</span>, <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>]  <span class="comment">// 选中歌曲</span><span class="keyword">let</span> selectedTrack = <span class="string">"d"</span><span class="comment">// 这里可以用array的index的许多方法</span><span class="keyword">let</span> index = tracks.index(<span class="keyword">where</span>: {<span class="keyword">return</span> $<span class="number">0</span> == selectedTrack})<span class="comment">// 上面获得的index是可选值，因此需要强制解析</span><span class="comment">// upTo 左闭右开</span><span class="keyword">let</span> prefixArray = tracks.<span class="keyword">prefix</span>(upTo: index!)<span class="keyword">let</span> suffixArray = tracks.suffix(from: index!)<span class="comment">// 最后注意组装的顺序</span><span class="keyword">let</span> arr = suffixArray + prefixArray</code></pre><p>这里的<a href="https://developer.apple.com/documentation/swift/array/1688966-index" target="_blank" rel="noopener">index</a>函数，声明是这样的： </p><pre><code class="swift"><span class="function"><span class="keyword">func</span> <span class="title">index</span><span class="params">(<span class="keyword">where</span> predicate: <span class="params">(Element)</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">Bool</span>) <span class="keyword">rethrows</span> -&gt; <span class="type">Int</span>?</code></pre><p>where后面是一个闭包，以<code>$0</code> 表示一个参数，预测参数和传入的元素是否匹配，匹配则返回<code>Int</code>，否则返回<code>nil</code>，所以最终的返回值是可选值 <code>Int?</code>。    </p><p>希望这个小的算法<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a> </sup> 可以运用到你的Application当中！</p><div class="footnotes"><ol><br>    <li class="footnote" id="fn:1"><br>        <p>快速掌握一门语言，比如Swift，勤加练习算法无疑是最好的方式！<a href="#fnref:1" title="footnote 在文末的标题"> </a></p><p><br>    </p></li><br>    <li class="footnote" id="fn:2"><br>        <p>在此之前，如果你不熟悉Array有哪些内置函数，不妨去看看<br>        <a href="https://developer.apple.com/documentation/swift/array" target="_blank">文档</a><br>        <a href="#fnref:2" title="footnote 在文末的标题"> </a></p><p><br>    </p></li><br></ol></div> <script type="text/javascript">    $.bigfoot();</script><script type="text/javascript">    var bigfoot = $.bigfoot({        deleteOnUnhover: false,        preventPageScroll: false,        hoverDelay: 250,        activateOnHover: true,    });</script>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;有趣的 &lt;code&gt;Swift 3&lt;/code&gt; 算法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在&lt;code&gt;Youtube&lt;/code&gt;上看到Swift3 的一个小算法，觉得很有趣！介绍给大家～  &lt;/p&gt;
&lt;h4 id=&quot;应用场景&quot;&gt;&lt;a href=&quot;#应用场景&quot; class=&quot;headerlink&quot; title=&quot;应用场景&quot;&gt;&lt;/a&gt;应用场景&lt;/h4&gt;&lt;p&gt;现在打开网易云音乐，选取一个歌单打开，从中选取一首歌，点击播放。若是循环模式，那么播放歌曲的顺序应该是：当前这首歌 -&amp;gt; 下面的所有歌 -&amp;gt; 当前这首歌上面的歌。&lt;br&gt;抽象出来就是： 对于数组&lt;code&gt;[&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;, &amp;quot;d&amp;quot;, &amp;quot;e&amp;quot;]&lt;/code&gt;， 选取”c”，输出 &lt;code&gt;[ &amp;quot;c&amp;quot;, &amp;quot;d&amp;quot;, &amp;quot;e&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;]&lt;/code&gt; 。  &lt;/p&gt;
&lt;h4 id=&quot;实现1&quot;&gt;&lt;a href=&quot;#实现1&quot; class=&quot;headerlink&quot; title=&quot;实现1&quot;&gt;&lt;/a&gt;实现1&lt;/h4&gt;&lt;p&gt;新建Playground，GeneratePlayList&lt;br&gt;
    
    </summary>
    
    
      <category term="algorithm" scheme="http://blog.x-fei.me/tags/algorithm/"/>
    
      <category term="swift" scheme="http://blog.x-fei.me/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>给Hexo添加Bigfoot</title>
    <link href="http://blog.x-fei.me/2017/09/02/%E7%BB%99Hexo%E6%B7%BB%E5%8A%A0Bigfoot/"/>
    <id>http://blog.x-fei.me/2017/09/02/给Hexo添加Bigfoot/</id>
    <published>2017-09-02T15:08:52.000Z</published>
    <updated>2017-09-04T01:58:22.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.bigfootjs.com/" target="_blank" rel="noopener">Bigfoot.js</a> 是一个很漂亮的footnote<a href="https://baike.baidu.com/item/%E8%84%9A%E6%B3%A8/17821082?fr=aladdin" target="_blank" rel="noopener">脚注</a>插件。我之前搭建Ghost博客的时候，在萌天的博客上有看到过，经过萌天介绍，认识了Bigfoot。现在将Bigfoot集成到我目前在用的hexo博客hiker主题中。<br><a id="more"></a></p><p>效果就是右边这个小气泡按钮啦，萌不萌？ <sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a> </sup>   </p><p> <em>下面就为Hexo博客添加Bigfoot支持吧！</em></p><h3 id="下载所需文件"><a href="#下载所需文件" class="headerlink" title="下载所需文件"></a>下载所需文件</h3><p>Bigfoot依赖jquery，所以需要下载以下内容：<br><a href="http://www.bigfootjs.com/download/bigfoot.zip" target="_blank" rel="noopener">Bigfoot.js</a><br><a href="http://www.jq22.com/jquery-info122" target="_blank" rel="noopener">jquery</a><br>(这里jquery的版本要高于1.8，但是在用到高版本的jquery的时候，会出现bigfoot气泡样式不对的错误！)  </p><h3 id="移动文件"><a href="#移动文件" class="headerlink" title="移动文件"></a>移动文件</h3><p>Hexo的一般theme的目录结构：<br><img src="/images/struct.png" alt="目录结构">  </p><p>将下载得到的 <code>bigfoot.min.js</code> 和 <code>jquery-2.0.3</code> 放入 <code>hiker</code>主题下 <code>source/js</code> 文件夹；<br>将下载得到的 <code>bigfoot-default.css</code> 放入<code>css</code> 文件夹。</p><h3 id="修改文件"><a href="#修改文件" class="headerlink" title="修改文件"></a>修改文件</h3><p>打开<code>主题名/layout/_partial/head.ejs</code> ，在适当的位置添加：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;%- js(&apos;js/jquery-2.0.3.min.js&apos;) %&gt;</span><br><span class="line">&lt;%- js(&apos;js/bigfoot.min.js&apos;) %&gt;</span><br></pre></td></tr></table></figure></p><p>然后打开根目录下面的<code>scaffolds</code>（模版文件夹）下的 <code>post.md</code> 文件，在最后添加：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    $.bigfoot();</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    var bigfoot = $.bigfoot(&#123;</span></span><br><span class="line"><span class="undefined">        deleteOnUnhover: false,</span></span><br><span class="line"><span class="undefined">        preventPageScroll: false,</span></span><br><span class="line"><span class="undefined">        hoverDelay: 250,</span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>这里我没有把这些加入<code>ejs</code>模版文件中，出于两方面考虑，一方面bigfoot对气泡有很多额外的设置可以在这里添加，另一方面加入到什么地方都让我觉得不太优美，暂时没有找到合适的地方。  </p><p>保存，<code>hexo generate、 hexo server</code> 看一下本地的效果，没有问题的话，<code>deploy</code>到服务器！  </p><h3 id="使用Bigfoot"><a href="#使用Bigfoot" class="headerlink" title="使用Bigfoot"></a>使用Bigfoot</h3><p>Bigfoot 的使用时靠直接写HTML的，使用如下：<br>在新的post当中：<br><strong>在文章需要显示气泡处</strong>，添加：<br><code>&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnote&quot;&gt;1&lt;/a&gt; &lt;/sup&gt;</code><br>其中数字1代表脚注序号。<br><strong>文章末尾处</strong>，添加：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"footnotes"</span>&gt;</span><span class="tag">&lt;<span class="name">ol</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"footnote"</span> <span class="attr">id</span>=<span class="string">"fn:1"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>footnote 里面要显示的内容<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#fnref:1"</span> <span class="attr">title</span>=<span class="string">"footnote 在文末的标题"</span>&gt;</span> ↩<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>序号要对应。  </p><p>好了，这个时候重新generate，应该会出现了！</p><div class="footnotes"><ol><br>    <li class="footnote" id="fn:1"><br>        <p>footnote 里面要显示的内容，有什么问题欢迎留言交流～ <a href="#fnref:1" title="footnote 在文末的标题"> </a></p><p><br>    </p></li><br></ol></div> <script type="text/javascript">    $.bigfoot();</script><script type="text/javascript">    var bigfoot = $.bigfoot({        deleteOnUnhover: false,        preventPageScroll: false,        hoverDelay: 250,    });</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://www.bigfootjs.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Bigfoot.js&lt;/a&gt; 是一个很漂亮的footnote&lt;a href=&quot;https://baike.baidu.com/item/%E8%84%9A%E6%B3%A8/17821082?fr=aladdin&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;脚注&lt;/a&gt;插件。我之前搭建Ghost博客的时候，在萌天的博客上有看到过，经过萌天介绍，认识了Bigfoot。现在将Bigfoot集成到我目前在用的hexo博客hiker主题中。&lt;br&gt;
    
    </summary>
    
    
      <category term="Web" scheme="http://blog.x-fei.me/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>Stay hungry, Stay Young</title>
    <link href="http://blog.x-fei.me/2017/08/29/Stay-hungry-Stay-foolish/"/>
    <id>http://blog.x-fei.me/2017/08/29/Stay-hungry-Stay-foolish/</id>
    <published>2017-08-29T11:59:27.000Z</published>
    <updated>2017-09-03T12:54:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>忘记第几次重新搭建博客了，之前重装系统、换笔记本或者服务器到期，（其实更关键的是博客更新太少了）。<br>现在重新开张，希望有缘到我这个小站来的你，能收获一些东西！：）  </p><p>Stay hungry, Stay Young!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;忘记第几次重新搭建博客了，之前重装系统、换笔记本或者服务器到期，（其实更关键的是博客更新太少了）。&lt;br&gt;现在重新开张，希望有缘到我这个小站来的你，能收获一些东西！：）  &lt;/p&gt;
&lt;p&gt;Stay hungry, Stay Young!&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="think" scheme="http://blog.x-fei.me/tags/think/"/>
    
  </entry>
  
</feed>
