<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Make everyday count!</title>
  
  <subtitle>Everything will be ok!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.x-fei.me/"/>
  <updated>2018-12-23T02:49:31.837Z</updated>
  <id>http://blog.x-fei.me/</id>
  
  <author>
    <name>XFeiF</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SVM(Part I)</title>
    <link href="http://blog.x-fei.me/2018/12/23/SVM/"/>
    <id>http://blog.x-fei.me/2018/12/23/SVM/</id>
    <published>2018-12-22T16:21:34.000Z</published>
    <updated>2018-12-23T02:49:31.837Z</updated>
    
    <content type="html"><![CDATA[<p>传送门： </p><p><a href="https://blog.x-fei.me/2018/12/23/SVM/">SVM_1</a>：</p><p>简介与线性可分情况分析，最后附有详细推导过程与注解。</p><p><a href="">SVM_2</a></p><p>VC维，非线性可分情况分析，核技巧，软间隔，总结  </p><a id="more"></a><p>About These  Articles：  </p><p>SVM的学习，可以查询到大量的相关文章、视频，并且在几本经典的书（西瓜书，统计学习方法等）中也有相应的解读。本文为个人总结回顾。(由于Markdown和MathJax的兼容问题，很多公式没有渲染出来，可以直接看手写推导过程。)</p><h2 id="SVM简介"><a href="#SVM简介" class="headerlink" title="SVM简介"></a>SVM简介</h2><p>Support Vector Machine（SVM），监督学习。</p><p>流行于1998年NIST的手写数字识别。其优点有：  </p><ol><li>是当时已有的比神经网络更有效的算法，泛化性能好，和神经网络相比不存在局部极小值，不需要长时间的收敛。  </li><li>在许多复杂的现实应用比如文字、图片分类等任务中有成功的应用</li><li>在很多任务中，SVM是最好的选择  </li></ol><p>从以上我们知道，SVM是一种强大的算法，即时今天我们的神经网络已经发展出很多，有了很多优异的表现，但是这与了解SVM并不冲突，学习好SVM对于我们理解、求解一些问题依然很重要。</p><h2 id="问题定义"><a href="#问题定义" class="headerlink" title="问题定义"></a>问题定义</h2><p>训练数据：$(x_1, y_1), (x_2, y_2), … , (x_n, y_n)$, 其中，$x_i$是m维的向量，每一个向量都属于$+1, -1$中的一类。    </p><p>希望寻找到一个<strong>超平面</strong>： $w·x + b = 0$，可以将训练数据分到对应的类中，正类为1，负类为-1.</p><p><img src="/images/multi_hps.png" alt="Posible HPs"></p><p>如图，虽然有无数可能的超平面，但是我们希望寻找一个泛化性能好（所谓的泛化性能好，指的是模型对没有见过的新数据依然有不错的性能，即模型表征的是一般性的特征）超平面，即上图<strong>H3</strong>的情况。  </p><p>假设选定的超平面<strong>H2</strong>是靠近训练数据$x_i$的，现在对于测试数据$x^{‘}$ ，它与$x_i$同类，但是用图中选定的超平面<strong>H2</strong>却误分类类。  </p><p>所以直观上，超平面的选定规则有：  </p><ul><li>超平面应该尽可能远离所有的样本点</li><li>靠近训练数据的新数据应该北正确分类  </li></ul><h2 id="线性可分SVM"><a href="#线性可分SVM" class="headerlink" title="线性可分SVM"></a>线性可分SVM</h2><p>在数据线性可分的情况下，SVM 的思想是最大化超平面与最接近的样本点间的距离。在理想最优超平面处：<strong>与最近的负样本点的距离 =  与最近的正样本点的距离</strong>。最优意味着有很好的泛化性能。  </p><h3 id="Support-Vectors"><a href="#Support-Vectors" class="headerlink" title="Support Vectors"></a>Support Vectors</h3><p>Support Vectors支持向量指的是距离分离超平面最近的那些样本点。即如下图所示虚线上的蓝点和绿点：  </p><p><img src="/images/idea_hp.png" alt="Idea HP"></p><h3 id="距离"><a href="#距离" class="headerlink" title="距离"></a>距离</h3><p>假设决策边界表达式为：$w^{t}x + b = 0$ ，其中$w{\in}R^{m}, x{\in}R^{m}, b{\in}R $ 。   </p><p>$\frac{w}{||w||}$ 和 决策边界垂直且长度为1。   </p><p>令$\gamma_i$表示训练集中的样本点$x_i$与决策边界之间的距离。  </p><p>令$x_i$为最接近决策边界的样本点集中的一个，$||w^{t}x_i + b = 1||$ ，可以 通过缩放$w,b$来满足1的条件。  </p><p>此时$d = \frac{w^tx_i + b}{||w||} = \frac{1}{||w||}$  。所以此时间隔 $m = \frac{2}{||w||}$。    </p><h3 id="寻找最优超平面"><a href="#寻找最优超平面" class="headerlink" title="寻找最优超平面"></a>寻找最优超平面</h3><p>SVM通过最大化间隔$m = \frac{2}{||w||}$ 以保证：</p><p>For $y_i = +1, w^tx_i + b \geq 1$</p><p>For $y_i = -1, w^tx_i + b \leq -1$</p><p>以上的最大化问题可以等价转化为最小化$\frac{1}{2} \parallel w \parallel^2$  ，条件为$y_i(w^tx_i + b) \geq 1$ （1）。</p><p>这样转化是最优化问题转化为了一个只有线性约束并且总有单一最小值的凸二次规划问题。</p><h3 id="最优化问题"><a href="#最优化问题" class="headerlink" title="最优化问题"></a>最优化问题</h3><p>为了求解线性可分SVM的最优化问题（1），将它作为原始最优化问题，应用拉格朗日对偶性，通过求解对偶问题得到原始问题的最优解。</p><p>这样做的优点，一是对偶问题往往更容易求解；二十自然引入<strong>核函数</strong>，进而推广到非线性分类问题。</p><p>首先构建拉格朗日函数，对每一个不等式约束引进拉格朗日乘子 $\alpha_i \geq 0, i=1,2,…,N$ （2.1），定义拉格朗日函数：</p><p>$L(w, b, \alpha)=$  $\frac{1}{2} \parallel w \parallel^2 - $$ \sum_{i=1}^{N}\alpha_i(y_i(w \cdot x_i+b) - 1 )$ （2.2），</p><p>其中 $\alpha = (\alpha_1, \alpha_2, … , \alpha_N)^T$ 为拉格朗日乘子向量。  </p><p>根据拉格朗日对偶性，原始问题的对偶问题是极大极小问题：  </p><p>\$max<em>\alpha$  \$min</em>{w, b}$\$L(w, b ,\alpha)$  </p><p>所以，为了得到对偶问题的解，需要先求$L(w, b, \alpha)$对$w, b$的极小，再求对$\alpha$的极大。  </p><ol><li><strong>求$min_{w,b}L(w, b, \alpha)$</strong> </li></ol><p>$\frac{\partial L}{\partial w} = 0  \Longrightarrow w = \sum_{i=1}^{n}\alpha_iy_ix_i  （3）$  </p><p>$\frac{\partial L}{\partial b} = 0  \Longrightarrow \sum_{i=1}^{n}\alpha_iy_i = 0 （4）$  </p><p>将$（3）$代入拉格朗日函数（2）中，并利用（4），可得：</p><p>$min<em>{w,b}L(w, b, \alpha) = \sum</em>{i=1}^{N} \alpha<em> i -\frac{1}{2}\sum</em>{i=1}^{N}\sum_{j=1}^{N}\alpha_i\alpha_jy_iy_j(x_i \cdot x_j)$  </p><ol><li><strong>求对偶问题，即$min_{w,b}L(w, b, \alpha)$ 对 $\alpha$的极大</strong>：  </li></ol><p>$max<em>\alpha L(\alpha) = \sum</em>{i=1}^{N} \alpha<em> i -\frac{1}{2}\sum</em>{i=1}^{N}\sum_{j=1}^{N}\alpha_i\alpha_jy_iy_j(x_i \cdot x_j) $      (5) </p><p> $s.t. \alpha_i \geq 0$<br>  and   </p><p>  $\sum_{i=1}^{N}\alpha_iy_i=0$.  </p><ol><li><strong>原问题的解</strong>  </li></ol><p>设$\alpha^{*} = (\alpha_1^{*}, \alpha_2^{*}, … , \alpha_l^{*})^T$是对偶最优化问题（2.1,2.2）的解，则存在下标$j$，使得$\alpha_j^{*} \gt 0$，并可按下式求得原始问题的解$w^{*}, b^{*}$：  </p><p>$w^{*} = \sum_{i=1}^{N}\alpha_i^{*}y_ix_i$  </p><p>$b^{*} = y_j -$  </p><p>$\sum \limits_{i=1}^{N} \alpha_i^{*} y_i ( x_i \cdot x_j )$  </p><p>最终得到我们的决策函数：  </p><p>$f(x)=sign(w^{*}x+b^{*})$</p><h3 id="小结：线性可分SVM学习算法"><a href="#小结：线性可分SVM学习算法" class="headerlink" title="小结：线性可分SVM学习算法"></a>小结：线性可分SVM学习算法</h3><p><strong>输入：</strong>  线性可分训练集$T = {(x_1, y_1),  (x_2, y_2), …, (x_N, y_N)}$，其中$x_i\in R^n, y_i \in {+1, -1}, i=1, 2,…,N$  </p><p><strong>输出：</strong> 分离超平面和分类决策函数</p><p>(1) <strong>构造并求解约束最优化问题</strong> </p><p>$\underset{\alpha}{\text{min}} \frac{1}{2} \sum\limits_{i,j}^n \alpha_i \alpha_j y_i y_j (x_i \cdot x<em>j) - \sum\limits</em>{i=1}^{N} \alpha_i$</p><p>$min<em>\alpha \frac{1}{2} \sum</em>{i=1}^{N}\sum_{j=1}^{N}\alpha_i\alpha_jy_iy_j(x_i \cdot x<em>j) - \sum</em>{i=1}^{N}\alpha_i$  </p><p>$s.t. \sum_{i=1}^{N}\alpha_iy_i = 0$</p><p>$\alpha_i \ge 0, i = 1, 2,…,N$</p><p>(2) <strong>计算</strong></p><p>$w^{*} = \sum_{i=1}^{N}\alpha_i^{*}y_ix_i$  </p><p><strong>并选择$\alpha^{*}$的一个正分量$\alpha_j^{*} \gt 0$，计算</strong></p><p>$b^{*}=y_j-$    </p><p>$\sum_{i=1}^{N} \alpha_i^{*} y_i(x_i \cdot x_j)$</p><p>(3)<strong>求得分离超平面</strong></p><p>$w^{*} \cdot x + b^{*} = 0$  </p><p><strong>分离决策函数：</strong> </p><p>$f(x)=$ $sign(w^{*}x+b^{*})$</p><h3 id="附-手写推导过程"><a href="#附-手写推导过程" class="headerlink" title="附: 手写推导过程"></a>附: 手写推导过程</h3><p>结合本图：</p><p><img src="/images/idea_hp.png" alt="Idea HP"></p><p><img src="/images/SVM_hand.png" alt="SVM 手写推导"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;传送门： &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.x-fei.me/2018/12/23/SVM/&quot;&gt;SVM_1&lt;/a&gt;：&lt;/p&gt;
&lt;p&gt;简介与线性可分情况分析，最后附有详细推导过程与注解。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;&quot;&gt;SVM_2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;VC维，非线性可分情况分析，核技巧，软间隔，总结  &lt;/p&gt;
    
    </summary>
    
      <category term="Machine Learning" scheme="http://blog.x-fei.me/categories/Machine-Learning/"/>
    
    
      <category term="algorithm" scheme="http://blog.x-fei.me/tags/algorithm/"/>
    
      <category term="Machine Learning" scheme="http://blog.x-fei.me/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>10-12月</title>
    <link href="http://blog.x-fei.me/2018/12/21/10-12%E6%9C%88/"/>
    <id>http://blog.x-fei.me/2018/12/21/10-12月/</id>
    <published>2018-12-21T06:33:41.000Z</published>
    <updated>2018-12-21T06:39:12.292Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>钱钟书先生说：“似乎我们总是很容易忽略当下的生活，忽略许多美好的时光。而当所有的时光在被辜负被浪费后，才能从记忆里将某一段拎出，拍拍上面沉积的灰尘，感叹它是最好的。”  </p></blockquote><a id="more"></a>  <h2 id="想要"><a href="#想要" class="headerlink" title="想要"></a>想要</h2><p>从8月开始刷LeetCode，刷了200道题，到了10月停了，一直停到2个月后的现在。<br>习惯的养成很难，但抛弃却很容易。<br>当时的目标很明确，这个研究生生活太短了，明年开春就春招了，当初的选择读研就是为了自己有更多的选择，而不是让自己的路越走越窄。<br>这种紧张感、急迫感时常让我感觉自己很没用，于是就陷入了一种很焦灼、颓的恶性循环。  </p><p>时常被随之而来的课程、以及论文的压力挤压，每天早上抽出一两个小时来刷题真的是太奢侈了（也可能因为晚睡所以晚起，所以当刷完题就以及中午，来不及感慨时间过的这么快）。  </p><p>12月17号的凌晨，在老师的帮助下，向一个会议投出了自己第一篇论文。很匆忙。匆忙到，还没有完全修正完。  </p><p>周二凌晨两点投完稿，回到寝室直接睡到了周三中午12点，躺在床上实在无聊，回想了自己的这两个月，忙于应付老师的meeting、task，之间夹带着小组、大组、课程的各种share，以及一些大小作业。</p><p>我清楚地知道自己没有看完AndrewNg的课程、没有看完李宏毅老师的课程，没有读完西瓜书，没有读完《PRML》…… 所以就很想有一段时间可以给自己充电，来补一补这些知识。  </p><p>所以在论文投出之后，依然没有感觉到轻松。  </p><p><strong>这并不是我想要的。</strong>  </p><h2 id="价值"><a href="#价值" class="headerlink" title="价值"></a>价值</h2><p>期间霖哥给我接了个活，给一个小程序写后端，用的是Laravel框架。因为两个人接上一个版本一起写的，所以有三个人的代码风格，以及一堆不规范。甲方对这方面的要求严格，所以后期就重新把所有代码都捋了一遍，格式、命名等等。甲方是一个年收几十亿的大公司，所以，当我们的数据库建表也不过关的时候，又重新弄了一遍。中间有个API是我们用爬虫爬取的一堆不规范的数据支持的，所以爬虫的表改了很久，甚至代码，之后我都一一改了过来。最后是安全问题，sql注入问题，还是考虑的不够全面啊。不过挺感谢霖哥以及智维哥给我这个机会的，又学到了很多。技术、素质以及有效沟通。  </p><p>但是回归到我自己的学业，写后端并不是我的本业，可以说我就是在不务正业了。</p><p><strong>可是，这是我能给的，这是我能给别人提供的价值呀。</strong></p><p><strong>想要</strong>与<strong>能给</strong>。  </p><p>这两个词，是这两年开始思考之后一直想不通透的问题。<br>求不得，无能给。就是这个时期的我的真实写照了。  </p><p>这两个月收到很多豆瓣广州自律小组组长的各种活动邀请，但是都被我给拒绝了。这又是我自身的一个矛盾了，一边想要交更多的朋友，一边在自己的周身筑起高高的城墙。  </p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>有的时候我在想钱钟书先生说的话，我觉得这几年的大学生活唯一遗憾的就是没有学会怎么去生活。  </p><p>生活，活在当下，走向未来。<br>所有的技能都是自己的财富，没有必要去抛弃，它们可以是自己的一些爱好。<br>主业当然要投入最多的精力，慢慢地打磨自己。<br>周末就不要把所有时间都用来和本科同学打游戏了，多出去走走。</p><p>好久不写这种总结性的话，都不会写了，感觉各种语句不通顺。权当是我的碎碎念了。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;钱钟书先生说：“似乎我们总是很容易忽略当下的生活，忽略许多美好的时光。而当所有的时光在被辜负被浪费后，才能从记忆里将某一段拎出，拍拍上面沉积的灰尘，感叹它是最好的。”  &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Fragments" scheme="http://blog.x-fei.me/categories/Fragments/"/>
    
    
      <category term="think" scheme="http://blog.x-fei.me/tags/think/"/>
    
      <category term="life" scheme="http://blog.x-fei.me/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>Python快速创建二维数组 [[0]*n]*n ？</title>
    <link href="http://blog.x-fei.me/2018/12/18/Python-Caveat-About-List-Creation-shortcuts/"/>
    <id>http://blog.x-fei.me/2018/12/18/Python-Caveat-About-List-Creation-shortcuts/</id>
    <published>2018-12-18T03:23:25.000Z</published>
    <updated>2018-12-19T04:00:28.072Z</updated>
    
    <content type="html"><![CDATA[<p>早先在刷Leetcode的时候，遇到了一个莫名的<code>bug</code>，为什么二维数组的元素没有按自己的预期改变呢？<br>当我们这样定义一个二维数组的时候，</p><pre><code class="python">n = <span class="number">3</span>res = [[<span class="number">0</span>] * n] * n</code></pre><p>发生了什么？<br><a id="more"></a><br><code>[0] * n</code> 创建了一个有n个0的<code>list</code>。<br><code>[[0] * n] * n</code> 创建了一个包含n个同一个<code>list</code>的<code>reference</code>。</p><h3 id="Explanation"><a href="#Explanation" class="headerlink" title="Explanation"></a>Explanation</h3><p>我们利用<code>python</code>的<code>id</code>方法查看对象在内存中的地址。</p><h4 id="1D-Array"><a href="#1D-Array" class="headerlink" title="1D Array"></a>1D Array</h4><p>初始化一个指定大小的<code>list</code>很简单：  </p><pre><code class="python"><span class="meta">&gt;&gt;&gt; </span>zeros = [<span class="number">0</span>] * <span class="number">3</span><span class="meta">&gt;&gt;&gt; </span>zeros[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]<span class="meta">&gt;&gt;&gt; </span>id(zeros)<span class="number">4602255816</span><span class="meta">&gt;&gt;&gt; </span>id(zeros[<span class="number">0</span>])<span class="number">4559308816</span><span class="meta">&gt;&gt;&gt; </span>id(<span class="number">0</span>)<span class="number">4559308816</span></code></pre><p>可以看到这里创建一维数组<code>zeros</code>的时候，内部复制了3次0，所以其本身具有一个内存地址，元素的地址则和<code>0</code>的地址相同，和我们预期的一样。</p><h4 id="2D-Array-Wrong"><a href="#2D-Array-Wrong" class="headerlink" title="2D Array (Wrong)"></a>2D Array (Wrong)</h4><p>利用<code>[[0]*n]*n</code> 创建一个二维数组。</p><pre><code class="python"><span class="meta">&gt;&gt;&gt; </span>zeros2d = [[<span class="number">0</span>]*<span class="number">3</span>]*<span class="number">3</span><span class="meta">&gt;&gt;&gt; </span>zeros2d[[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]]<span class="meta">&gt;&gt;&gt; </span>zeros2d[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span> [[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]]</code></pre><p>这??? 只改变一个元素的值，为什么变了三个，还是相同位置的？<br>我们看一下它们的地址。</p><pre><code class="python"><span class="meta">&gt;&gt;&gt; </span>id(zeros2d)<span class="number">4602725512</span><span class="meta">&gt;&gt;&gt; </span>print([id(ele) <span class="keyword">for</span> ele <span class="keyword">in</span> zeros2d])[<span class="number">4600869448</span>, <span class="number">4600869448</span>, <span class="number">4600869448</span>]</code></pre><p>内部的三个一维数组其实是<strong>一个</strong>。</p><p><strong>警告：</strong><br>这里Python对外部的<code>list</code>用了相同的内部<code>list</code>的引用，即本文开篇提到的。<br>其实从元素的地址看来创建一维和二维都一样，都是复制内部对象的引用。  </p><h4 id="2D-Array-right"><a href="#2D-Array-right" class="headerlink" title="2D Array (right)"></a>2D Array (right)</h4><p>知道了问题所在，那么正确的使用方式应该有如下形式：  </p><pre><code class="python">zeros2d = [[<span class="number">0</span>] * <span class="number">3</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">3</span>)]</code></pre><h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><p><a href="https://en.wikibooks.org/wiki/Python_Programming/Lists#List_creation_shortcuts" target="_blank" rel="noopener">Wiki</a><br><a href="https://www.quora.com/Whats-wrong-in-declaring-a-2d-list-in-python-like-this-0-%2An-%2An" target="_blank" rel="noopener">Quora</a>  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;早先在刷Leetcode的时候，遇到了一个莫名的&lt;code&gt;bug&lt;/code&gt;，为什么二维数组的元素没有按自己的预期改变呢？&lt;br&gt;当我们这样定义一个二维数组的时候，&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;n = &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;
res = [[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;] * n] * n
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;发生了什么？&lt;br&gt;
    
    </summary>
    
      <category term="python" scheme="http://blog.x-fei.me/categories/python/"/>
    
    
      <category term="python" scheme="http://blog.x-fei.me/tags/python/"/>
    
      <category term="code" scheme="http://blog.x-fei.me/tags/code/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode Challenge 🏆 Dynamic Programming Problems X 100 ⚡️</title>
    <link href="http://blog.x-fei.me/2018/12/18/LeetCode-Challenge-Dynamic-Programming-Problems-X-100/"/>
    <id>http://blog.x-fei.me/2018/12/18/LeetCode-Challenge-Dynamic-Programming-Problems-X-100/</id>
    <published>2018-12-18T02:00:00.000Z</published>
    <updated>2018-12-25T14:06:13.633Z</updated>
    
    <content type="html"><![CDATA[<p><center> LeetCode Challenge 🏆 </center></p><blockquote><p>挑战目标🎖: 100道DP题<br> <span>&nbsp;&nbsp;&nbsp;</span>时间<span>&nbsp;&nbsp;&nbsp;&nbsp;</span>🗓: <span>&nbsp;</span><del>25/70 （2018-09-13 👉🏻 2018-11-15）</del><br> <span>&nbsp;&nbsp;&nbsp;</span>进度<span>&nbsp;&nbsp;&nbsp;&nbsp;</span>🛴: <span>&nbsp;</span>39/100<br> 成功奖励🍭: ██████████  </p></blockquote><p>Solved: 🥈🥈🥈🥉🥉🥉🥉🥉🥉🥉🥉🥉<br><a id="more"></a><br>Log:<br>18-09-28: 取消每次记录天吧，只记录每周刷了多少道题，感觉时间分配不足了。<br>18-09-30: 决定50道题之后开个part2的记录，不然篇幅太长了，虽然已经很长了。<br>18-10-01～18-12-17: Pause</p><hr><h2 id="Week4"><a href="#Week4" class="headerlink" title="Week4:"></a>Week4:</h2><h3 id="Solved-5-problems"><a href="#Solved-5-problems" class="headerlink" title="Solved 5 problems"></a>Solved 5 problems</h3><h4 id="740-M"><a href="#740-M" class="headerlink" title="740-M"></a>740-M</h4><p><a href="https://leetcode.com/problems/delete-and-earn/" target="_blank" rel="noopener">740. Delete and Earn</a><br>Difficulty: ★★★☆☆<br>Beats: 40.95%<br>Time Complexity: O($n$)   </p><p>Code:  </p><pre><code class="python"><span class="function"><span class="keyword">def</span> <span class="title">deleteAndEarn</span><span class="params">(self, nums)</span>:</span>    <span class="keyword">if</span> <span class="keyword">not</span> nums: <span class="keyword">return</span> <span class="number">0</span>    counter = collections.defaultdict(int)    vis = collections.defaultdict(int)    <span class="keyword">for</span> num <span class="keyword">in</span> nums:        counter[num] += <span class="number">1</span>        vis[num] = <span class="number">1</span>    nums = sorted(list(set(nums)))    <span class="keyword">if</span> len(nums) == <span class="number">1</span>: <span class="keyword">return</span> nums[<span class="number">0</span>]*counter[nums[<span class="number">0</span>]]    dp = [<span class="number">0</span>]*len(nums)    dp[<span class="number">0</span>] = counter[nums[<span class="number">0</span>]]*nums[<span class="number">0</span>]    <span class="keyword">if</span> nums[<span class="number">1</span>] - <span class="number">1</span> != nums[<span class="number">0</span>]:        dp[<span class="number">1</span>] = dp[<span class="number">0</span>] + counter[nums[<span class="number">1</span>]]*nums[<span class="number">1</span>]    <span class="keyword">else</span>:        dp[<span class="number">1</span>] = max(dp[<span class="number">0</span>], counter[nums[<span class="number">1</span>]]*nums[<span class="number">1</span>])    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, len(nums)):        cur = nums[i]*counter[nums[i]]        <span class="keyword">if</span> nums[i]<span class="number">-1</span> != nums[i<span class="number">-1</span>]:            dp[i] = dp[i<span class="number">-1</span>] + cur        <span class="keyword">else</span>:            dp[i] = max(dp[i<span class="number">-1</span>], dp[i<span class="number">-2</span>] + cur)    <span class="keyword">return</span> max(dp)</code></pre><h4 id="377-M"><a href="#377-M" class="headerlink" title="377-M"></a>377-M</h4><p><a href="https://leetcode.com/problems/combination-sum-iv/" target="_blank" rel="noopener">377. Combination Sum IV</a><br>Difficulty: ★★★☆☆<br>Beats: 16.16%<br>Time Complexity: O($n^2$)  </p><p>Code:  </p><pre><code class="python"><span class="function"><span class="keyword">def</span> <span class="title">combinationSum4</span><span class="params">(self, nums, target)</span>:</span>    nums = sorted([num <span class="keyword">for</span> num <span class="keyword">in</span> nums <span class="keyword">if</span> num &lt;= target])    <span class="keyword">if</span> <span class="keyword">not</span> nums: <span class="keyword">return</span> <span class="number">0</span>    res = [<span class="number">0</span>] * (target+<span class="number">1</span>)    res[<span class="number">0</span>] = <span class="number">1</span>    <span class="keyword">for</span> i <span class="keyword">in</span> range(nums[<span class="number">0</span>], target+<span class="number">1</span>, <span class="number">1</span>):        smaller = list(num <span class="keyword">for</span> num <span class="keyword">in</span> nums <span class="keyword">if</span> num &lt;= i)        <span class="keyword">for</span> num <span class="keyword">in</span> smaller:            res[i] += res[i-num]    <span class="keyword">return</span> res[<span class="number">-1</span>]</code></pre><h4 id="962-M"><a href="#962-M" class="headerlink" title="962-M"></a>962-M</h4><p><a href="https://leetcode.com/problems/maximum-width-ramp/" target="_blank" rel="noopener">962. Maximum Width Ramp</a><br>Difficulty: ★★★☆☆    </p><pre><code class="python"><span class="function"><span class="keyword">def</span> <span class="title">maxWidthRamp</span><span class="params">(self, A)</span>:</span>    n = len(A)    res = [<span class="number">0</span>] * n    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):        <span class="comment"># if A[i] &gt;= A[i-1] and res[i-1] != 0:</span>        <span class="comment">#     res[i] = res[i-1] + 1</span>        <span class="comment"># else:</span>        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, i):            <span class="keyword">if</span> A[i] &gt;= A[j]:                res[i] = i - j                <span class="keyword">break</span>    <span class="keyword">return</span> max(res)</code></pre><h4 id="486-M"><a href="#486-M" class="headerlink" title="486-M"></a>486-M</h4><p><a href="https://leetcode.com/problems/predict-the-winner/" target="_blank" rel="noopener">486. Predict the Winner</a><br>Difficulty: ★★★★★<br>Explanation: <a href="https://leetcode.com/problems/predict-the-winner/solution/" target="_blank" rel="noopener">Solution</a><br>Remark: 有的时候就会陷入某一步定住，不知道怎么继续下去。想到分别计算Player1和Player2的最大和关系，sum1 &gt; sum2，却想不到深层或者说再底层的关系，怎么解？(其实还是要回归到DP问题，分析最优子结构、状态、状态转移)  </p><p>Approach #4:<br>最优子结构性质：<br>我们可以观察到，给定子数组<code>nums[x:y]</code>，对当前玩家而言的有效得分只依赖<code>nums</code>整个数组中<code>[x,y]</code>范围内的元素。<br>就看当前玩家本轮取的是<code>nums[x]</code>还是<code>nums[y]</code>，以及取完后另一个玩家用剩余元素可能达到的最高分数。<br>因此，当前有效得分不受<code>[x,y]</code>之外的元素影响。   </p><p>假设我们已知<code>nums[x+1: y]</code> 和 <code>nums[x:y-1]</code>的最大有效得分情况，那么我们就可以轻松得到<code>nums[x:y]</code>的有效的最高得分情况 <code>max(nums[x] - score[x+1][y], nums[y] - score[x][y-1]</code>。  </p><p>因此得到状态方程:<br><code>dp[i, j] = nums[i] - dp[i+1][j], nums[j] - dp[i][j-1]</code>。</p><h4 id="931-M"><a href="#931-M" class="headerlink" title="931-M"></a>931-M</h4><p><a href="https://leetcode.com/problems/minimum-falling-path-sum/" target="_blank" rel="noopener">931. Minimum Falling Path Sum</a><br>Difficulty: ★★★☆☆<br>Beats: 45.24%<br>Time Complexity: O($n^2$)<br>Remark: 最小问题，容易发现状态方程，需要注意边界条件的处理。  </p><p>Explanation:<br>这里定义状态为从顶层落到第<code>i</code>层，第<code>j</code>个元素位置处的最小和。<br>那么对于第<code>i+1</code>层非边界元素位置，其最小值取决于上一层的相邻三个元素<code>i-1</code>,<code>i</code>,<code>i+1</code>的最小值；边界元素只考虑两个相邻元素。<br>容易得到我们的状态方程： <code>res[i+1][j] = A[i+1][j] + min(res[i][j-1], res[i][j], res[i][j+1])</code>。<br>Code:  </p><pre><code class="python"><span class="function"><span class="keyword">def</span> <span class="title">minFallingPathSum</span><span class="params">(self, A)</span>:</span>    <span class="keyword">if</span> <span class="keyword">not</span> A:        <span class="keyword">return</span> <span class="number">0</span>    <span class="keyword">if</span> len(A) == <span class="number">1</span>:        <span class="keyword">return</span> min(A[<span class="number">-1</span>])    size = len(A)    res = [[<span class="number">0</span>]*size <span class="keyword">for</span> i <span class="keyword">in</span> range(size)]    res[<span class="number">0</span>] = A[<span class="number">0</span>]    <span class="keyword">for</span> row <span class="keyword">in</span> range(<span class="number">1</span>, size):        <span class="keyword">for</span> col <span class="keyword">in</span> range(size):            <span class="keyword">if</span> col == <span class="number">0</span>:                res[row][col] = A[row][col] + min(res[row<span class="number">-1</span>][col], res[row<span class="number">-1</span>][col+<span class="number">1</span>])            <span class="keyword">elif</span> col == size - <span class="number">1</span>:                res[row][col] = A[row][col] + min(res[row<span class="number">-1</span>][col<span class="number">-1</span>], res[row<span class="number">-1</span>][col])            <span class="keyword">else</span>:                res[row][col] = A[row][col] + min(res[row<span class="number">-1</span>][col<span class="number">-1</span>], res[row<span class="number">-1</span>][col], res[row<span class="number">-1</span>][col+<span class="number">1</span>])    <span class="keyword">return</span> min(res[<span class="number">-1</span>])</code></pre><hr><hr><h2 id="Week3"><a href="#Week3" class="headerlink" title="Week3:"></a>Week3:</h2><h3 id="Solved-8-problems"><a href="#Solved-8-problems" class="headerlink" title="Solved 8 problems"></a>Solved 8 problems</h3><h4 id="139-M"><a href="#139-M" class="headerlink" title="139-M"></a>139-M</h4><p><a href="https://leetcode.com/problems/word-break/description/" target="_blank" rel="noopener">139. Word Break</a><br>Difficulty：★★★☆☆<br>Beats: 81%<br>Time Complexity: O(nwd)<br>Remark: 思路清晰，DP.  </p><p>Explanation:  </p><div><br>The idea is the following:<br><br>d is an array that contains booleans<br><br>d[i] is True if there is a word in the dictionary that ends at ith index of s AND d is also True at the beginning of the word<br><br>Example:<br><br>s = “leetcode”<br><br>words = [“leet”, “code”]<br><br>d[3] is True because there is “leet” in the dictionary that ends at 3rd index of “leetcode”<br><br>d[7] is True because there is “code” in the dictionary that ends at the 7th index of “leetcode” AND d[3] is True<br><br>The result is the last index of d.<br></div><p>Code:  </p><pre><code class="py"><span class="function"><span class="keyword">def</span> <span class="title">wordBreak</span><span class="params">(self, s, wordDict)</span>:</span>    n = len(s)    dp = [<span class="keyword">False</span>] * n    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):        <span class="keyword">for</span> word <span class="keyword">in</span> wordDict:            <span class="keyword">if</span> word == s[i-len(word)+<span class="number">1</span> : i+<span class="number">1</span>] <span class="keyword">and</span> (dp[i-len(word)] <span class="keyword">or</span> i - len(word) == <span class="number">-1</span>):                dp[i] = <span class="keyword">True</span>                <span class="keyword">break</span>    <span class="keyword">return</span> dp[<span class="number">-1</span>]</code></pre><hr><h4 id="464-M"><a href="#464-M" class="headerlink" title="464-M"></a>464-M</h4><p><a href="https://leetcode.com/problems/can-i-win/description/" target="_blank" rel="noopener">464. Can I Win</a>  </p><blockquote><p>Difficulty：★★★★★<br>Beats: 76%<br>Time Complexity: O(n^2)<br>Remark: 博弈论，以及移位操作表示数字是否用过的状态。不会。  </p></blockquote><p><a href="https://www.liuchuo.net/archives/3155" target="_blank" rel="noopener">liuchou的博客</a></p><p>Code:  </p><pre><code class="py"><span class="function"><span class="keyword">def</span> <span class="title">canIWin</span><span class="params">(self, M, T)</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">win</span><span class="params">(M, T, m, state)</span>:</span>        <span class="keyword">if</span> T &lt;= <span class="number">0</span>: <span class="keyword">return</span> <span class="keyword">False</span>        <span class="keyword">if</span> m[state] != <span class="number">0</span>: <span class="keyword">return</span> m[state] == <span class="number">1</span>        <span class="keyword">for</span> i <span class="keyword">in</span> range(M):        <span class="keyword">if</span> (state &amp; (<span class="number">1</span> &lt;&lt; i)) &gt; <span class="number">0</span>: <span class="keyword">continue</span>        <span class="keyword">if</span> <span class="keyword">not</span> win(M, T - i - <span class="number">1</span>, m, state | (<span class="number">1</span> &lt;&lt; i)):            m[state] = <span class="number">1</span>            <span class="keyword">return</span> <span class="keyword">True</span>        m[state] = <span class="number">-1</span>        <span class="keyword">return</span> <span class="keyword">False</span>    s = M * (M + <span class="number">1</span>) / <span class="number">2</span>    <span class="keyword">if</span> s &lt; T: <span class="keyword">return</span> <span class="keyword">False</span>    <span class="keyword">if</span> T &lt;= <span class="number">0</span>: <span class="keyword">return</span> <span class="keyword">True</span>    <span class="keyword">if</span> s == T: <span class="keyword">return</span> (M % <span class="number">2</span>) == <span class="number">1</span>    m = [<span class="number">0</span>] * (<span class="number">1</span> &lt;&lt; M)    <span class="keyword">return</span> win(M, T, m, <span class="number">0</span>)</code></pre><hr><h4 id="650-M"><a href="#650-M" class="headerlink" title="650-M"></a>650-M</h4><p><a href="https://leetcode.com/problems/2-keys-keyboard/description/" target="_blank" rel="noopener">650. 2 Keys Keyboard</a>  </p><blockquote><p>Difficulty：★★★☆☆<br>Beats: 100%<br>Time Complexity: O(n)<br>Remark: 多尝试几个n，就会发现其中蕴含的规律。  </p></blockquote><p>Explanation:<br>什么时候复制、粘贴？<br>当剩余元素数目是当前已有元素数目的整数倍的时候，如果已复制长度小于已有元素数目，更新复制长度，操作+1，接着复制，反复这个过程，直至剩余元素为0。  </p><pre><code class="py"><span class="function"><span class="keyword">def</span> <span class="title">minSteps</span><span class="params">(self, n)</span>:</span>    res, cpl, ops = <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>    <span class="keyword">if</span> n == <span class="number">1</span>: <span class="keyword">return</span> <span class="number">0</span>    <span class="keyword">if</span> n == <span class="number">2</span>: <span class="keyword">return</span> <span class="number">2</span>    rawn = n    n = n - res    <span class="keyword">while</span> n&gt;<span class="number">0</span>:        <span class="keyword">if</span> n % res == <span class="number">0</span>:            <span class="comment"># do copy</span>            <span class="keyword">if</span> cpl &lt; res:                cpl = res                ops += <span class="number">1</span>        <span class="comment"># do paste</span>        res += cpl        n -= cpl        ops += <span class="number">1</span>    <span class="keyword">return</span> ops</code></pre><hr><h4 id="838-M"><a href="#838-M" class="headerlink" title="838-M"></a>838-M</h4><p><a href="https://leetcode.com/problems/push-dominoes/description/" target="_blank" rel="noopener">838. Push Dominoes</a>  </p><blockquote><p>Difficulty：★★★★☆<br>Beats: 84.30%<br>Time Complexity: O(n)<br>Remark: 理解几种普遍的倒下的情况，O(n)可以做。</p></blockquote><p><strong>Intuition:</strong><br>Whether be pushed or not, depend on the shortest distance to ‘L’ and ‘R’.<br>Also the direction matters.  </p><p>Here is another idea that focus on ‘L’ and ‘R’.<br>‘R……R’ =&gt; ‘RRRRRRRR’<br>‘R……L’ =&gt; ‘RRRRLLLL’ or ‘RRRR.LLLL’<br>‘L……R’ =&gt; ‘L……R’<br>‘L……L’ =&gt; ‘LLLLLLLL’  </p><p>Code:  </p><pre><code class="py"><span class="function"><span class="keyword">def</span> <span class="title">pushDominoes</span><span class="params">(self, d)</span>:</span>    d = <span class="string">'L'</span> + d + <span class="string">'R'</span>    res = []    i = <span class="number">0</span>    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(d)):        <span class="keyword">if</span> d[j] == <span class="string">'.'</span>: <span class="keyword">continue</span>        middle = j - i - <span class="number">1</span>        <span class="keyword">if</span> i: res.append(d[i])        <span class="keyword">if</span> d[i] == d[j]: res.append(d[i] * middle)        <span class="keyword">elif</span> d[i] == <span class="string">'L'</span> <span class="keyword">and</span> d[j] == <span class="string">'R'</span>: res.append(<span class="string">'.'</span> * middle)        <span class="keyword">else</span>: res.append(<span class="string">'R'</span> * (middle / <span class="number">2</span>) + <span class="string">'.'</span> * (middle % <span class="number">2</span>) + <span class="string">'L'</span> * (middle / <span class="number">2</span>))        i = j    <span class="keyword">return</span> <span class="string">''</span>.join(res)</code></pre><hr><h4 id="646-M"><a href="#646-M" class="headerlink" title="646-M"></a>646-M</h4><p><a href="https://leetcode.com/problems/maximum-length-of-pair-chain/description/" target="_blank" rel="noopener">646. Maximum Length of Pair Chain</a>  </p><blockquote><p>Difficulty：★★★☆☆<br>Beats: 40.26%<br>Time Complexity: O(n^2)<br>Remark: 经常性拿到这种二元变量的题有些没思路，学会使用python的lambda；思路还是比较清晰的，用DP的一般步骤套，可以想到怎么做。  </p></blockquote><p>Explanation:<br>首先判断是DP问题：要求最长的chain，符合重复子问题、最优子结构的性质。  </p><p>其次，它的状态，可以定义为到第<code>i</code>个元素时，以它结尾的和它前面的元素能组成的最长链。  </p><p>状态转移，如果<code>pairs[i]</code>能放在<code>pairs[i-1]</code>后面，那么它最长就是在前者基础上加1。<br>如果不能，我们就需要找到那个能放的，因此需要遍历<code>0...i-2</code>个元素，找到即可。</p><p>Code:  </p><pre><code class="py"><span class="function"><span class="keyword">def</span> <span class="title">findLongestChain</span><span class="params">(self, pairs)</span>:</span>    pairs.sort(key=<span class="keyword">lambda</span> r:r[<span class="number">0</span>])    n = len(pairs)    dp = [<span class="number">0</span>]*n    dp[<span class="number">0</span>] = <span class="number">1</span>    <span class="keyword">if</span> pairs[<span class="number">1</span>][<span class="number">0</span>] &gt; pairs[<span class="number">0</span>][<span class="number">1</span>]:        dp[<span class="number">1</span>] = dp[<span class="number">0</span>] + <span class="number">1</span>    <span class="keyword">else</span>:        dp[<span class="number">1</span>] = <span class="number">1</span>    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n):        <span class="keyword">if</span> pairs[i][<span class="number">0</span>] &gt; pairs[i<span class="number">-1</span>][<span class="number">1</span>]:            dp[i] = dp[i<span class="number">-1</span>] + <span class="number">1</span>        <span class="keyword">else</span>:            j = i - <span class="number">2</span>            <span class="keyword">while</span> j &gt; <span class="number">-1</span>:                <span class="keyword">if</span> pairs[j][<span class="number">1</span>] &lt; pairs[i][<span class="number">0</span>]:                    <span class="keyword">break</span>                j -= <span class="number">1</span>            dp[i] = dp[j] + <span class="number">1</span>    <span class="keyword">return</span> dp[<span class="number">-1</span>]</code></pre><hr><h4 id="221-M"><a href="#221-M" class="headerlink" title="221-M"></a>221-M</h4><p><a href="https://leetcode.com/problems/maximal-square/description/" target="_blank" rel="noopener">221. Maximal Square</a>  </p><blockquote><p>Difficulty：★★★☆☆<br>Beats: 67.54%<br>Time Complexity: O(nm)<br>Remark: 多举几个例子就能发现背后的状态方程了，不算难。  </p></blockquote><p>Explanation:<br>假定状态是以<code>s[i][j]</code>作为右下角的符合条件的正方形的边长<code>dp[i][j]</code>，那么它由周围哪几个状态决定呢？  </p><blockquote><p>[[“1”,”0”,”1”,”0”,”0”],[“1”,”0”,”1”,”1”,”1”],[“1”,”1”,”1”,”1”,”1”],[“1”,”0”,”0”,”1”,”0”]]<br>[[“1”,”0”],[“0”,”0”]]<br>[[“1”,”0”,”1”,”0”],[“1”,”0”,”1”,”1”],[“1”,”0”,”1”,”1”],[“1”,”1”,”1”,”1”]]<br>[[“0”,”0”,”0”,”1”],[“1”,”1”,”0”,”1”],[“1”,”1”,”1”,”1”],[“0”,”1”,”1”,”1”],[“0”,”1”,”1”,”1”]]  </p></blockquote><p>给出上面4个例子，其结果是4，1，4，9。自己尝试推导一下。  </p><p>Code:  </p><pre><code class="py"><span class="function"><span class="keyword">def</span> <span class="title">maximalSquare</span><span class="params">(self, matrix)</span>:</span>    <span class="keyword">if</span> <span class="keyword">not</span> matrix: <span class="keyword">return</span> <span class="number">0</span>    n = len(matrix)    m = len(matrix[<span class="number">0</span>])    dp = [[<span class="number">0</span>] * (m+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(n+<span class="number">1</span>)]    res = <span class="number">0</span>    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>):        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, m+<span class="number">1</span>):            <span class="keyword">if</span> matrix[i<span class="number">-1</span>][j<span class="number">-1</span>] == <span class="string">"1"</span>:                dp[i][j] = min(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>], dp[i<span class="number">-1</span>][j<span class="number">-1</span>]) + <span class="number">1</span>                res = max(res, dp[i][j])    <span class="keyword">return</span> res*res</code></pre><hr><h4 id="091-M"><a href="#091-M" class="headerlink" title="091-M"></a>091-M</h4><p><a href="https://leetcode.com/problems/decode-ways/description/" target="_blank" rel="noopener">91. Decode Ways</a>  </p><blockquote><p>Difficulty：★★☆☆☆<br>Beats: 100%<br>Time Complexity: O(n)<br>Remark: 注意对‘0’进行特殊处理，简单DP。  </p></blockquote><p>Code:  </p><pre><code class="py"><span class="function"><span class="keyword">def</span> <span class="title">numDecodings</span><span class="params">(self, s)</span>:</span>    d = [<span class="number">0</span>]*(len(s)+<span class="number">1</span>)    d[<span class="number">0</span>] = <span class="number">1</span>    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(d)):        <span class="keyword">if</span> s[i<span class="number">-1</span>] != <span class="string">'0'</span>:            d[i] += d[i<span class="number">-1</span>]        <span class="keyword">if</span> (i &gt; <span class="number">1</span>) <span class="keyword">and</span> (<span class="string">'09'</span> &lt; s[i<span class="number">-2</span>:i] &lt; <span class="string">'27'</span>):            d[i] += d[i<span class="number">-2</span>]                  <span class="keyword">return</span> d[<span class="number">-1</span>]</code></pre><hr><h4 id="152-M"><a href="#152-M" class="headerlink" title="152-M"></a>152-M</h4><p><a href="https://leetcode.com/problems/maximum-product-subarray/description/" target="_blank" rel="noopener">152. Maximum Product Subarray</a>  </p><blockquote><p>Difficulty：★★★☆☆<br>Beats: 47.25%<br>Time Complexity: O(n)<br>Remark: 写了一段程序只有最后一个样例过不了，很长的一个数组，15000，超内存应该是其次，最主要还是算法不够好，而且优化的方向就在内存上，为什么会需要<code>n^2</code>的内存。以及，之前的最大和最小在当前数为负数时的转化，题目的思考还是不够深入。</p></blockquote><p>Code:  </p><pre><code class="py"><span class="function"><span class="keyword">def</span> <span class="title">maxProduct</span><span class="params">(self, nums)</span>:</span>    n = len(nums)    res = nums[<span class="number">0</span>]    rx, rm = nums[<span class="number">0</span>], nums[<span class="number">0</span>]    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):        <span class="keyword">if</span> nums[i] &lt; <span class="number">0</span>:            tmp = rx            rx = rm            rm = tmp        rx = max(nums[i], nums[i]*rx)        rm = min(nums[i], nums[i]*rm)        res = max(res, rx)    <span class="keyword">return</span> res</code></pre><hr><h2 id="Week2"><a href="#Week2" class="headerlink" title="Week2"></a>Week2</h2><p>中秋放假，就这么混吗？路那么长，多停一天，可能就走不完了。<br>Solved 8 problems.  </p><h3 id="Day14"><a href="#Day14" class="headerlink" title="Day14"></a>Day14</h3><p><strong>Date: 18-09-26</strong>  </p><h4 id="718-M"><a href="#718-M" class="headerlink" title="718-M"></a>718-M</h4><p><a href="https://leetcode.com/problems/maximum-length-of-repeated-subarray/description/" target="_blank" rel="noopener">718. Maximum Length of Repeated Subarray</a>    </p><blockquote><p>Difficulty：★★★☆☆<br>Beats: 63.52%<br>Time Complexity: O(mn)<br>Remark: 简单题。最长公共子串。  </p></blockquote><p>Explanation:<br>尝试考虑以<code>B[i]</code>结尾的<code>B[:i+1]</code>子串和<code>A</code>串的关系，迭代<code>A</code>，若<code>A[j] == B[i]</code>，那么比较内部的串。<br>即状态方程：  <code>dp[i][j] = dp[i-1][j-1] + 1 if B[i] == A[j]</code></p><p>Code:  </p><pre><code class="py"><span class="function"><span class="keyword">def</span> <span class="title">findLength</span><span class="params">(self, A, B)</span>:</span>    n1, n2 = len(A), len(B)    dp = [[<span class="number">0</span>] * (n1+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(n2+<span class="number">1</span>)]    res = <span class="number">0</span>    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n2+<span class="number">1</span>):        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n1+<span class="number">1</span>):            <span class="keyword">if</span> B[i<span class="number">-1</span>] == A[j<span class="number">-1</span>]:                dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>                res = max(res, dp[i][j])         <span class="keyword">return</span> res</code></pre><hr><h3 id="Day13"><a href="#Day13" class="headerlink" title="Day13"></a>Day13</h3><p><strong>Date: 18-09-25</strong>  </p><h4 id="494-M"><a href="#494-M" class="headerlink" title="494-M"></a>494-M</h4><p><a href="https://leetcode.com/problems/target-sum/description/" target="_blank" rel="noopener">494. Target Sum</a>  </p><blockquote><p>Difficulty：★★★★☆<br>Beats: 49.57%<br>Time Complexity: ?<br>Remark: dp + dfs，这里的dp的自顶向下算法就是dfs，但是需要做memorization，否则会出现TLE。  </p></blockquote><p>Explanation:<br>以第i位置，以及可能在这个位置出现的<code>和</code>，两个值的<code>tuple</code>作为key，节约时间空间。</p><p>Code:  </p><pre><code class="py"><span class="function"><span class="keyword">def</span> <span class="title">findTargetSumWays</span><span class="params">(self, nums, S)</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">memoization</span><span class="params">(i, S)</span>:</span>        <span class="keyword">if</span> i == <span class="number">0</span>:            <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> S == <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span>        <span class="keyword">elif</span> (i,S) <span class="keyword">in</span> dic:            <span class="keyword">return</span> dic[i, S]        res = memoization(i<span class="number">-1</span>, S-nums[i<span class="number">-1</span>]) + memoization(i<span class="number">-1</span>, S+nums[i<span class="number">-1</span>])        dic[i, S] = res        <span class="keyword">return</span> res    dic = {}    <span class="keyword">return</span> memoization(len(nums), S)</code></pre><hr><h3 id="Day12"><a href="#Day12" class="headerlink" title="Day12"></a>Day12</h3><p><strong>Date: 18-09-24</strong>  </p><h4 id="516-M"><a href="#516-M" class="headerlink" title="516-M"></a>516-M</h4><p><a href="https://leetcode.com/problems/longest-palindromic-subsequence/description/" target="_blank" rel="noopener">516. Longest Palindromic Subsequence</a>  </p><blockquote><p>Difficulty：★★★☆☆<br>Beats: \<br>Time Complexity: O(n^2)<br>Space Complexity: O(n^2)<br>Remark: 要么就是python3的执行评判有问题，要么就是python3的执行是真的慢。算法的想法挺简单的，属于那种制表就可以完成的。  </p></blockquote><p>Explanation:<br>我们假设从i位置开始，长度为<code>l</code>的子串<code>subs</code>（这里是子串，不是子序列），现在需要判断<code>subs</code>的最长回文子序列，先判断首尾是否相同：相同则首尾同时向内缩进1位，继续判断。<br>自底向上的做法，需要我们将长度<code>l</code>从2一直迭代至<code>len(s)</code>。  </p><p><em>Formula</em>:<br><code>T[i][j] = T[i+1][j-1] + 2 if s[i] == s[j] else max(T[i+1][j], T[i][j-1])</code></p><p>Code:  </p><pre><code class="py"><span class="comment"># submit this using python, not python3</span><span class="function"><span class="keyword">def</span> <span class="title">longestPalindromeSubseq</span><span class="params">(self, s)</span>:</span>    n = len(s)    dp = [[<span class="number">0</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):        dp[i][i] = <span class="number">1</span>    <span class="keyword">for</span> l <span class="keyword">in</span> range(<span class="number">2</span>, n+<span class="number">1</span>):        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, n - l + <span class="number">1</span>):            j = i + l - <span class="number">1</span>            <span class="keyword">if</span> l == <span class="number">2</span> <span class="keyword">and</span> s[i] == s[j]:                dp[i][j] = <span class="number">2</span>            <span class="keyword">elif</span> s[i] == s[j]:                dp[i][j] = dp[i+<span class="number">1</span>][j<span class="number">-1</span>] + <span class="number">2</span>            <span class="keyword">else</span>:                dp[i][j] = max(dp[i+<span class="number">1</span>][j], dp[i][j<span class="number">-1</span>])    <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">-1</span>]</code></pre><hr><h3 id="Day11"><a href="#Day11" class="headerlink" title="Day11"></a>Day11</h3><p><strong>Date: 18-09-23</strong>  </p><h4 id="120-M"><a href="#120-M" class="headerlink" title="120-M"></a>120-M</h4><p><a href="https://leetcode.com/problems/triangle/description/" target="_blank" rel="noopener">120. Triangle</a></p><blockquote><p>Difficulty：★★★☆☆<br>Beats: 72.33%<br>Time Complexity: O(n^2)<br>Space Complexity: O(n)<br>Remark: 标准DP问题。</p></blockquote><p>Explanation:  </p><ul><li><p><em>Step1: 判断</em><br>最小化问题，满足两个性质，可以用DP解。</p></li><li><p><em>Step2: 状态</em><br>首先我们不可能从底向上，从最后一层最小的点往上找的。<br>这样的话，就会想知道，比如到第k层第i个元素，想知道到前k-1层第i/i-1个元素那里哪一个最小。<br>所以状态可以定义为到第k层第i个元素</p></li><li><p><em>Step3: 状态方程</em><br>我们需要迭代整个n，去寻找<code>[start, end]</code>的分割位置k，在k位置的时候，计算它的最坏情况，即<code>max(dp[start, k-1], dp[k+1, end]) + k</code>，现在我们想要的最终结果就是所有这样的k中最小的。  </p></li><li><p><em>Step4: Tabulation or Memorizatio</em><br>有两种做法，一种是存储N个结果，另一种是直接修改原数组。</p><pre><code class="py"><span class="function"><span class="keyword">def</span> <span class="title">minimumTotal</span><span class="params">(self, triangle)</span>:</span>  <span class="comment"># res = [0]*len(triangle)</span>  <span class="comment"># res[0] = triangle[0][0]</span>  <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(triangle)):      <span class="comment"># cur = [x for x in res]</span>      <span class="keyword">for</span> j <span class="keyword">in</span> range(len(triangle[i])):          <span class="keyword">if</span> j<span class="number">-1</span> &lt; <span class="number">0</span>:              upmin = triangle[i<span class="number">-1</span>][j]          <span class="keyword">elif</span> j &gt;= len(triangle[i<span class="number">-1</span>]):              upmin = triangle[i<span class="number">-1</span>][j<span class="number">-1</span>]          <span class="keyword">else</span>:              upmin = min(triangle[i<span class="number">-1</span>][j], triangle[i<span class="number">-1</span>][j<span class="number">-1</span>])          triangle[i][j] += upmin      <span class="comment"># print(res)</span>  <span class="keyword">return</span> min(triangle[<span class="number">-1</span>])</code></pre></li></ul><hr><h3 id="Day10"><a href="#Day10" class="headerlink" title="Day10"></a>Day10</h3><p><strong>Date: 18-09-22</strong>  </p><h4 id="375-M"><a href="#375-M" class="headerlink" title="375-M"></a>375-M</h4><p><a href="https://leetcode.com/problems/guess-number-higher-or-lower-ii/description/" target="_blank" rel="noopener">375. Guess Number Higher or Lower II</a>  </p><blockquote><p>Difficulty：★★★☆☆<br>Beats: 15.63%<br>Time Complexity: O(n^2)<br>Remark: 题目表述有点晦涩。又是可以用两个数字表示字典key的一道题。  </p></blockquote><p>Explanation:<strong>源: <a href="https://leetcode.com/problems/guess-number-higher-or-lower-ii/discuss/84766/Clarification-on-the-problem-description.-Problem-description-need-to-be-updated-!!!" target="_blank" rel="noopener">xuehaohu</a></strong>    </p><ul><li><p><em>Step1: 判断</em><br>最后我们需要找出<code>how much money you need to have to guarantee a win</code>，保证赢，至少需要多少钱，看起来像是需要最大化某个量又需要最小化另外某个量的问题。</p></li><li><p><em>Step2: 状态</em><br>如果只有一个数，那么不用猜，代价是0；  </p></li></ul><p>如果有两个数，比如<code>[5, 6]</code>，最小的代价是5：我们有两种方法去猜，一是猜5，猜中代价为0，猜不中代价为5，这种情况下需要付出的代价是5（想一想为什么）；另一种是猜6，猜中代价为0，猜不中代价为6。综合两种情况，猜中的最小代价是5;  </p><p>如果有三个数，比如<code>[3, 4, 5]</code>，我们猜中的最小代价一定是4。  </p><p>以此类推，对于更大的范围，我们可以将其划分成多个小的范围，这就符合DP问题的定义了。<br>我们可以定义状态为从<code>start</code>到<code>end</code>需要付出的最小代价。  </p><ul><li><p><em>Step3: 状态方程</em><br>我们需要迭代整个n，去寻找<code>[start, end]</code>的分割位置k，在k位置的时候，计算它的最坏情况，即<code>max(dp[start, k-1], dp[k+1, end]) + k</code>，现在我们想要的最终结果就是所有这样的k中最小的。  </p></li><li><p><em>Step4: Tabulation or Memorizatio</em>  </p></li></ul><p>Code:  </p><pre><code class="py"><span class="function"><span class="keyword">def</span> <span class="title">getMoneyAmount</span><span class="params">(self, n)</span>:</span>    dp = {}    <span class="function"><span class="keyword">def</span> <span class="title">getMA</span><span class="params">(l, r)</span>:</span>        <span class="keyword">if</span> l &gt; r:            <span class="keyword">return</span> <span class="number">0</span>        <span class="keyword">if</span> (l, r) <span class="keyword">in</span> dp:            <span class="keyword">return</span> dp[l, r]        <span class="keyword">if</span> r == l:            dp[l, r] = <span class="number">0</span>            <span class="keyword">return</span> dp[l, r]        <span class="keyword">if</span> r-l == <span class="number">1</span>:            dp[l, r] = l            <span class="keyword">return</span> dp[l, r]        dp[l, r] = r*r        <span class="keyword">for</span> i <span class="keyword">in</span> range(l, r):            dp[l, r] = min(dp[l,r], i + max(getMA(l, i<span class="number">-1</span>),getMA(i+<span class="number">1</span>, r)))        <span class="keyword">return</span> dp[l, r]    <span class="keyword">return</span> getMA(<span class="number">1</span>, n)</code></pre><hr><h3 id="Day9"><a href="#Day9" class="headerlink" title="Day9"></a>Day9</h3><p><strong>Date: 18-09-21</strong><br>数值分析上到今天终于跟不上了，看来假期需要补一补了，不然就真废了。今天的组会开的很不尽兴，各种事故。</p><h4 id="712-M"><a href="#712-M" class="headerlink" title="712-M"></a>712-M</h4><p><a href="https://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/description/" target="_blank" rel="noopener">712. Minimum ASCII Delete Sum for Two Strings</a>  </p><blockquote><p>Difficulty：★★★★☆<br>Beats: 11.11%<br>Time Complexity: O(n^2)<br>Remark: 思路较为简单。本题基于最长公共子序列的解法，只不过状态的内容由公共子序列的长度变成了需要删除字母的代价。<br>Explanation:  </p><ul><li><em>Step1: 判断</em><br>最小化删除的字母和，是DP问题  </li></ul></blockquote><ul><li><p><em>Step2: 状态</em><br>匹配到<code>str1[j]</code>和<code>str2[i]</code>需要删除的代价，即<code>str1[:j]</code>和<code>str2[:i]</code>需要删除的字母ascii码和，设为<code>dp[i][j]</code>。</p></li><li><p><em>Step3: 状态方程</em><br>由状态之间的传递关系，如果<code>str1[j] == str2[i]</code> ，那么它们俩可以不用删除，需要考虑的是<code>str1[:j-1], str2[:i-1]</code>这两个串之间的关系，它们的关系由<code>dp[i-1][j-1]</code>给出；<br>如果<code>str1[j]</code>和<code>str2[i]</code>不同，直观想法是把这两个字符都删除了，但这样需要付出的代价无疑是<br>最大的（<code>dp[i-1][j-1] + str2[i] + str1[j]</code>），考虑，如果只删除<code>str1[j]</code>，那么问题转化为<code>str1[:j-1]</code>和<code>str2[:i]</code>进行匹配，它们需要付出的代价就是<code>dp[i][j-1] + str1[j]</code>，同理，删除<code>str2[i]</code>需要付出的代价<br>是<code>dp[i-1][j] + str2[i]</code>，二者取较小者即可。所以状态方程定义如下：<br><code>if str1[j] == str2[i]: dp[i][j] = dp[i-1][j-1]</code><br><code>if str1[j] != str2[i]: dp[i][j] = max(dp[i][j-1] + str1[j],dp[i-1][j] + str2[i])</code></p></li><li><p><em>Step4: Tabulation or Memorizatio</em><br>实现的时候，为了计算方便，多增加一行一列。</p></li></ul><p>Code:  </p><pre><code class="py"><span class="function"><span class="keyword">def</span> <span class="title">minimumDeleteSum</span><span class="params">(self, s1, s2)</span>:</span>    l1, l2 = len(s1), len(s2)    dp = [[<span class="number">0</span>]*(l1 + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(l2 + <span class="number">1</span>)]    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, l1+<span class="number">1</span>):        dp[<span class="number">0</span>][i] += dp[<span class="number">0</span>][i<span class="number">-1</span>] + ord(s1[i<span class="number">-1</span>])    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, l2+<span class="number">1</span>):        dp[i][<span class="number">0</span>] += dp[i<span class="number">-1</span>][<span class="number">0</span>] + ord(s2[i<span class="number">-1</span>])    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, l2+<span class="number">1</span>):        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, l1+<span class="number">1</span>):            <span class="keyword">if</span> s2[i<span class="number">-1</span>] == s1[j<span class="number">-1</span>]:                dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]            <span class="keyword">else</span>:                dp[i][j] = min(dp[i<span class="number">-1</span>][j] + ord(s2[i<span class="number">-1</span>]), dp[i][j<span class="number">-1</span>] + ord(s1[j<span class="number">-1</span>]))    <span class="keyword">return</span> dp[l2][l1]</code></pre><hr><h3 id="Day8"><a href="#Day8" class="headerlink" title="Day8"></a>Day8</h3><p><strong>Date: 18-09-20</strong><br>失了智的一天，两道题没有一道想出来的。差评，菜🐶。这两道题属于同一类型的，值得再刷！</p><h4 id="813-M"><a href="#813-M" class="headerlink" title="813-M"></a>813-M</h4><p><a href="https://leetcode.com/problems/largest-sum-of-averages/description/" target="_blank" rel="noopener">813. Largest Sum of Averages</a>  </p><blockquote><p>Difficulty：★★★★☆<br>Beats: &lt;20%<br>Time Complexity: O(Kn^2)<br>Remark: 如果没有直接思路，从笨方法入手深入理解题意，然后再想想哪里可以提升。  </p></blockquote><p>Explanation:(参考lee215的题解)<br><strong>如何寻找状态？</strong><br>我们有一个数组，至多可以分成K个连续的部分，然后对每个部分求平均再累加，求这个最大值。<br>K个连续的部分，如何分割呢，我们可以以每个部分最后一个元素的位置作为分割点（至于为什么这么想，因为标志位置就只有每部分的开头和结尾元素，二者选其一而已）。<br>现在假设我们分割了倒数一部分元素，那么整个数据集被我们分割成了最后一部分，以及前面k-1个部分，那么它的值便可以用下面的式子表达：<br><code>dp[n,k] = max(dp[n, k], dp[i, k-1] + sum(A[i:n])/float(n-i)), i=n-1,...,0</code><br>由此可以用递归求解本题。<br>(PS: lee215是真的喜欢用set的key来保存状态（：).</p><p>Code:  </p><pre><code class="py"><span class="function"><span class="keyword">def</span> <span class="title">largestSumOfAverages</span><span class="params">(self, A, K)</span>:</span>    memo = {}    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(n, k)</span>:</span>        <span class="keyword">if</span> (n, k) <span class="keyword">in</span> memo: <span class="keyword">return</span> memo[n, k]        <span class="keyword">if</span> n &lt; k: <span class="keyword">return</span> <span class="number">0</span>        <span class="keyword">if</span> k == <span class="number">1</span>:            memo[n, k] = sum(A[:n]) / float(n)            <span class="keyword">return</span> memo[n, k]        cur, memo[n, k] = <span class="number">0</span>, <span class="number">0</span>        <span class="keyword">for</span> i <span class="keyword">in</span> range(n - <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>):            cur += A[i]            memo[n, k] = max(memo[n, k], search(i, k - <span class="number">1</span>) + cur / float(n - i))        <span class="keyword">return</span> memo[n, k]    <span class="keyword">return</span> search(len(A), K)</code></pre><hr><h4 id="873-M"><a href="#873-M" class="headerlink" title="873-M"></a>873-M</h4><p><a href="https://leetcode.com/problems/length-of-longest-fibonacci-subsequence/description/" target="_blank" rel="noopener">873. Length of Longest Fibonacci Subsequence</a>  </p><blockquote><p>Difficulty：★★★★☆<br>Beats: 73.98%<br>Time Complexity: O(n^2)<br>Remark: 如果DP的掌握程度可以量化的话，我觉得我才走到25%，状态和状态转移方程真TM神奇，同时也明确提醒自己状态不一定连续。  </p></blockquote><p>Explanation:(参考lee215的题解)<br>首先我们明确一点，<strong>已知类斐波那契数列的连续两个数之后，可以推导出规定范围内所有属于它的数。</strong><br>基于这一点，我们的状态可以基于<code>类斐波那契数列的连续两个数</code>来设置，即令<code>dp[a, b]</code>表示以数<code>(a, b)</code>为结尾的类斐波那契数列。<br>如此，我们的状态方程可以设置为：<code>dp[a, b] = (dp[b-a, a] + 1) or 2</code>。  </p><p>Code:  </p><pre><code class="py"><span class="function"><span class="keyword">def</span> <span class="title">lenLongestFibSubseq</span><span class="params">(self, A)</span>:</span>    dp = collections.defaultdict(int)    s = set(A)    res = <span class="number">0</span>    <span class="keyword">for</span> j <span class="keyword">in</span> xrange(len(A)):        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(j):            <span class="keyword">if</span> A[j] - A[i] &lt; A[i] <span class="keyword">and</span> A[j] - A[i] <span class="keyword">in</span> s:                dp[A[i], A[j]] = dp.get((A[j] - A[i], A[i]), <span class="number">2</span>) + <span class="number">1</span>                res = max(res, dp[A[i], A[j]])    <span class="keyword">return</span> max(dp.values() <span class="keyword">or</span> [<span class="number">0</span>])</code></pre><hr><h2 id="Week1"><a href="#Week1" class="headerlink" title="Week1"></a>Week1</h2><p>Solved 18 problems.</p><h3 id="Day7"><a href="#Day7" class="headerlink" title="Day7"></a>Day7</h3><p><strong>Date: 18-09-19</strong>  </p><h4 id="064-M"><a href="#064-M" class="headerlink" title="064-M"></a>064-M</h4><p><a href="https://leetcode.com/problems/minimum-path-sum/description/" target="_blank" rel="noopener">64. Minimum Path Sum</a>  </p><blockquote><p>Difficulty：★★☆☆☆<br>Beats: 48.92%<br>Time Complexity: O(n^2)<br>Remark: 属于比较简单的基础DP题，模拟一遍就知道状态方程了。  </p></blockquote><p>Explanation:<br>状态定义为走到当前位置需要的最少步数<code>dp[i][j]</code>。<br>由规则可知，当前步往下一步走，只能向下或者向右，因此可以推得状态方程：<br><code>dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]</code>。</p><p>Code:  </p><pre><code class="py"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">minPathSum</span><span class="params">(self, grid)</span>:</span>        <span class="string">"""</span><span class="string">        :type grid: List[List[int]]</span><span class="string">        :rtype: int</span><span class="string">        """</span>        n = len(grid)        m = len(grid[<span class="number">0</span>])        dp = [[<span class="number">0</span>]*m <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]        dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>]        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m):            dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i<span class="number">-1</span>] + grid[<span class="number">0</span>][i]        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):            dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>] + grid[i][<span class="number">0</span>]        <span class="comment"># print(dp)</span>        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, m):                dp[i][j] = min(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>]) + grid[i][j]        <span class="comment"># print(dp)</span>        <span class="keyword">return</span> dp[n<span class="number">-1</span>][m<span class="number">-1</span>]</code></pre><hr><h4 id="300-M"><a href="#300-M" class="headerlink" title="300-M"></a>300-M</h4><p><a href="https://leetcode.com/problems/longest-increasing-subsequence/description/" target="_blank" rel="noopener">300. Longest Increasing Subsequence</a>  </p><blockquote><p>Difficulty：★★☆☆☆<br>Beats: 11.25%<br>Time Complexity: O(n^2)<br>Remark: 十分典型的DP题，求最长递增子序列。  </p></blockquote><p>Explanation:<br>定义状态为在第<code>i</code>个元素时以它结尾的最长递增子序列的长度<code>T[i]</code>。<br>求解<code>T[i]</code>时，我们需要寻找前<code>i</code>个元素中比<code>nums[i]</code>小的最大<code>T[k]</code>。<br>则状态方程为：<br><code>T[i] = max(T[i], T[k] + 1) k=i-1,...,0</code>  </p><p>Code:  </p><pre><code class="py"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLIS</span><span class="params">(self, nums)</span>:</span>        <span class="string">"""</span><span class="string">        :type nums: List[int]</span><span class="string">        :rtype: int</span><span class="string">        """</span>        <span class="keyword">if</span> <span class="keyword">not</span> nums: <span class="keyword">return</span> <span class="number">0</span>        n = len(nums)        res = [<span class="number">1</span>]*n        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):            tmp = res[i]            <span class="keyword">for</span> j <span class="keyword">in</span> range(i<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):                <span class="keyword">if</span> nums[j] &lt; nums[i]:                    tmp = max(tmp, res[j] + <span class="number">1</span>)            res[i] = tmp        <span class="keyword">return</span> max(res)</code></pre><hr><h4 id="416-M"><a href="#416-M" class="headerlink" title="416-M"></a>416-M</h4><p><a href="https://leetcode.com/problems/partition-equal-subset-sum/description/" target="_blank" rel="noopener">416. Partition Equal Subset Sum</a>  </p><blockquote><p>Difficulty：★★★☆☆<br>Beats: 0%<br>Time Complexity: O(n^2)<br>Remark: 我觉得这题python的判法有问题，同样的思路，复杂度，我递归和制表两种方法都试了，疯狂TLE，太真实了。  </p></blockquote><p>Explanation:<br>这题的思路相对简单，要将数据集划分为两个和相等的的子数据集，那么和<code>sum</code>肯定是偶数，奇数和直接返回错。<br>这个时候问题转化为，求<code>subset sum</code>，指定<code>sum</code>，是否存在子集满足和等于它。  </p><p>对于<code>subset sum</code>这个问题，比较经典。  </p><pre>Let isSubSetSum(int set[], int n, int sum) be the function to find whether there is a subset of set[] with sum equal to sum. n is the number of elements in set[].The isSubsetSum problem can be divided into two subproblems…a) Include the last element, recur for n = n-1, sum = sum – set[n-1]…b) Exclude the last element, recur for n = n-1.If any of the above the above subproblems return true, then return true.</pre><p>这题贴没AC的代码，看同样的思路改写成C++有没有问题🙃<br>Code:  </p><pre><code class="py"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">canPartition</span><span class="params">(self, nums)</span>:</span>        <span class="string">"""</span><span class="string">        :type nums: List[int]</span><span class="string">        :rtype: bool</span><span class="string">        """</span>        nsum = sum(nums)        <span class="keyword">if</span> nsum % <span class="number">2</span> == <span class="number">1</span>:            <span class="keyword">return</span> <span class="keyword">False</span>        n = len(nums)        half = int(nsum/<span class="number">2</span>)        <span class="function"><span class="keyword">def</span> <span class="title">subsetSum</span><span class="params">(target, ns)</span>:</span>            <span class="keyword">if</span> target == <span class="number">0</span>: <span class="keyword">return</span> <span class="keyword">True</span>            <span class="keyword">if</span> <span class="keyword">not</span> ns: <span class="keyword">return</span> <span class="keyword">False</span>            <span class="keyword">if</span> ns[<span class="number">-1</span>] &gt; target:                <span class="keyword">return</span> subsetSum(target, ns[:<span class="number">-1</span>])            <span class="keyword">return</span> subsetSum(target-ns[<span class="number">-1</span>], ns[:<span class="number">-1</span>]) <span class="keyword">or</span> subsetSum(target, ns[:<span class="number">-1</span>])        <span class="keyword">return</span> subsetSum(half, nums)        <span class="comment"># dp = [[0]*(half+1) for _ in range(n)]</span>        <span class="comment"># for i in range(n):</span>        <span class="comment">#     dp[i][0] = 1</span>        <span class="comment"># for i in range(1, half+1):</span>        <span class="comment">#     if i == nums[0]:</span>        <span class="comment">#         dp[0][i] = 1</span>        <span class="comment"># for i in range(1, n):</span>        <span class="comment">#     for j in range(1, half+1):</span>        <span class="comment">#         if j &lt; nums[i]:</span>        <span class="comment">#             dp[i][j] = dp[i-1][j]</span>        <span class="comment">#         else:</span>        <span class="comment">#             dp[i][j] = dp[i-1][j] or dp[i-1][j-nums[i]]</span>        <span class="comment"># if dp[n-1][half]:</span>        <span class="comment">#     return True</span>        <span class="comment"># return False</span></code></pre><hr><h3 id="Day6"><a href="#Day6" class="headerlink" title="Day6"></a>Day6</h3><p><strong>Date: 18-09-18</strong>  </p><h4 id="343-M"><a href="#343-M" class="headerlink" title="343-M"></a>343-M</h4><p><a href="https://leetcode.com/problems/is-subsequence/description/" target="_blank" rel="noopener">343. Integer Break</a>  </p><blockquote><p>Difficulty：★★☆☆☆<br>Beats: 36.83%<br>Time Complexity: O(n^2)<br>Remark: 这道题属于容易推断的DP问题，多举几个例子就能自己发现了。  </p></blockquote><p>Explanation：<br>通过枚举观察可以发现以下结果：  </p><p><pre><br>2: 1<br>3: 1x2 = 2<br>4: 2x2 = 4<br>5: 2x3 = 6<br>6: 3x3 = 9<br>7: 3x4 = 12<br>8: 2x(6) = 2x9 = 18<br>9: 3x(6) = 3x9 = 27<br>10: 2x(8) = 2x18 = 36<br></pre><br>所以它具有最优子结构以及重复子问题的性质。值得注意的是，2和3的结果并没有他们本身大，所以后续我们需要用到2或者3的时候，我们用的是它本身，而不是它break的结果。  </p><p>状态方程如下：<br><code>T[n]=max(T[n], T[i]*T[n-i]) i = 1,...,n/2</code>  </p><p>Code:  </p><pre><code class="py"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">integerBreak</span><span class="params">(self, n)</span>:</span>        <span class="string">"""</span><span class="string">        :type n: int</span><span class="string">        :rtype: int</span><span class="string">        """</span>        <span class="keyword">if</span> n &lt; <span class="number">4</span>:            <span class="keyword">return</span> n<span class="number">-1</span>        maxr = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]        <span class="keyword">for</span> cur <span class="keyword">in</span> range(<span class="number">4</span>, n+<span class="number">1</span>):            cm = <span class="number">0</span>            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, int(cur/<span class="number">2</span>) + <span class="number">1</span>):                cm = max(cm, maxr[i] * maxr[cur-i])            maxr.append(cm)        <span class="keyword">return</span> maxr[n]</code></pre><hr><h4 id="474-M"><a href="#474-M" class="headerlink" title="474-M"></a>474-M</h4><p><a href="https://leetcode.com/problems/ones-and-zeroes/description/" target="_blank" rel="noopener">474. Ones and Zeroes</a>  </p><blockquote><p>Difficulty：★★★☆☆<br>Beats: 15.76%<br>Time Complexity: O(n)<br>Remark: 就题目本身而言，属于经典的0/1背包问题，而且属于二维费用的背包问题。同时这题揭露了LeetCode中python3和python评判的差异，同样的代码，python3用时更久。  </p></blockquote><p>Explanation:<br>先Mark一下，状态方程很简单：<code>dp[i][j] = max(dp[i][j], dp[i-zeros][j-ones]+1)</code><br>留待背包问题做个总结。  </p><p>Code:  </p><pre><code class="py"><span class="comment"># 使用python，可AC；使用python3，TLE</span><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">findMaxForm</span><span class="params">(self, strs, m, n)</span>:</span>        <span class="string">"""</span><span class="string">        :type strs: List[str]</span><span class="string">        :type m: int</span><span class="string">        :type n: int</span><span class="string">        :rtype: int</span><span class="string">        """</span>        dp = [[<span class="number">0</span>] * (n+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(m+<span class="number">1</span>) ]        <span class="keyword">for</span> s <span class="keyword">in</span> strs:            s0 = s.count(<span class="string">'0'</span>)            s1 = len(s) - s0            <span class="keyword">for</span> i <span class="keyword">in</span> range(m, s0<span class="number">-1</span>, <span class="number">-1</span>):                <span class="keyword">for</span> j <span class="keyword">in</span> range(n, s1<span class="number">-1</span>, <span class="number">-1</span>):                    dp[i][j] = max(dp[i][j], dp[i-s0][j-s1]+<span class="number">1</span>)        <span class="keyword">return</span> dp[m][n]</code></pre><hr><h4 id="392-M"><a href="#392-M" class="headerlink" title="392-M"></a>392-M</h4><p><a href="https://leetcode.com/problems/is-subsequence/description/" target="_blank" rel="noopener">392. Is Subsequence</a></p><blockquote><p>Difficulty：★★★☆☆<br>Beats: 62.02%<br>Time Complexity: O(nm)<br>Remark: 中规中矩的DP，但是构建状态矩阵的时候MLE了两次，之后改用了递归。</p></blockquote><p>Explanation:  </p><ul><li><p><em>Step1: 判断</em><br>满足重叠子问题、最优子结构性质。</p></li><li><p><em>Step2: 状态</em><br>首先明确一点，如果一个串B是串A的子串，那么串B中字符出现的先后顺序在串A中也是一样的。想一想为什么？<br>在知道了上面一这点后，我们可以这样定义状态，若当前字符s[i]对应串A的A[j]，其状态为<code>true</code>。  </p></li><li><p><em>Step3: 状态方程</em><br>那么s[i+1]在哪里找呢？我们需要在A[j+1:]里找，重复上面的过程。如果有一次s[k]没有找到对应字符，直接返回<code>false</code>。</p></li><li><p><em>Step4: Tabulation or Memorizatio</em><br>这里我用的是自上而下的递归。  </p></li></ul><p>Code:  </p><pre><code class="py"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">isSubsequence</span><span class="params">(self, s, t)</span>:</span>        <span class="string">"""</span><span class="string">        :type s: str</span><span class="string">        :type t: str</span><span class="string">        :rtype: bool</span><span class="string">        """</span>        <span class="function"><span class="keyword">def</span> <span class="title">sub</span><span class="params">(s, t)</span>:</span>            <span class="keyword">if</span> <span class="keyword">not</span> s: <span class="keyword">return</span> <span class="keyword">True</span>            <span class="keyword">if</span> <span class="keyword">not</span> t: <span class="keyword">return</span> <span class="keyword">False</span>            target = s[<span class="number">0</span>]            idx = <span class="number">-1</span>            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(t)):                <span class="keyword">if</span> target == t[i]:                    idx = i                    <span class="keyword">break</span>            <span class="keyword">if</span> idx &lt; <span class="number">0</span>:                <span class="keyword">return</span> <span class="keyword">False</span>            <span class="keyword">return</span> sub(s[<span class="number">1</span>:], t[idx+<span class="number">1</span>:])        <span class="keyword">return</span> sub(s, t)    <span class="comment"># 利用Python自带函数  </span>    <span class="function"><span class="keyword">def</span> <span class="title">isSubsequence</span><span class="params">(self, s, t)</span>:</span>        ind = <span class="number">-1</span>        <span class="keyword">for</span> i <span class="keyword">in</span> s:            <span class="keyword">try</span>: ind = t.index(i,ind+<span class="number">1</span>)            <span class="keyword">except</span>: <span class="keyword">return</span> <span class="keyword">False</span>        <span class="keyword">return</span> <span class="keyword">True</span></code></pre><hr><h3 id="Day5"><a href="#Day5" class="headerlink" title="Day5"></a>Day5</h3><p><strong>Date: 18-09-17</strong>  </p><h4 id="357-M"><a href="#357-M" class="headerlink" title="357-M"></a>357-M</h4><p><a href="https://leetcode.com/problems/count-numbers-with-unique-digits/description/" target="_blank" rel="noopener">357. Count Numbers with Unique Digits</a>  </p><blockquote><p>Difficulty：★★☆☆☆<br>Beats: 69.17%<br>Time Complexity: O(n)<br>Remark: 简单题，可以总结为数学问题，这道题说明，状态不一定要直接解决我们的最终问题，它可以是最终答案的骨架。  </p></blockquote><p>一看就懂，直接放代码。<br>Code:  </p><pre><code class="py"><span class="comment">#     n = 1 : 10</span><span class="comment">#     n = 2 : 9 * 9      (1-9)|(0-9 except first Digit)</span><span class="comment">#     n = 3 : 9 * 9 * 8  (1-9)|(0-9 except first Digit) | (0-9 except first Digit))</span><span class="comment">#     ...   </span><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">countNumbersWithUniqueDigits</span><span class="params">(self, n)</span>:</span>        <span class="string">"""</span><span class="string">        :type n: int</span><span class="string">        :rtype: int</span><span class="string">        """</span>        <span class="keyword">if</span> n == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">1</span>        <span class="keyword">if</span> n == <span class="number">1</span>: <span class="keyword">return</span> <span class="number">10</span>        dp = [<span class="number">0</span>]*(n+<span class="number">1</span>)        dp[<span class="number">1</span>] = <span class="number">10</span>        dp[<span class="number">2</span>] = <span class="number">9</span>*<span class="number">9</span>        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>, n+<span class="number">1</span>):            dp[i] = dp[i<span class="number">-1</span>] * (<span class="number">10</span>-i+<span class="number">1</span>)        <span class="keyword">return</span> sum(dp)</code></pre><hr><h3 id="Day4"><a href="#Day4" class="headerlink" title="Day4"></a>Day4</h3><p><strong>Date: 18-09-16</strong>  </p><h4 id="714-M"><a href="#714-M" class="headerlink" title="714-M"></a>714-M</h4><p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/description/" target="_blank" rel="noopener">714. Best Time to Buy and Sell Stock with Transaction Fee</a>  </p><blockquote><p>Difficulty：★★★★☆<br>Beats: 44.97%<br>Time Complexity: O(n)<br>Remark: 比较难，什么状态，以及状态方程。我个人想不到需要两个状态方程来维护，所以看了很多题解。买卖这两个字很值得推敲。  </p></blockquote><p>Explanation:<br>有两个题解写的比较好，推荐一下。<br><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/discuss/136388" target="_blank" rel="noopener">精简的解释</a><br><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/discuss/75928/" target="_blank" rel="noopener">利用状态机，含图解，非本题</a><br><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/discuss/108870/" target="_blank" rel="noopener">针对买卖股票系列，总结十分全面</a>  </p><p>本题的关键就是要想清楚什么时候买、什么时候卖。这二者又取决于今天 买/卖 和明天 买/卖 有什么联系。  </p><p>买和卖之间的桥梁就是股票以及利润。  </p><p>以<code>1, 4, 2, 8, 4, 9</code>为例。<br>第0天，假设不买，则利润为<code>profit[0] = 0</code>；假设买了，持有<code>shares[0] = -1</code>。<br>第1天，根据第0天的两种状态：<br>今天卖还是不卖呢，可以卖手中持有的，如果卖，收益是 <code>tmp = shares[0] + nums[1] - fee</code>，这里结果是1，如果不卖，收益就是<code>profit[0]=0</code>，说明今天卖昨天买的可以有正收益，因此<code>profit[1] = max(tmp, profit[0])</code>；<br>那么今天适不适合买呢，如果买，就面临一个选择。因为要求不能持有多余一股，所以今天买了，昨天就不能买。因此，若今天买，需要付出<code>tmp = profits[0] - nums[1] = -4</code>，显然第0天买更划算，因此<code>shares[1] = max(tmp,  shares[0])</code>。<br>……<br>以此类推，可以理解为：  </p><blockquote><p><code>dp[i][0]</code>: arrive i, no shares at hand.<br><code>dp[i][1]</code>: arrive i, shares at hand.<br><code>dp[i][1] = max(dp[i-1][0] - nums[i], dp[i-1][1])</code>: buy at nums[i] or do nothing.<br><code>dp[i][0] = max(dp[i-1][1] + nums[i] - fee, dp[i-1][0])</code>: sell at nums[i] or do nothing.  </p></blockquote><p>Code:  </p><pre><code class="py"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices, fee)</span>:</span>        <span class="string">"""</span><span class="string">        :type prices: List[int]</span><span class="string">        :type fee: int</span><span class="string">        :rtype: int</span><span class="string">        """</span>        <span class="comment"># dp = [[0 for _ in range(2)] for _ in range(len(prices))]</span>        <span class="comment"># dp[0][0] = 0</span>        <span class="comment"># dp[0][1] = -prices[0]</span>        <span class="comment"># for i in range(1, len(prices)):</span>        <span class="comment">#     dp[i][1] = max([dp[i - 1][0] - prices[i], dp[i - 1][1]])</span>        <span class="comment">#     dp[i][0] = max([dp[i - 1][1] + prices[i] - fee, dp[i - 1][0]])</span>        <span class="comment"># print(dp)</span>        <span class="comment"># return dp[-1][0]</span>        profits = <span class="number">0</span>        shares = -prices[<span class="number">0</span>]        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(prices)):            tmp_shares = shares            shares = max(profits - prices[i], shares)            profits = max(tmp_shares + prices[i] - fee, profits)        <span class="keyword">return</span> profits</code></pre><hr><h4 id="647-M"><a href="#647-M" class="headerlink" title="647-M"></a>647-M</h4><p><a href="https://leetcode.com/problems/palindromic-substrings/description/" target="_blank" rel="noopener">647. Palindromic Substrings</a>  </p><blockquote><p>Difficulty：★★★☆☆<br>Beats: 29.16%<br>Time Complexity: O(n^2)<br>Remark: 关键还是要分析出相邻状态之间的关系。  </p></blockquote><p>Explanation:  </p><ul><li><p><em>Step1: 判断</em><br>满足重叠子问题、最优子结构性质。考虑如果某个串是回文串，那么它所临近的串应该如何判断呢？</p></li><li><p><em>Step2: 状态</em><br>直观一点，我们可以简单的认为状态是从<code>i</code>到<code>j</code>的子串是否是回文串，即<code>T[i][j]</code>是否是回文串。</p></li></ul><ul><li><em>Step3: 状态方程</em><br>假设现在<code>T[i][j]</code>是回文串，对于<code>s[j+1]</code>，基于回文串的性质，我们知道，如果在已有回文串的两边加上同样的字符，它依然是一个回文串，所以若<code>s[i-1]</code>和<code>s[j+1]</code>相等，就可以得出<code>T[i-1][j+1]</code>也是回文串。所以我们可以推导出状态方程：<br><code>if s[i]==s[j]: T[i][j] = T[i+1][j-1]</code>  </li></ul><ul><li><em>Step4: Tabulation or Memorizatio</em><br>本题我们的父问题需要多个子问题堆叠，比较简单的想法是自底向上，构建二维状态矩阵。  </li></ul><p>Code</p><pre><code class="py"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">countSubstrings</span><span class="params">(self, s)</span>:</span>        <span class="string">"""</span><span class="string">        :type s: str</span><span class="string">        :rtype: int</span><span class="string">        """</span>        <span class="keyword">if</span> <span class="keyword">not</span> s:            <span class="keyword">return</span> <span class="number">0</span>        n = len(s)        T = [[<span class="keyword">None</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]        res = <span class="number">0</span>        <span class="keyword">for</span> l <span class="keyword">in</span> range(n):            <span class="keyword">for</span> i <span class="keyword">in</span> range(n):                j = i+l                <span class="keyword">if</span> j &lt; n:                    <span class="keyword">if</span> i == j:                        T[i][j] = <span class="number">1</span>                        res += <span class="number">1</span>                        <span class="keyword">continue</span>                    <span class="keyword">if</span> s[i] == s[j]:                        <span class="keyword">if</span> j<span class="number">-1</span> &lt;= i+<span class="number">1</span> <span class="keyword">or</span> T[i+<span class="number">1</span>][j<span class="number">-1</span>] == <span class="number">1</span>:                             T[i][j] = <span class="number">1</span>                            res += <span class="number">1</span>        <span class="keyword">return</span> res</code></pre><hr><h4 id="877-M"><a href="#877-M" class="headerlink" title="877-M"></a>877-M</h4><p><a href="https://leetcode.com/problems/stone-game/discuss/" target="_blank" rel="noopener">877. Stone Game</a>  </p><blockquote><p>Difficulty：★★★☆☆<br>Beats: %<br>Time Complexity: O(n)<br>Remark: 可以说没有意义。  </p></blockquote><p>Alex永远不会输。</p><hr><h3 id="Day3"><a href="#Day3" class="headerlink" title="Day3"></a>Day3</h3><p><strong>Date: 180915</strong>  </p><h4 id="413-M"><a href="#413-M" class="headerlink" title="413-M"></a>413-M</h4><p><a href="https://leetcode.com/problems/arithmetic-slices/description/" target="_blank" rel="noopener">413. Arithmetic Slices</a>  </p><blockquote><p>Difficulty：★★★☆☆<br>Beats: 97.54%<br>Time Complexity: O(n)<br>Remark: 有几个点需要注意一下，按照DP的解题思路，想通了注意点就ok了。  </p></blockquote><p>Explanation:  </p><ul><li><p><em>Step1: 判断</em><br>满足重叠子问题、最优子结构性质。即如果某个位置与之前连续的若干个元素满足题意，那么其下一个位置是否满足呢？  </p></li><li><p><em>Step2: 状态</em><br>假设<code>A[i]</code>与之前若干个连续元素满足arithmetic slices的性质 (i&gt;=2)，我们将之前的满足条件的连续元素存到数组中。<br>那么元素<code>A[i+1]</code>是否满足，只需要比较它和它之前的两个元素即可。<br>如果<code>A[i+1]</code>满足，会多出多少个满足条件的arithmetic slices呢？<br>如果<code>A[i+1]</code>不满足，又要怎么算呢？</p></li></ul><ul><li><p><em>Step3: 状态方程</em><br>接上面的状态分析。<br>举个简单的例子，<code>1,3,5,7</code>是满足性质的一个slice，判断元素<code>9</code>，<code>9-7==7-5</code>，<br>那么对于<code>1,3,5,7,9</code>而言，因为它整体是满足条件的，所有以<code>9</code>结尾的所有至少3个连续元素都可以满足题目条件，<br>即<code>3,5,7,9</code>，<code>5,7,9</code>均满足，整理一下：<br><pre><br>1,3,5,7,9<br>3,5,7,9<br>5,7,9<br></pre><br>所以当多出一个元素<code>9</code>满足条件的时候，就有多出<code>5-3+1</code>个元素。 </p><p>注意点，如果<code>A[i+1]</code>不满足，我们也不能从<code>A[i+1]</code>重新开始算，而是需要从<code>A[i]</code>开始重新算。  </p></li><li><p><em>Step4: Tabulation or Memorizatio</em>   </p></li></ul><p>Code:</p><pre><code class="py"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">numberOfArithmeticSlices</span><span class="params">(self, A)</span>:</span>        <span class="string">"""</span><span class="string">        :type A: List[int]</span><span class="string">        :rtype: int</span><span class="string">        """</span>        cur = []        res = <span class="number">0</span>        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(A)):            <span class="keyword">if</span> len(cur) &lt; <span class="number">2</span>:                cur.append(A[i])            <span class="keyword">else</span>:                <span class="keyword">if</span> A[i] - cur[<span class="number">-1</span>] == cur[<span class="number">-1</span>] - cur[<span class="number">-2</span>]:                    cur.append(A[i])                    res += len(cur) - <span class="number">3</span> + <span class="number">1</span>                <span class="keyword">else</span>:                    tmp = cur[<span class="number">-1</span>]                    cur = [tmp, A[i]]        <span class="keyword">return</span> res</code></pre><hr><h3 id="Day2"><a href="#Day2" class="headerlink" title="Day2"></a>Day2</h3><p><strong>Date: 18-09-14</strong>  </p><h4 id="338-M"><a href="#338-M" class="headerlink" title="338-M"></a>338-M</h4><p><a href="https://leetcode.com/problems/counting-bits/description/" target="_blank" rel="noopener">338. Counting Bits</a>  </p><blockquote><p>Difficulty：★★★☆☆<br>Beats: 63.94%<br>Time Complexity: O(n)<br>Remark: 考察二进制的时候，多向左移右移的方向考虑。  </p></blockquote><p>Explanation:  </p><ul><li><p><em>Step1: 判断</em><br>朝<code>O(n)</code>的时间复杂度方向考虑，肯定需要用到子问题的解，不然不太可能。  </p></li><li><p><em>Step2: 状态</em><br>状态自然是数<code>i</code>的二进制中包含1的个数<code>count[i]</code>。<br>难度是如何找寻它与子问题的关系。  </p></li><li><p><em>Step3: 状态方程</em><br><pre><br>0: 0000 0000   0<br>1: 0000 0001   1<br>2: 0000 0010   1<br>3: 0000 0011   2<br>4: 0000 0100   1<br>5: 0000 0101   2<br>6: 0000 0110   2<br>7: 0000 0111   3<br>8: 0000 1000   1<br></pre><br>观察<code>0-8</code>的二进制，会比较自然的朝左移右移的角度去想。一个数的二进制左移一位相当于翻倍，反之减小一般。奇数比较特别的地方在于左移的时候末尾补<code>0</code>，右移的时候原来末尾的<code>1</code>会丢失。基于这个想法，对于数<code>i</code>，在不考虑原本末位的情况下，我们不难想到右移后<code>i</code>与<code>i&gt;&gt;1</code>的二进制中含有相同个数的<code>1</code>。再加上末位可能有的<code>1</code>，就可以得到<code>i</code>中含有<code>1</code>的个数了。<br>得到状态方程：<code>count[i] = count[i&gt;&gt;1] + (i &amp; 1)</code></p></li><li><p><em>Step4: Tabulation or Memorizatio</em><br>两种方法都可以。  </p></li></ul><p>Code:</p><pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">countBits</span><span class="params">(self, num)</span>:</span>        <span class="string">"""</span><span class="string">        :type num: int</span><span class="string">        :rtype: List[int]</span><span class="string">        """</span>        array = [<span class="number">0</span>]*(num+<span class="number">1</span>)        <span class="keyword">for</span> i <span class="keyword">in</span> range(num+<span class="number">1</span>):            array[i] = array[i&gt;&gt;<span class="number">1</span>] + (i &amp; <span class="number">1</span>)         <span class="keyword">return</span> array</code></pre><hr><h4 id="053-E"><a href="#053-E" class="headerlink" title="053-E"></a>053-E</h4><p><a href="https://leetcode.com/problems/maximum-subarray/description/" target="_blank" rel="noopener">053 Maximum Subarray</a>  </p><blockquote><p>Difficulty：★★☆☆☆<br>Beats: 99.53%<br>Time Complexity: O(n)<br>Remark: <code>O(n^2)</code>是不行的，从解DP问题的一般思路入手，一步一步来。同样的Beats存在问题，以后除了低于30%的就不写了，另外两个数比较大小，python的<code>max</code>函数比直接比较要慢。  </p></blockquote><p>Explanation:  </p><ul><li><p><em>Step1: 判断</em><br>最大子串问题，属于DP问题。  </p></li><li><p><em>Step2: 状态</em><br>我们希望得到的<code>Maximum Subarray</code>，这个子串的最后一个元素可能在原数组中的任意位置，因此自然联想到用<strong>以<code>i</code>结尾的子串的最大和<code>res[i]</code></strong> 作为状态，当然，这个子串可能不是以<code>0</code>作为首元素。  </p></li><li><p><em>Step3: 状态方程</em><br>探索<code>res</code>的前后序列关系，如果<code>res[i-1]</code>是前<code>i-1</code>个元素的最大和，那么在第<code>i</code>个元素的位置，我们需要计算以它结尾的最大和，如果<code>res[i-1] &lt; 0</code>，那就没有累加的必要，反之，累加。即状态方程为：<br><code>res[i] = max(0, res[i-1]) + nums[i]</code><br>更新最大值。</p></li><li><p><em>Step4: Tabulation or Memorizatio</em><br>两种方法都可以，为了节约空间，我们只使用常数数量的空间。</p></li></ul><p>Code:</p><pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums)</span>:</span>        <span class="string">"""</span><span class="string">        :type nums: List[int]</span><span class="string">        :rtype: int</span><span class="string">        """</span>        res = cur = nums[<span class="number">0</span>]        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(nums)):            <span class="keyword">if</span> cur &lt;= <span class="number">0</span>:                cur = nums[i]            <span class="keyword">else</span>:                cur += nums[i]            <span class="keyword">if</span> cur &gt; res:                res = cur        <span class="keyword">return</span> res</code></pre><hr><h4 id="303-E"><a href="#303-E" class="headerlink" title="303-E"></a>303-E</h4><p><a href="https://leetcode.com/problems/range-sum-query-immutable/description/" target="_blank" rel="noopener">303. Range Sum Query - Immutable</a>  </p><blockquote><p>Difficulty：★☆☆☆☆<br>Beats: 87.5%<br>Time Complexity: O(n)<br>Remark: 简单题，基于一个简单的发现。同样的Beats存在问题。  </p></blockquote><p>Explanation:  </p><ol><li><p><em>Step1: 判断</em><br>求从位置i到位置j的值的和，i和j任意，具有重叠子问题、最优子结构两个性质。  </p></li><li><p><em>Step2: 状态</em><br>如果暴力把所有的i,j都算一遍，那么无论时间还是空间复杂度都会很高。<br>换个思路，我们算一下从0到1，两个数的和<code>sum[1]</code>是<code>nums[0]+nums[1]</code>，<br>从0到2的和<code>sum[2]</code>是<code>nums[0] + nums[1] + nums[2]</code>，<br>从0到3的和<code>sum[3]</code>是<code>nums[0] + nums[1] + nums[2] + nums[3]</code>。<br>我们发现从0开始，加到<code>i-1</code>的和是<code>sum[i-1]</code>，到<code>i</code>的时候，只需要在<code>sum[i-1]</code>的基础上加上<code>nums[i]</code>，<br>在<code>sum[i-2]</code>的基础上加上<code>nums[i-1] + nums[i]</code>……  </p></li><li><p><em>Step3: 状态方程</em><br>那么我们的状态就可以设置为从0到i的和是<code>sum[i]</code>。<br>从<code>i</code>到<code>j</code>的话，<code>sum[j]</code>就等于<code>sum[i] + nums[i+1] + ... + nums[j]</code>。<br>从而得到<code>res[i,j] = sum[j] - sum[i]</code>。</p></li><li><p><em>Step4: Tabulation or Memorizatio</em><br>根据题目的设置，可以选用<code>list</code>或者<code>dict</code>。</p></li></ol><p>Code:</p><pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, nums)</span>:</span>        <span class="string">"""</span><span class="string">        :type nums: List[int]</span><span class="string">        """</span>        self.val = {<span class="number">-1</span>:<span class="number">0</span>}        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):            self.val[i] = self.val[i<span class="number">-1</span>] + nums[i]    <span class="function"><span class="keyword">def</span> <span class="title">sumRange</span><span class="params">(self, i, j)</span>:</span>        <span class="string">"""</span><span class="string">        :type i: int</span><span class="string">        :type j: int</span><span class="string">        :rtype: int</span><span class="string">        """</span>        <span class="keyword">return</span> self.val[j] - self.val[i<span class="number">-1</span>]</code></pre><hr>  <h4 id="198-E"><a href="#198-E" class="headerlink" title="198-E"></a>198-E</h4><p><a href="https://leetcode.com/problems/house-robber/description/" target="_blank" rel="noopener">198. House Robber</a>  </p><blockquote><p>Difficulty：★☆☆☆☆<br>Beats: 50% ? 100%<br>Time Complexity: O(n)<br>Remark: 同样是Python，时间复杂度相同，常数空间复杂度的解居然也只有50%，对比了其他人的解法，感觉leetcode的评判有点问题。  </p></blockquote><p>Explanation:  </p><ol><li><p><em>Step1: 判断</em><br>最大化数值，是DP问题  </p></li><li><p><em>Step2: 状态</em><br>在第i家可以获得的最大利润P[i]，不一定要取nums[i]</p></li><li><p><em>Step3: 状态方程</em><br>P[i] 和同序列之前的数有什么关系呢？<br>我们知道为了在第i家的时候，有两种选择：  </p><ul><li>一是偷取第i家，此时最大利润是<code>P[i-2] + nums[i]</code>  </li><li>二是不取第i家，此时最大利润就是<code>P[i-1]</code>  </li></ul><p>为了使得在第i家时的利润最大，我们取二者较大的。因此可以求得状态方程：<br><code>P[i] = max(P[i-1], P[i-2] + nums[i])</code>。</p></li><li><p><em>Step4: Tabulation or Memorizatio</em><br>这里结合<code>746-E</code>里的做法，可以节约空间，只使用常数空间复杂度。 </p></li></ol><p>Code:  </p><pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>        <span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, nums)</span>:</span>        <span class="string">"""</span><span class="string">        :type nums: List[int]</span><span class="string">        :rtype: int</span><span class="string">        """</span>        length = len(nums)        <span class="keyword">if</span> <span class="keyword">not</span> nums:             <span class="keyword">return</span> <span class="number">0</span>        <span class="keyword">if</span> length == <span class="number">1</span>:            <span class="keyword">return</span> nums[<span class="number">0</span>]        pre, cur = nums[<span class="number">0</span>], max(nums[<span class="number">0</span>], nums[<span class="number">1</span>])        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, length):            pre, cur = cur, max(cur, pre + nums[i])        <span class="keyword">return</span> cur</code></pre><hr><h3 id="Day1"><a href="#Day1" class="headerlink" title="Day1"></a>Day1</h3><p><strong>Date: 18-09-13</strong>  </p><h4 id="746-E"><a href="#746-E" class="headerlink" title="746-E"></a>746-E</h4><p><a href="https://leetcode.com/problems/min-cost-climbing-stairs/description/" target="_blank" rel="noopener">746. Min Cost Climbing Stairs</a>  </p><blockquote><p>Difficulty：★☆☆☆☆<br>Beats: 52% / 100%<br>Time Complexity: O(n)<br>Remark: 简单题，斐波那契的拓展，但是同样是BottomUp，用了O(n)的空间，和O(1)的空间是不同的！  </p></blockquote><p>Explanation:<br>参考070题，再加上cost的条件，注意要踏到最顶端，容易得出状态是<strong>迈上</strong>第i层的最小代价T[i]。<br>要踏上第<code>i</code>层，可能是从<code>i-1</code>或者<code>i-2</code>层上来的，要使得代价最小，那么二者取较小者。<br>因此有状态方程：<code>T[i] = min(T[i-1], T[i-2]) + cost[i]</code>。<br>时间复杂度都是<code>O(n)</code>，不难写出代码。下面分享的是两种用不同空间复杂度的代码。  </p><p><strong>空间复杂度 O(n)</strong> - 这是比较常规的做法  </p><pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">minCostClimbingStairs</span><span class="params">(self, cost)</span>:</span>        <span class="string">"""</span><span class="string">        :type cost: List[int]</span><span class="string">        :rtype: int</span><span class="string">        """</span>        <span class="keyword">if</span> <span class="keyword">not</span> cost:            <span class="keyword">return</span> <span class="number">0</span>        n = len(cost) + <span class="number">2</span>        T = [<span class="number">0</span>]*n        T[<span class="number">0</span>] = <span class="number">0</span>        T[<span class="number">1</span>] = <span class="number">0</span>        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n):            T[i] = min(T[i<span class="number">-1</span>], T[i<span class="number">-2</span>]) + cost[i<span class="number">-2</span>]        print(T)        <span class="keyword">return</span> min(T[n<span class="number">-1</span>], T[n<span class="number">-2</span>])</code></pre><p><strong>空间复杂度 O(1)</strong>   </p><pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">minCostClimbingStairs</span><span class="params">(self, cost)</span>:</span>        <span class="string">"""</span><span class="string">        :type cost: List[int]</span><span class="string">        :rtype: int</span><span class="string">        """</span>        <span class="keyword">if</span> <span class="keyword">not</span> cost:            <span class="keyword">return</span> <span class="number">0</span>        pre, cur = cost[<span class="number">0</span>], cost[<span class="number">1</span>]        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, len(cost)):            pre, cur = cur, min(pre, cur) + cost[i]        <span class="keyword">return</span> min(pre,cur)</code></pre><p>注意这里的<code>pre, cur = cur, min(pre, cur) + cost[i]</code>，其作用等价于：  </p><pre><code class="python">tmp = curcur = min(pre, cur) + cost[i]pre = tmp</code></pre><hr><h4 id="121-E"><a href="#121-E" class="headerlink" title="121-E"></a>121-E</h4><p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/" target="_blank" rel="noopener">121. Best Time to Buy and Sell Stock</a>  </p><blockquote><p>难易程度：★★☆☆☆<br>Beats: 73.94%<br>时间复杂度：O(n)<br>Remark: 简单题，有助于DP基本概念的理解。</p></blockquote><p>Explanation:<br>暴力：<br>每一天都和前面所有天的股价计算差值，保留最大值，那么时间复杂度就是 n的平方。不出意外就是TLE了。</p><p>问题在于如何确定哪天是股价最小的，再确定差价最高的。</p><p><strong>DP Steps</strong>  </p><ul><li><p><em>Step1: 判断</em><br>最大化利润，是DP问题  </p></li><li><p><em>Step2: 状态</em><br>第i天可以获得的最大利润P[i]（不一定是第[i]天卖出）</p></li><li><p><em>Step3: 状态方程</em><br>P[i] 和 P[i-1]有什么关系呢？<br>如果s[i] 比s[i-1]小，那么P[i] = P[i-1]，同时这两天最小价格至少会是s[i]，更新minPrice；<br>如果s[i] 比s[i-1]大，那么第s[i] - minPrice 是要比s[i-1] - minPrice大的，因此更新当前差价，和最大差价比较，如果比最大差价大，那么P[i] = nowMax</p></li><li><p><em>Step4: Tabulation or Memorizatio</em><br>Code:  </p><pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>  <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices)</span>:</span>      <span class="string">"""</span><span class="string">      :type prices: List[int]</span><span class="string">      :rtype: int</span><span class="string">      """</span>      <span class="keyword">if</span> <span class="keyword">not</span> prices:          <span class="keyword">return</span> <span class="number">0</span>      n = len(prices)      T = [<span class="number">0</span>]      minPrice = prices[<span class="number">0</span>]      maxPrice = T[<span class="number">0</span>]      <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):          <span class="keyword">if</span> prices[i] &lt; prices[i<span class="number">-1</span>]:              T.append(T[i<span class="number">-1</span>])              minPrice = prices[i] <span class="keyword">if</span> prices[i] &lt; minPrice <span class="keyword">else</span> minPrice          <span class="keyword">else</span>:              cur = prices[i] - minPrice              maxPrice = cur <span class="keyword">if</span> cur &gt; maxPrice <span class="keyword">else</span> maxPrice              T.append(maxPrice)      <span class="keyword">return</span> T[n<span class="number">-1</span>]</code></pre></li></ul><!-- <hr style="border:none; border-top:1px dashed ; height:1px"/> --><hr><h4 id="070-E"><a href="#070-E" class="headerlink" title="070-E"></a>070-E</h4><p><a href="https://leetcode.com/problems/climbing-stairs/description/" target="_blank" rel="noopener">070. Climbing Stairs</a>  </p><blockquote><p>难易程度：★☆☆☆☆<br>TopDown Beats: 100%<br>BottomUp Beats: 45.20%<br>时间复杂度：O(n)<br>Remark: 简单题，理解TopDown和BottomUp概念，<a href="https://www.geeksforgeeks.org/tabulation-vs-memoizatation/" target="_blank" rel="noopener">区别</a>。  </p></blockquote><p>DP问题中有一些典型的情况。<br>本题属于其中一种，即斐波那契数列。<br>那么不难想到状态方程<code>T[n] = T[n-1] + T[n-2]</code>。  </p><p>假设我们没看出这是一个斐波那契问题，我们来推理看看。</p><p>(层数)：方式。解释<br> (1)： 1。只有一种方式<br> (2)： 2。两种方式，11，2。<br> (3)： 3。111，12，21。<br> (4)： 5。1111，112， 121，211，22。  </p><p>思考一下4层的情况，如果先迈出了一步，那么总的情况就是1(3)，括号里是剩下的总层数，3层的情况我们已经算过了，把3层的情况填到括号中，1(111)，1(12)，1(21)；同理如果先迈出两步，总的情况就是2(2)，(2)又有2种。那么(4)可以写成<code>(4) = 1(3) + 2(2)</code>。下面验证一下(5)。<br>(5) =&gt; 1(4)，2(3) =&gt; 1(1111，112， 121，211，22)，2(111，12，21)。  </p><p>这个时候我们就可以得出相同的结论了。</p><p>这道题的价值在于练习<code>TopDown</code> 和 <code>BottomUp</code> 两种方式。    </p><p><strong>Top Down</strong>  </p><pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(self, n)</span>:</span>        <span class="string">"""</span><span class="string">        :type n: int</span><span class="string">        :rtype: int</span><span class="string">        """</span>        f = [<span class="number">0</span>] * (n+<span class="number">1</span>)        f[<span class="number">0</span>] = f[<span class="number">1</span>] = <span class="number">1</span>        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n+<span class="number">1</span>):            f[i] = f[i<span class="number">-1</span>] + f[i<span class="number">-2</span>]        print(f)        <span class="keyword">return</span> f[n]</code></pre><p><strong>Bottom Up</strong></p><pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(self, n)</span>:</span>        <span class="string">"""</span><span class="string">        :type n: int</span><span class="string">        :rtype: int</span><span class="string">        """</span>        lookup = [<span class="keyword">None</span>]*(n+<span class="number">1</span>)        <span class="comment"># Memoization -&gt; Bottom Up</span>        <span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(n)</span>:</span>            <span class="keyword">if</span> n == <span class="number">0</span> <span class="keyword">or</span> n == <span class="number">1</span>:                lookup[n] = <span class="number">1</span>            <span class="keyword">if</span> lookup[n] <span class="keyword">is</span> <span class="keyword">None</span>:                lookup[n] = fib(n<span class="number">-1</span>) + fib(n<span class="number">-2</span>)            <span class="keyword">return</span> lookup[n]        res = fib(n)        <span class="comment"># print(lookup)</span>        <span class="keyword">return</span> res</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;center&gt; LeetCode Challenge 🏆 &lt;/center&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;挑战目标🎖: 100道DP题&lt;br&gt; &lt;span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;时间&lt;span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;🗓: &lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;del&gt;25/70 （2018-09-13 👉🏻 2018-11-15）&lt;/del&gt;&lt;br&gt; &lt;span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;进度&lt;span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;🛴: &lt;span&gt;&amp;nbsp;&lt;/span&gt;39/100&lt;br&gt; 成功奖励🍭: ██████████  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Solved: 🥈🥈🥈🥉🥉🥉🥉🥉🥉🥉🥉🥉&lt;br&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://blog.x-fei.me/categories/Algorithm/"/>
    
    
      <category term="leetcode" scheme="http://blog.x-fei.me/tags/leetcode/"/>
    
      <category term="algorithm" scheme="http://blog.x-fei.me/tags/algorithm/"/>
    
      <category term="python" scheme="http://blog.x-fei.me/tags/python/"/>
    
      <category term="dynamic programming" scheme="http://blog.x-fei.me/tags/dynamic-programming/"/>
    
  </entry>
  
  <entry>
    <title>Paper Notes[1]: Rethinking ImageNet Pre-training</title>
    <link href="http://blog.x-fei.me/2018/12/11/RethinkingImageNetPretraining/"/>
    <id>http://blog.x-fei.me/2018/12/11/RethinkingImageNetPretraining/</id>
    <published>2018-12-11T03:23:25.000Z</published>
    <updated>2018-12-19T03:25:32.731Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Take-Home-Message"><a href="#Take-Home-Message" class="headerlink" title="Take Home Message"></a>Take Home Message</h3><blockquote><ol><li>不大幅度修改模型结构也可以在目标任务上随机初始化参数进行训练。  </li><li>随机初始化参数训练需要更多的迭代次数来充分收敛。  </li><li>随机初始化参数训练可以达到和预训练相匹配的模型性能，即使是只有10k的COCO数据作训练集。  </li><li>ImageNet的预训练加快了模型在新任务上的收敛速度。  </li><li>排除数据集非常小的情况，ImageNet的预训练并不一定有助于减少过拟合现象的发生。  </li><li>相较于分类，如果目标任务对定位更加敏感，那么ImageNet预训练对模型的帮助将变得更小。   </li></ol></blockquote><a id="more"></a><h3 id="Personal-opinion"><a href="#Personal-opinion" class="headerlink" title="Personal opinion"></a>Personal opinion</h3><p>就这样的‘发现’而言，更多的是用实打实的验证过去几年里大家对于<code>pre-train</code>的一些直觉感受。</p><p>文末的<strong>Rethink</strong>：<br>第一点是对未来的展望，如果有更多的目标数据和计算资源，不要忘记了针对目标任务训练，ImageNet预训练并不是必须的。言外之意，就是第二点，当下缺少这两个条件，ImageNet预训练是有用的，可以帮助更快收敛，训练成本低。<br>第三点，与第一点还是呼应的，需要大数据，为未来的到来做积累量。<br>第四点比较有意思，追求通用的模型性能。所有的模型都是想要学到数据的通用特征表征。所以我们更需要注意评估预训练的特征，预训练学习到的特征是不是和目标任务相契合，如果不契合，用随机初始化可能得到比预训练更出色的表现。   </p><p>当下还是先跟紧‘潮流’，先造好自己的小船。<br>所以AI+医学图像，目前Pretrain标配的现状什么时候能结束？  ：）</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Take-Home-Message&quot;&gt;&lt;a href=&quot;#Take-Home-Message&quot; class=&quot;headerlink&quot; title=&quot;Take Home Message&quot;&gt;&lt;/a&gt;Take Home Message&lt;/h3&gt;&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;不大幅度修改模型结构也可以在目标任务上随机初始化参数进行训练。  &lt;/li&gt;
&lt;li&gt;随机初始化参数训练需要更多的迭代次数来充分收敛。  &lt;/li&gt;
&lt;li&gt;随机初始化参数训练可以达到和预训练相匹配的模型性能，即使是只有10k的COCO数据作训练集。  &lt;/li&gt;
&lt;li&gt;ImageNet的预训练加快了模型在新任务上的收敛速度。  &lt;/li&gt;
&lt;li&gt;排除数据集非常小的情况，ImageNet的预训练并不一定有助于减少过拟合现象的发生。  &lt;/li&gt;
&lt;li&gt;相较于分类，如果目标任务对定位更加敏感，那么ImageNet预训练对模型的帮助将变得更小。   &lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Paper" scheme="http://blog.x-fei.me/categories/Paper/"/>
    
    
      <category term="Paper" scheme="http://blog.x-fei.me/tags/Paper/"/>
    
  </entry>
  
  <entry>
    <title>8-puzzles algorithm</title>
    <link href="http://blog.x-fei.me/2018/10/20/8-puzzles-algorithm/"/>
    <id>http://blog.x-fei.me/2018/10/20/8-puzzles-algorithm/</id>
    <published>2018-10-20T01:19:29.000Z</published>
    <updated>2018-10-20T02:06:10.049Z</updated>
    
    <content type="html"><![CDATA[<center>AIMA: 8-puzzles</center>  <p><strong>topics</strong>: <code>DFS</code>, <code>IDS</code>, <code>A*</code>, <code>Greedy</code>, <code>Informed Search</code> <sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a> </sup>  </p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><pre>8-puzzle problemGiven any randomly generated start state and a goal state shown below, implement the IDS, greedy search and A* search algorithms, respectively, to find a sequence of actions that will transform the state from the start state to the goal state.</pre>  <a id="more"></a><h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><pre>1) When implementing the A* search algorithm, you need to use at least two differentheuristic functions2) Compare the running time of these different searching algorithms, and do someanalyses on your obtained results. Note that the reported running time should beaveraged on many randomly generate different start states.</pre>  <h2 id="问题解析"><a href="#问题解析" class="headerlink" title="问题解析"></a>问题解析</h2><h3 id="是否有解"><a href="#是否有解" class="headerlink" title="是否有解"></a>是否有解</h3><p>首先对于八数码问题，存在有解和无解的情况，为了使得我们后续的程序能正常测试，我们需要对给定的随机初始状态进行检测，从而得到一定有解的随机初始状态。<br>根据维基百科，如果给定初始状态的逆序和为偶数，那么问题有解，否则无解。  </p><p>生成有解的随机初始状态有两种做法。一是生成随机的状态，检测是否有解，无解则继续生成，直到生成有解的状态并返回。二是逆序推导，从目标状态出发，随机选择方向走若干步得到随机状态。  </p><p>这里我们为了方便，将空白格用数字0表示。</p><p>两种做法的代码如下：  </p><pre><code class="py"><span class="comment"># Solution 1: genRandomState-&gt;check-&gt;genRandomState....</span><span class="function"><span class="keyword">def</span> <span class="title">genRandomState</span><span class="params">()</span>:</span>    puzzle = [x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">9</span>)]    random.shuffle(puzzle)    puzzle = np.asarray(puzzle).reshape((<span class="number">3</span>,<span class="number">3</span>))    <span class="keyword">return</span> puzzle<span class="comment"># getInvCount</span><span class="function"><span class="keyword">def</span> <span class="title">getInvCount</span><span class="params">(state)</span>:</span>    state = state.flatten()    int_count = <span class="number">0</span>    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>):        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, <span class="number">9</span>):            <span class="keyword">if</span> state[j] <span class="keyword">and</span> state[i] <span class="keyword">and</span> state[i] &gt; state[j]:                int_count += <span class="number">1</span>    <span class="keyword">return</span> int_count<span class="comment"># judge</span><span class="function"><span class="keyword">def</span> <span class="title">isSolvable</span><span class="params">(state)</span>:</span>    invCount = getInvCount(state)    <span class="keyword">return</span> invCount % <span class="number">2</span> == <span class="number">0</span>:<span class="function"><span class="keyword">def</span> <span class="title">genSolvableRandomState</span><span class="params">()</span>:</span>    puzzle = genRandomState()    <span class="keyword">if</span> isSolvable(puzzle):        <span class="keyword">return</span> puzzle    <span class="keyword">else</span>:        <span class="keyword">return</span> genSolvableRandomState()<span class="comment"># Solution 2: targetState-&gt;randomWalk-&gt;randomState  </span><span class="function"><span class="keyword">def</span> <span class="title">shuffle</span><span class="params">(self, numAct)</span>:</span>    <span class="keyword">for</span> i <span class="keyword">in</span> range(numAct):        self.move(self.directions[random.randint(<span class="number">0</span>, <span class="number">3</span>)])<span class="function"><span class="keyword">def</span> <span class="title">move</span><span class="params">(self, direction)</span>:</span>    <span class="keyword">if</span> direction == <span class="string">'U'</span>:        self.up()    <span class="keyword">if</span> direction == <span class="string">'D'</span>:        self.down()    <span class="keyword">if</span> direction == <span class="string">'L'</span>:        self.left()    <span class="keyword">if</span> direction == <span class="string">'R'</span>:        self.right()</code></pre><p><strong>思考</strong>：<br>第二种做法里，我们需要对状态做一些变化，从当前状态到下一个状态，需要判断可以走的方向，并更新0点的位置，都是一些可以重复并高度聚合的方法，因此可以将这些操作都封装到<code>Puzzle</code>类中。  </p><h3 id="IDS"><a href="#IDS" class="headerlink" title="IDS"></a>IDS</h3><p>IDS算法的伪代码如下：  </p><div align="center"><br><img src="/images/IDS.png" width="60%" alt="IDS"><br></div>   <p>IDS(<code>Iterative deepening search</code>)的核心在于，使用迭代深度限制深度搜索，使得每次只搜索到指定的深度。因此也需要对<code>DFS</code>有较深的理解。<br>这样做虽然会使得高层的节点被反复访问多次，但是可以推导出，最底层的节点数是最多的，将问题简化为二叉树，那么最底层有总体一半的节点，同时我们需要前序节点的信息去访问后续节点，因此在深度较深的时候，前面反复访问的时间可以不用去管。<br><code>Depth-Limited-Search</code>基于<code>DFS</code>，<code>DFS</code>的伪代码如下：  </p><div align="center"><br><img src="/images/DFS.png" width="60%" alt="DFS"><br></div>  <p><strong>思考</strong>：<br>这里我们需要维护的信息是深度信息，而且由于当前状态可能的子节点最多有四个，所以子节点的信息最好和父节点绑定，所以在设计<code>Puzzle</code>类的时候，我们可以绑定父节点<code>parent</code>，计算与判断当前节点的深度也相对方便。<br>在IDS中，我们更多的需要对<code>节点</code>进行操作，而不是直接对<code>Puzzle</code>操作，所以可以尝试构建<code>Node</code>类，简化代码逻辑。</p><p>IDS实现代码如下：  </p><pre><code class="py"><span class="function"><span class="keyword">def</span> <span class="title">IDS</span><span class="params">(self)</span>:</span>    depth = <span class="number">0</span>    result = <span class="keyword">None</span>    <span class="keyword">while</span> result == <span class="keyword">None</span>:        result = self.depthLimited(depth)        depth += <span class="number">1</span>    <span class="keyword">return</span> result<span class="function"><span class="keyword">def</span> <span class="title">depthLimited</span><span class="params">(self, depth)</span>:</span>    stack = LifoQueue()    stack.put(self.start)    <span class="keyword">while</span> <span class="keyword">True</span>:        <span class="keyword">if</span> stack.empty():            <span class="keyword">return</span> <span class="keyword">None</span>        top = stack.get()        <span class="keyword">if</span> top.isGoal():            <span class="keyword">return</span> top        <span class="keyword">elif</span> top.depth <span class="keyword">is</span> <span class="keyword">not</span> depth:            <span class="keyword">for</span> neighbor <span class="keyword">in</span> top.neighbors():                stack.put(neighbor)</code></pre><h3 id="Uninformed-v-s-Informed-search"><a href="#Uninformed-v-s-Informed-search" class="headerlink" title="Uninformed v.s. Informed search"></a>Uninformed v.s. Informed search</h3><p><code>Uninformed Search</code>，不知情搜索，无先验知识的搜索，通俗一点理解就是摸着石头过河，把所有可能的路都走一遍。个人理解，不同之处就在于走的顺序是全随机，还是半随机，对于DFS和BFS，可以归类为全随机，而IDS可以算半随机。<br><code>Uninformed Search</code>，先验搜索，启发式搜索，像是有了一把自己定义的尺子，可以衡量某一状态到目标状态的距离，通过这个先验知识去确定下一个最接近目标状态的中间状态。  </p><h3 id="Greedy"><a href="#Greedy" class="headerlink" title="Greedy"></a>Greedy</h3><p>对中间状态的选择取决于其到目标状态的“距离”，这个距离可以有不同的衡量标准。贪心算法基于“距离”，通过维护一个优先队列，每次选择距离目标状态最近的中间状态去扩展。为了避免陷入死循环，维护<code>visited</code>数组。<br>贪心算法的实现如下：  </p><pre><code class="py"><span class="function"><span class="keyword">def</span> <span class="title">greedy</span><span class="params">(self, heuristic_mode)</span>:</span>    cur_node = self.start    nodes = PriorityQueue()    nodes.put((cur_node.cost(heuristic_mode), cur_node))    visited = []    <span class="keyword">while</span> <span class="keyword">True</span>:        <span class="keyword">if</span> nodes.empty():            <span class="keyword">return</span> <span class="keyword">None</span>        cur_node = nodes.get()[<span class="number">1</span>]        <span class="keyword">if</span> cur_node.isGoal():            <span class="keyword">return</span> cur_node        <span class="keyword">elif</span> cur_node.state.puzzle <span class="keyword">not</span> <span class="keyword">in</span> visited:            visited.append(cur_node.state.puzzle)            <span class="keyword">for</span> neighbor <span class="keyword">in</span> cur_node.neighbors():                nodes.put((neighbor.cost(heuristic_mode), neighbor))</code></pre><h3 id="A"><a href="#A" class="headerlink" title="A*"></a>A*</h3><p>启发式函数<code>h(n)</code>告诉<code>A*</code>从任何结点n到目标结点的最小代价评估值。因此选择一个好的启发式函数很重要。<br><code>A*</code> 计算<code>f(n) = g(n) + h(n)</code>。为了将两个值相加，这两个值必须使用相同的单位去度量。如果度量<code>g(n)</code>的单位是小时，衡量<code>h(n)</code>的单位是米，则<code>A*</code>将认为g或h太大或太小，因此，要么无法得到好的路径，要么<code>A*</code>的运行速度会更慢。<br><code>A*</code>算法的伪代码如下：  </p><div align="center"><br><img src="/images/aStar.png" width="60%" alt="A*"><br></div>    <p><code>A*</code>算法实现如下：  </p><pre><code class="py"><span class="function"><span class="keyword">def</span> <span class="title">aStar</span><span class="params">(self, heuristic_mode)</span>:</span>    cur_node = self.start    nodes = PriorityQueue()    nodes.put((cur_node.cost(heuristic_mode), cur_node))    visited = []    <span class="keyword">while</span> <span class="keyword">True</span>:        <span class="keyword">if</span> nodes.empty():            <span class="keyword">return</span> <span class="keyword">None</span>        cur_node = nodes.get()[<span class="number">1</span>]        <span class="keyword">if</span> cur_node.isGoal():            <span class="keyword">return</span> cur_node        <span class="keyword">elif</span> cur_node.state.puzzle <span class="keyword">not</span> <span class="keyword">in</span> visited:            visited.append(cur_node.state.puzzle)            <span class="keyword">for</span> neighbor <span class="keyword">in</span> cur_node.neighbors():                nodes.put((neighbor.cost(heuristic_mode) + neighbor.depth, neighbor))</code></pre><h3 id="启发式函数"><a href="#启发式函数" class="headerlink" title="启发式函数"></a>启发式函数</h3><p>针对八数码问题，考虑两个相对间的的启发式函数：  </p><ol><li><code>wrongPlace</code>，摆放位置错位的数字个数。  </li><li><code>distance_manhattan</code>，曼哈顿距离，计算元素当前位置到目标位置的曼哈顿距离之和。  </li></ol><p>两个启发式函数的代码如下：  </p><pre><code class="py"><span class="function"><span class="keyword">def</span> <span class="title">cost</span><span class="params">(self, heuristic_mode)</span>:</span>    <span class="keyword">return</span> self.placeWrong() <span class="keyword">if</span> heuristic_mode == <span class="number">0</span> <span class="keyword">else</span> self.distance_manhattan()<span class="function"><span class="keyword">def</span> <span class="title">placeWrong</span><span class="params">(self)</span>:</span>    errors = <span class="number">0</span>    count = <span class="number">1</span>    all = self.state.order ** <span class="number">2</span>    <span class="keyword">for</span> i <span class="keyword">in</span> range(self.state.order):        <span class="keyword">for</span> j <span class="keyword">in</span> range(self.state.order):            <span class="keyword">if</span> self.state.puzzle[i][j] != count % all:                errors += <span class="number">1</span>            count += <span class="number">1</span>    <span class="keyword">return</span> errors<span class="function"><span class="keyword">def</span> <span class="title">distance_manhattan</span><span class="params">(self)</span>:</span>    res = <span class="number">0</span>    <span class="keyword">for</span> i <span class="keyword">in</span> range(self.state.order):        <span class="keyword">for</span> j <span class="keyword">in</span> range(self.state.order):            index = self.state.puzzle[i][j] - <span class="number">1</span>            dis = <span class="number">0</span> <span class="keyword">if</span> index == <span class="number">-1</span> <span class="keyword">else</span> abs(i - int(index/self.state.order)) + abs(j - int(index % self.state.order))            res += dis    <span class="keyword">return</span> res</code></pre><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="Puzzle-Node"><a href="#Puzzle-Node" class="headerlink" title="Puzzle, Node"></a>Puzzle, Node</h3><p>上文的两段思考提到，首先需要将<code>Puzzle</code>的生成、移动、深度等方法或属性集成；接着，我们的算法操作的都是状态节点，而不是状态本身，为了方便对<code>Puzzle</code>进行堆栈、队列操作，同时分离二者有助于我们后续添加算法，因此再构建<code>Node</code>类，并将启发式函数归为本类。   </p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>在<code>solution.py</code>中，集成了问题求解的几个算法。</p><h3 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h3><p>在<code>misc.py</code>中，设计了两个函数计算随机生成状态的逆序和，以及判断是否可解。<br>最终测试结果在<code>AIMA_HW1_Test.ipynb</code>文件中。</p><h2 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h2><p>生成30个随机初始状态。  </p><pre><code class="py">order = <span class="number">3</span>steps = <span class="number">30</span>puzzles = []<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">30</span>):    t = puzzle.Puzzle(order)    t.shuffle(steps)    puzzles.append(t)</code></pre><p>生成的随机初始状态如下：  </p><pre>1 0 2       2 3 6       1 2 3       1 3 0 7 6 3       1 4 0       4 8 5       5 2 65 4 8       7 5 8       7 6 0       4 7 81 8 2       2 5 3       1 3 5       1 3 6 5 4 3       4 1 0       4 2 0       4 0 80 7 6       7 8 6       7 8 6       7 2 50 2 3       1 5 2       1 5 2       4 1 21 5 6       0 4 3       3 7 6       5 3 04 7 8       7 8 6       4 0 8       7 8 62 4 3       1 0 5       1 2 3       1 2 30 7 5       4 3 2       7 4 6       4 0 68 1 6       7 8 6       0 5 8       7 5 8...</pre>  <p>执行不同搜索算法，并记录平均执行时间：  </p><pre><code class="py"><span class="comment"># 0: Greedy with wrongplace cost</span><span class="comment"># 1: Greedy with manhattan cost</span><span class="comment"># 2: A* with wrongplace cost</span><span class="comment"># 3: A* with manhattan cost</span><span class="comment"># 4: IDS</span><span class="function"><span class="keyword">def</span> <span class="title">eval</span><span class="params">(puzzles, algos)</span>:</span>    timeuse = []    <span class="keyword">for</span> i <span class="keyword">in</span> algos:        start = time.time()        <span class="keyword">if</span> i == <span class="number">4</span>:            print(<span class="string">"-------------------IDS------------------------"</span>)            <span class="keyword">for</span> t <span class="keyword">in</span> puzzles:<span class="comment">#                 t.toString()</span>                s = solution.Solution(t)                print(<span class="string">"Routes:"</span>, s.IDS())        <span class="keyword">elif</span> i == <span class="number">0</span>:            print(<span class="string">"----------Greedy heuristic wrongPlace----------------"</span>)            <span class="keyword">for</span> t <span class="keyword">in</span> puzzles:<span class="comment">#                 t.toString()</span>                s = solution.Solution(t)                print(<span class="string">"Routes:"</span>, s.greedy(<span class="number">0</span>))        <span class="keyword">elif</span> i == <span class="number">1</span>:            print(<span class="string">"----------Greedy heuristic manhattan----------------"</span>)            <span class="keyword">for</span> t <span class="keyword">in</span> puzzles:<span class="comment">#                 t.toString()</span>                s = solution.Solution(t)                print(<span class="string">"Routes:"</span>, s.greedy(<span class="number">1</span>))        <span class="keyword">elif</span> i == <span class="number">2</span>:            print(<span class="string">"-------------A* heuristic wrongPlace----------------"</span>)            <span class="keyword">for</span> t <span class="keyword">in</span> puzzles:<span class="comment">#                 t.toString()</span>                s = solution.Solution(t)                print(<span class="string">"Routes:"</span>, s.aStar(<span class="number">0</span>))        <span class="keyword">elif</span> i == <span class="number">3</span>:            print(<span class="string">"-------------A* heuristic manhattan-----------------"</span>)            <span class="keyword">for</span> t <span class="keyword">in</span> puzzles:<span class="comment">#                 t.toString()</span>                s = solution.Solution(t)                print(<span class="string">"Routes:"</span>, s.aStar(<span class="number">1</span>))        print(<span class="string">"--------------------Time------------------------------"</span>)        during = time.time() - start        timeuse.append(during)        print(during/len(puzzles))        print(<span class="string">"----------------------------------------------------------"</span>)    <span class="keyword">return</span> timeusetimeuse = eval(puzzles, [<span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])print(timeuse)</code></pre><h3 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h3><p><strong>IDS执行结果</strong>  </p><div align="center"><br><img src="/images/IDS_run.png" width="60%" alt="IDS_run"><br></div>   <p><strong>Greedy, wrongPlace执行结果</strong>  </p><div align="center"><br><img src="/images/Greedy_run1.png" width="60%" alt="Greedy_wrongPlace"><br></div>   <p><strong>Greedy, manhattan执行结果</strong>  </p><div align="center"><br><img src="/images/Greedy_run2.png" width="60%" alt="Greedy_manhattan"><br></div>   <p><strong>AStar, wrongPlace执行结果</strong>  </p><div align="center"><br><img src="/images/AStar_run1.png" width="60%" alt="AStar_wrongPlace"><br></div>   <p><strong>AStar, manhattan执行结果</strong>  </p><div align="center"><br><img src="/images/AStar_run2.png" width="60%" alt="AStar_manhattan"><br></div>   <h3 id="结果分析-1"><a href="#结果分析-1" class="headerlink" title="结果分析"></a>结果分析</h3><h4 id="不同方法比较"><a href="#不同方法比较" class="headerlink" title="不同方法比较"></a>不同方法比较</h4><p><code>IDS</code>, <code>Greedy</code>与<code>A*</code>算法表现出了截然不同的性能。<code>IDS</code>的执行情况非常不理想，其余二者的算法表现都令人相当满意。经过多次的生成以及执行，发现<code>Greedy</code>与<code>A*</code>相对稳定，基本上可以保持这个平均用时得到解路径；但是<code>IDS</code>经常性出现执行时间明显过久。  </p><h4 id="不同启发式函数比较"><a href="#不同启发式函数比较" class="headerlink" title="不同启发式函数比较"></a>不同启发式函数比较</h4><p>本次实验用了两个启发式函数，分别是 <code>wrongPlace</code>（摆放位置错位的数字个数）、<code>distance_manhattan</code>（曼哈顿距离，计算元素当前位置到目标位置的曼哈顿距离之和）。分析可知，曼哈顿距离的度量包含了错误摆放度量的结果。因此，使用曼哈顿距离的算法表现应该相对较好。实验也证实了这一点，在<code>Greedy</code>算法中，<code>distance_manhattan</code>比<code>wrongPlace</code>执行快约7倍；在<code>A*</code>算法中，<code>distance_manhattan</code>比<code>wrongPlace</code>执行快约3倍。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>经过本次实验，我对经典的搜索算法有了深刻的认识，在编写Solution代码的时候，通过抽取公用代码，极大简化了代码并降低了最终的代码量。通过对比两个启发式函数，理解了一个“好的”启发式函数对问题求解的重要性。  </p><p><strong><a href="">source code-&gt;github</a></strong>   </p><div class="footnotes"><ol><br>    <li class="footnote" id="fn:1"><br>        <p><a href="https://github.com/XFeiF/PRML-AIMA_Practice/tree/master/AIMA/8_puzzle_solution" target="_blank" rel="noopener">Source Code.  If you like it, please give a star!</a> <a href="#fnref:1" title="Source Code"> </a></p><p><br>    </p></li><br></ol></div> <script type="text/javascript">    $.bigfoot();</script><script type="text/javascript">    var bigfoot = $.bigfoot({        deleteOnUnhover: false,        preventPageScroll: false,        hoverDelay: 250,    });</script>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;AIMA: 8-puzzles&lt;/center&gt;  

&lt;p&gt;&lt;strong&gt;topics&lt;/strong&gt;: &lt;code&gt;DFS&lt;/code&gt;, &lt;code&gt;IDS&lt;/code&gt;, &lt;code&gt;A*&lt;/code&gt;, &lt;code&gt;Greedy&lt;/code&gt;, &lt;code&gt;Informed Search&lt;/code&gt; &lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnote&quot;&gt;1&lt;/a&gt; &lt;/sup&gt;  &lt;/p&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;pre&gt;
8-puzzle problem
Given any randomly generated start state and a goal state shown below, implement the IDS, greedy search and A* search algorithms, respectively, to find a sequence of actions that will transform the state from the start state to the goal state.
&lt;/pre&gt;
    
    </summary>
    
      <category term="Machine Learning" scheme="http://blog.x-fei.me/categories/Machine-Learning/"/>
    
    
      <category term="algorithm" scheme="http://blog.x-fei.me/tags/algorithm/"/>
    
      <category term="search" scheme="http://blog.x-fei.me/tags/search/"/>
    
  </entry>
  
  <entry>
    <title>axis and argmax function</title>
    <link href="http://blog.x-fei.me/2018/10/16/argmax-function-and-its-usage/"/>
    <id>http://blog.x-fei.me/2018/10/16/argmax-function-and-its-usage/</id>
    <published>2018-10-15T16:53:13.000Z</published>
    <updated>2018-10-15T16:58:16.345Z</updated>
    
    <content type="html"><![CDATA[<p>简单讨论一下<code>argmax</code>函数及其用法，由于其在<code>numpy</code>和<code>PyTorch</code>中都有出现，所以先在<code>numpy</code>中讨论，然后补充介绍在<code>PyTorch</code>中的用法。  </p><p>同理我们可以理解<code>argmin</code>。</p><a id="more"></a><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><pre>numpy.argmax(a, axis=None, out=None)[source]Returns the indices of the maximum values along an axis.  Returns:    index_array : ndarray of intsArray of indices into the array. It has the same shape as a.shape with the dimension along axis removed.</pre> <p>如API中描述的，它返回某一轴上最大值所在位置的下标。它有一个非常重要的参数<code>axis</code>。    </p><h3 id="axis"><a href="#axis" class="headerlink" title="axis"></a>axis</h3><pre>axis : int, optionalBy default, the index is into the flattened array, otherwise along the specified axis.</pre>  <p>比如：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一维</span></span><br><span class="line">b = np.asarray([<span class="number">0</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line">np.argmax(b)  <span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 二维  </span></span><br><span class="line">a = np.asarray([[<span class="number">0</span>, <span class="number">2</span>, <span class="number">5</span>], [<span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>]])</span><br><span class="line">np.argmax(a) <span class="comment"># 2</span></span><br><span class="line">np.argmax(a, axis=<span class="number">1</span>) <span class="comment"># array([2, 0])</span></span><br></pre></td></tr></table></figure></p><p>对于一维的情况，最大值是5，但是注意它只返回第一个最大值元素的下标，所以这里是1。<br>对于二维的情况，需要指定其在哪一个轴上做，比如这里<code>a.shape</code>为<code>(2,3)</code>，如果axis不指定，那就默认把它平坦化，变成<code>array([0, 2, 5, 4, 1, 3]</code>，同一维情况一样，返回2；如果指定<code>axis=1</code>，表明在<code>[0, 2, 5]</code>，<code>[4, 1, 3]</code>上分别执行，前者返回2，后者返回0，所以结果返回<code>array([2, 0])</code>。</p><p><em>问：如果指定<code>axis=0</code>呢？</em><br>这就需要我们对<code>axis</code>有更清晰的理解了。以数组<code>a</code>为例，它元素可以用$a_ij$来表示，其中i表示第0维，j表示第1维，这里的维就可以理解为轴，i表示纵轴，j表示横轴。<br>所以<code>axis=1</code>时，就表示以横轴为单位进行运算，因此返回数组与纵轴元素的数目相同。<br>同理，<code>axis=0</code>时，以纵轴为单位运算，即<code>a[0][0] vs a[1][0], a[0][1] vs a[1][1], a[0][2] vs a[1][2]</code>，返回数组与纵轴元素的数目相同，结果为<code>array([1, 0, 0])</code>。  </p><p><strong>更高维的情况呢？</strong><br>总结为一句话，<code>a_i...k...n</code>，设<code>axis=k</code>，那么沿着第<code>k</code>个下标的位置进行操作。<br>例如三维的情况：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">check = np.asarray([[[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],[<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>],[<span class="number">4</span> , <span class="number">5</span> , <span class="number">6</span> ],[<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]],</span><br><span class="line">                    [[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>],[<span class="number">7</span> , <span class="number">8</span> , <span class="number">9</span> ],[<span class="number">1</span> , <span class="number">2</span> , <span class="number">3</span> ],[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]],</span><br><span class="line">                    [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],[<span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>], [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>],[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]]])</span><br><span class="line"><span class="comment">#  check.shape  (3, 4, 3)</span></span><br><span class="line">np.argmax(check, axis=<span class="number">0</span>)  <span class="comment"># eg: 1, 4, 1 -&gt; 1</span></span><br><span class="line"><span class="comment"># array([[1 1 1] [0 0 0] [2 2 2] [0 0 0]])</span></span><br><span class="line">np.argmax(check, axis=<span class="number">1</span>)  <span class="comment"># eg: 1, 10, 4, 7 -&gt; 1</span></span><br><span class="line"><span class="comment"># array([[1 1 1] [1 1 1] [2 2 2]]) </span></span><br><span class="line">np.argmax(check, axis=<span class="number">2</span>)  <span class="comment"># eg: 1, 2, 3</span></span><br><span class="line"><span class="comment"># array([[2 2 2 2] [2 2 2 2] [2 2 2 2]])</span></span><br></pre></td></tr></table></figure></p><h3 id="PyTorch"><a href="#PyTorch" class="headerlink" title="PyTorch"></a>PyTorch</h3><p>PyTorch里的对应<code>axis</code>参数为<code>dim</code>，更为直观，表示在第几维做操作。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单讨论一下&lt;code&gt;argmax&lt;/code&gt;函数及其用法，由于其在&lt;code&gt;numpy&lt;/code&gt;和&lt;code&gt;PyTorch&lt;/code&gt;中都有出现，所以先在&lt;code&gt;numpy&lt;/code&gt;中讨论，然后补充介绍在&lt;code&gt;PyTorch&lt;/code&gt;中的用法。  &lt;/p&gt;
&lt;p&gt;同理我们可以理解&lt;code&gt;argmin&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="Machine Learning" scheme="http://blog.x-fei.me/categories/Machine-Learning/"/>
    
    
      <category term="PyTorch" scheme="http://blog.x-fei.me/tags/PyTorch/"/>
    
      <category term="Code" scheme="http://blog.x-fei.me/tags/Code/"/>
    
  </entry>
  
  <entry>
    <title>GD &amp; SGD 理解与二维模拟</title>
    <link href="http://blog.x-fei.me/2018/10/10/GD-SGD-%E7%90%86%E8%A7%A3%E4%B8%8E%E4%BA%8C%E7%BB%B4%E6%A8%A1%E6%8B%9F/"/>
    <id>http://blog.x-fei.me/2018/10/10/GD-SGD-理解与二维模拟/</id>
    <published>2018-10-10T13:12:56.000Z</published>
    <updated>2018-10-11T16:53:59.968Z</updated>
    
    <content type="html"><![CDATA[<p><strong><center>Machine Learning Exercise 2</center></strong>    </p><h3 id="实验题目"><a href="#实验题目" class="headerlink" title="实验题目"></a>实验题目</h3><ol><li>Generate n = 2,000 points uniformly at random in the two-dimensional unit square. Which point do you expect the centroid to be?  </li><li>What objective does the centroid of the points optimize?  </li><li>Apply gradient descent (GD) to find the centroid.  </li><li>Apply stochastic gradient descent (SGD) to find the centroid. Can you<br>say in simple words, what the algorithm is doing?  </li></ol><a id="more"></a><h3 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h3><p>1)编程语言不限。<br>2)作业包含一份报告(word 或 pdf 格式)及代码加注释，并打包到.zip，其中 zip 文件的命名格式为学号_姓名。<br>3)不允许使用梯度下降相关的库函数。<br>4)禁止抄袭。    </p><h3 id="实验过程及代码"><a href="#实验过程及代码" class="headerlink" title="实验过程及代码"></a>实验过程及代码</h3><h4 id="Q1"><a href="#Q1" class="headerlink" title="Q1"></a>Q1</h4><p><strong>Generate n = 2,000 points uniformly at random in the two-dimensional unit square. Which point do you expect the centroid to be?</strong><br>在数学和物理学中，平面图形的质心或几何中心是图中所有点的算术平均值；在几何学中，重心时质心的同义词；在天体物理学和天文学中，重心是两个或多个轨道相互环绕的物质的质心。如果物理对象具有均匀的密度，则其质心与其形状的质心相同。<br>首先生成2000个分布在0~1范围之间的随机散点，从统计学的角度理解，它们具有均匀的密度，质心是最能代表这群点的点，它到所有点距离之和最小。由于点的生成是随机的，所以期望的点是<code>(0.5, 0.5)</code>。  </p><p>我们利用如下的代码生成2000个分布在0~1范围之间的随机散点，用蓝色点标出，同时用红点标注我们期望的质心。  </p><pre><code class="py"><span class="keyword">import</span> numpy <span class="keyword">as</span> np<span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt  Sample_num = <span class="number">2000</span>x = np.random.random_sample((Sample_num, ))y = np.random.random_sample((Sample_num, ))plt.figure(figsize=(<span class="number">8</span>, <span class="number">8</span>))plt.plot(x, y, <span class="string">'b.'</span>)plt.plot(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="string">'ro'</span>)</code></pre><div align="center"><br><img src="/images/hw2_points.png" width="60%" alt="Sample"><br></div>   <h4 id="Q2"><a href="#Q2" class="headerlink" title="Q2"></a>Q2</h4><p><strong>What objective does the centroid of the points optimize?</strong><br>在<em>Q1</em>中我们分析得到，质心是一群点中到其他所有点距离和最小的点，所以我们的目标就是最小化距离之和。<br>假设当前点为:<code>C(x,y)</code>，与其他所有点的距离为<code>dist(x,y)</code>。所以优化的目标是：  </p><div align="center"><br><img src="/images/dist_func.png" width="60%" alt="optimize_func"><br></div>    <p>此时我们可以定义损失函数如下：  </p><pre><code class="py"><span class="function"><span class="keyword">def</span> <span class="title">cost</span><span class="params">(c, points)</span>:</span>    <span class="string">'''</span><span class="string">    params:</span><span class="string">      c: (x,y) 表示待求的质心坐标</span><span class="string">      points: 所有的点</span><span class="string">    return:</span><span class="string">      dist: c到所有点的距离之和 </span><span class="string">    '''</span>    <span class="keyword">return</span> sum(sum((c - points) ** <span class="number">2</span>, axis=<span class="number">1</span>) ** <span class="number">0.5</span>)</code></pre><h4 id="Q3"><a href="#Q3" class="headerlink" title="Q3"></a>Q3</h4><p><strong>Apply gradient descent (GD) to find the centroid.</strong>  </p><h5 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h5><p>根据损失函数<code>cost</code>，求出其在当前点<code>(x, y)</code>两个维度上的梯度<code>(dx, dy)</code>，梯度求解的公式如下：  </p><div align="center"><br><img src="/images/grad_dist.png" width="60%" alt="grad"><br></div>     <p>其代码如下：  </p><pre><code class="py"><span class="function"><span class="keyword">def</span> <span class="title">gradient_raw</span><span class="params">(c, points)</span>:</span>    <span class="string">'''</span><span class="string">    params:</span><span class="string">      c: (x,y) 表示待求的质心坐标</span><span class="string">      points: 所有的点</span><span class="string">    return:</span><span class="string">      (dx, dy), 在c点时cost在两个维度方向的梯度</span><span class="string">    '''</span>    x = points[:, <span class="number">0</span>]    y = points[:, <span class="number">1</span>]    dist = sum((c - points) ** <span class="number">2</span>, axis=<span class="number">1</span>) ** <span class="number">0.5</span>    dx = sum((c[<span class="number">0</span>] - x) / dist)  <span class="comment">#求x偏导数</span>    dy = sum((c[<span class="number">1</span>] - y) / dist)  <span class="comment">#求y偏导数</span>    <span class="keyword">return</span> np.asarray([dx, dy])</code></pre><h5 id="GD"><a href="#GD" class="headerlink" title="GD"></a>GD</h5><p>这一步设置一些参数，编写好梯度下降函数。</p><pre><code class="py"><span class="function"><span class="keyword">def</span> <span class="title">gradientDescent_raw</span><span class="params">(points, start=array<span class="params">([<span class="number">1</span>, <span class="number">1</span>])</span>, theta=<span class="number">0.01</span>, iterations=<span class="number">500</span>, eps=<span class="number">1e-6</span>)</span>:</span>    <span class="string">'''</span><span class="string">    params:</span><span class="string">      start: 初始化点，即出发点，为了便于观察，可以设置为四个顶点中的任意一个，这里默认为右上角的顶点</span><span class="string">      points: 所有采样点</span><span class="string">      theta: 步长，即学习率，控制步长</span><span class="string">      iterations: 迭代次数</span><span class="string">      eps: 阈值，通过比较前后连续两次的cost差值控制迭代。</span><span class="string">    return:</span><span class="string">      x_route: centroid路径</span><span class="string">      x: 收敛时的centroid</span><span class="string">      i: end iteration, 退出迭代时已经迭代了多少次</span><span class="string">    '''</span>    x = start    x_route = x    pre_cost = cost(x, points) <span class="comment"># 初始cost</span>    <span class="keyword">for</span> i <span class="keyword">in</span> range(iterations):        grad = gradient(x, points)        x_i = x - theta * grad        cur_cost = cost(x_i, points)        <span class="keyword">if</span> abs(pre_cost - cur_cost) &gt; eps: <span class="comment"># 前一个cost与当前cost的差大于阈值，可以继续迭代</span>            x = x_i            pre_cost = cur_cost        <span class="keyword">else</span>:            <span class="keyword">return</span> x_route, x, i+<span class="number">1</span>        x_route = vstack((x_route, x))    <span class="keyword">return</span> x_route, x, i+<span class="number">1</span></code></pre><h5 id="结果绘图与分析"><a href="#结果绘图与分析" class="headerlink" title="结果绘图与分析"></a>结果绘图与分析</h5><p>编写辅助函数与测试函数。  </p><pre><code class="py"><span class="function"><span class="keyword">def</span> <span class="title">plotRoute</span><span class="params">(points, route, c, endIteration)</span>:</span>    plt.plot(points[:, <span class="number">0</span>], points[:, <span class="number">1</span>], <span class="string">'b,'</span>)    plt.plot(route[:, <span class="number">0</span>], route[:, <span class="number">1</span>], <span class="string">'r.'</span>)    plt.plot(route[:, <span class="number">0</span>], route[:, <span class="number">1</span>], <span class="string">'k-'</span>)    plt.xlabel(<span class="string">'c = (%.3f, %.3f), endAt = %d'</span> % (c[<span class="number">0</span>], c[<span class="number">1</span>], endIteration))    print(c)    plt.show()<span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span>    x_b, c, i = gradientDescent(points, theta=<span class="number">0.1</span>,, iterations=<span class="number">1000</span>, lr_decay=<span class="number">0.8</span>)    plotRoute(points, x_b, c, i)</code></pre><p>运行上面的程序并绘图。</p><div align="center"><br><img src="/images/gd_2errors.png" width="60%" alt="Error1"><br></div>     <p>结果分析：  </p><p><strong>问题1：不收敛</strong><br>图示路径与最终得到的<code>centroid(x,y)</code>表明达到<strong>最大迭代次数后，没有收敛</strong>，尝试了增大迭代次数到10000，100000之后依然得到的是类似的结果。<br>观察发现路径不是一点一点慢慢向中心靠拢，而是在两边很夸张地跳跃，因此问题出在theta，也就是我们熟悉的学习率上。当某一步“跨”的过大，即本次迭代更新后的<code>cur_cost</code>比<code>pre_cost</code>要大的时候，说明我们不是朝着下降的方向在走，此时要调整我们的步伐，迈小一点的步子。因此我们更新我们的梯度下降函数如下。 </p><pre><code class="py"><span class="function"><span class="keyword">def</span> <span class="title">gradientDescent</span><span class="params">(points, start=array<span class="params">([<span class="number">1</span>, <span class="number">1</span>])</span>, theta=<span class="number">0.01</span>, iterations=<span class="number">500</span>, eps=<span class="number">1e-6</span>, lr_decay=<span class="number">0.5</span>)</span>:</span>    <span class="string">'''</span><span class="string">    params:</span><span class="string">      start: 初始化点，即出发点，为了便于观察，可以设置为四个顶点中的任意一个，这里默认为右上角的顶点</span><span class="string">      points: 所有采样点</span><span class="string">      theta: 步长，即学习率，控制步长</span><span class="string">      iterations: 迭代次数</span><span class="string">      eps: 阈值，通过比较前后连续两次的cost差值控制迭代</span><span class="string">      lr_decay: 步长衰减比例</span><span class="string">    return:</span><span class="string">      x_route: centroid路径</span><span class="string">      x: 收敛时的centroid</span><span class="string">      i: end iteration, 退出迭代时已经迭代了多少次</span><span class="string">    '''</span>    x = start    x_route = x    pre_cost = cost(x, points) <span class="comment"># 初始cost</span>    <span class="keyword">for</span> i <span class="keyword">in</span> range(iterations):        grad = gradient(x, points)        x_i = x - theta * grad        cur_cost = cost(x_i, points)        <span class="keyword">if</span> pre_cost - cur_cost &gt; eps: <span class="comment"># 前一个cost与当前cost的差大于阈值，可以继续迭代</span>            x = x_i            pre_cost = cur_cost        <span class="keyword">elif</span> cur_cost - pre_cost &gt; eps: <span class="comment"># 这一步“跨”的过大，调小步长</span>            theta = theta * lr_decay        <span class="keyword">else</span>:            <span class="keyword">return</span> x_route, x, i+<span class="number">1</span>        x_route = vstack((x_route, x))    <span class="keyword">return</span> x_route, x, i+<span class="number">1</span></code></pre><p>再次运行结果绘图。  </p><div align="center"><br><img src="/images/hw2_error1.png" width="60%" alt="Error2"><br></div>     <p>出现新的问题。<br><strong>问题2:第一步直接“跨”到中心位置附近</strong><br>在<code>gradient_raw</code>函数中，我们得到的梯度不仅包含方向，也包含了在该方向上的长度，这个长度数值可能较大，因此我们将其单位化，即<code>dx</code>和<code>dy</code>分别除以它们的欧式距离。因此更新我们的<code>gradient</code>函数如下。  </p><pre><code class="py"><span class="function"><span class="keyword">def</span> <span class="title">gradient</span><span class="params">(c, points)</span>:</span>    <span class="string">'''</span><span class="string">    params:</span><span class="string">      c: (x,y) 表示待求的质心坐标</span><span class="string">      points: 所有的点</span><span class="string">    return:</span><span class="string">      (dx, dy), 在c点时cost在两个维度方向的梯度</span><span class="string">    '''</span>    x = points[:, <span class="number">0</span>]    y = points[:, <span class="number">1</span>]    dist = sum((c - points) ** <span class="number">2</span>, axis=<span class="number">1</span>) ** <span class="number">0.5</span>    dx = sum((c[<span class="number">0</span>] - x) / dist)  <span class="comment">#求x偏导数</span>    dy = sum((c[<span class="number">1</span>] - y) / dist)  <span class="comment">#求y偏导数</span>    s = (dx ** <span class="number">2</span> + dy ** <span class="number">2</span>) ** <span class="number">0.5</span> <span class="comment"># 欧式距离</span>    dx = dx/s    dy = dy/s    <span class="keyword">return</span> np.asarray([dx, dy])</code></pre><p>运行结果绘图。  </p><div align="center"><br><img src="/images/gd_good.png" width="60%" alt="GradientDescent"><br></div>     <p>图中红色的点(由于比较密集，看起来像线)，表示路径上的点，在稳步向中心靠拢，最终得到的质心也接近理想的质心。至此，完成本部分实验。  </p><h4 id="Q4"><a href="#Q4" class="headerlink" title="Q4"></a>Q4</h4><p><strong>Apply stochastic gradient descent (SGD) to find the centroid. Can you say in simple words, what the algorithm is doing?</strong>    </p><p>随机梯度下降和梯度下降的区别：  </p><ol><li>梯度下降需要所有点都参与梯度更新；随机梯度下降是每次迭代时，随机选取一个点计算梯度。  </li><li>梯度下降最终的结果是一般是稳定的，即稳定收敛到某个点；随机梯度下降可能会陷入某个局部最小值。  </li></ol><p>修改<code>gradient</code>参数，使得迭代时随机选取一个点。  </p><pre><code class="py"><span class="function"><span class="keyword">def</span> <span class="title">stochasticgradient</span><span class="params">(c, points)</span>:</span>    <span class="string">'''</span><span class="string">    params:</span><span class="string">      c: (x,y) 表示待求的质心坐标</span><span class="string">      points: 所有的点</span><span class="string">    return:</span><span class="string">      (dx, dy), 在c点时cost在两个维度方向的梯度</span><span class="string">    '''</span>    r = choice(points)    dx = (c[<span class="number">0</span>] - r[<span class="number">0</span>]) / sum((c - r) ** <span class="number">2</span>) ** <span class="number">0.5</span> <span class="comment"># x偏导</span>    dy = (c[<span class="number">1</span>] - r[<span class="number">1</span>]) / sum((c - r) ** <span class="number">2</span>) ** <span class="number">0.5</span>  <span class="comment"># y偏导</span>    s = (dx ** <span class="number">2</span> + dy ** <span class="number">2</span>) ** <span class="number">0.5</span>    dx = dx/s    dy = dy/s    <span class="keyword">return</span> array([dx, dy])</code></pre><p>我们修改<code>gradientDescent</code>函数，在计算梯度的时候调用<code>stochasticgradient</code>方法，这样我们把计算梯度所用的函数作为一个参数，同样传递进去。修改后代码如下：  </p><pre><code class="py"><span class="function"><span class="keyword">def</span> <span class="title">gd_final</span><span class="params">(points, gd_method=gradient,start=array<span class="params">([<span class="number">1</span>, <span class="number">1</span>])</span>, theta=<span class="number">0.01</span>, iterations=<span class="number">500</span>, eps=<span class="number">1e-6</span>, lr_decay=<span class="number">0.5</span>)</span>:</span>    <span class="string">'''</span><span class="string">    params:</span><span class="string">      gd_method: 迭代的方式，可以在(stochasticgradient, gradient)中选择</span><span class="string">      start: 初始化点，即出发点，为了便于观察，可以设置为四个顶点中的任意一个，这里默认为右上角的顶点</span><span class="string">      points: 所有采样点</span><span class="string">      theta: 步长，即学习率，控制步长</span><span class="string">      iterations: 迭代次数</span><span class="string">      eps: 阈值，通过比较前后连续两次的cost差值控制循环结束。</span><span class="string">    return:</span><span class="string">      x_route: centroid路径</span><span class="string">      x: 收敛时的centroid</span><span class="string">      i: end iteration, 退出迭代时已经迭代了多少次</span><span class="string">    '''</span>    x = start    x_route = x    pre_cost = cost(x, points) <span class="comment"># 初始cost</span>    <span class="keyword">for</span> i <span class="keyword">in</span> range(iterations):        grad = gd_method(x, points)        x_i = x - theta * grad        cur_cost = cost(x_i, points)        <span class="keyword">if</span> pre_cost - cur_cost &gt; eps: <span class="comment"># 前一个cost与当前cost的差大于阈值，可以继续迭代</span>            x = x_i            pre_cost = cur_cost        <span class="keyword">elif</span> cur_cost - pre_cost &gt; eps: <span class="comment"># 这一步“跨”的过大，调小步长</span>            theta = theta * lr_decay        <span class="keyword">else</span>:            <span class="keyword">return</span> x_route, x, i+<span class="number">1</span>        x_route = vstack((x_route, x))    <span class="keyword">return</span> x_route, x, i+<span class="number">1</span></code></pre><p>最终得到下图：  </p><div align="center"><br><img src="/images/sgd_good.png" width="60%" alt="SGD"><br></div>    <p>这张图是在多次调整参数多次运行之后得到结果相对较好的图。 下面两张则是陷入局部最小时的情况。  </p><div align="center"><br><img src="/images/sgd_rand.png" width="60%" alt="SGD_rand"><br></div>    <p>可以看到，由于是随机选取的点，所以在找最优值的过程是曲折的。但是最终还是会收敛。  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;&lt;center&gt;Machine Learning Exercise 2&lt;/center&gt;&lt;/strong&gt;    &lt;/p&gt;
&lt;h3 id=&quot;实验题目&quot;&gt;&lt;a href=&quot;#实验题目&quot; class=&quot;headerlink&quot; title=&quot;实验题目&quot;&gt;&lt;/a&gt;实验题目&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;Generate n = 2,000 points uniformly at random in the two-dimensional unit square. Which point do you expect the centroid to be?  &lt;/li&gt;
&lt;li&gt;What objective does the centroid of the points optimize?  &lt;/li&gt;
&lt;li&gt;Apply gradient descent (GD) to find the centroid.  &lt;/li&gt;
&lt;li&gt;Apply stochastic gradient descent (SGD) to find the centroid. Can you&lt;br&gt;say in simple words, what the algorithm is doing?  &lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Machine Learning" scheme="http://blog.x-fei.me/categories/Machine-Learning/"/>
    
    
      <category term="Machine Learning" scheme="http://blog.x-fei.me/tags/Machine-Learning/"/>
    
      <category term="Code" scheme="http://blog.x-fei.me/tags/Code/"/>
    
  </entry>
  
  <entry>
    <title>你也想要重来吗</title>
    <link href="http://blog.x-fei.me/2018/10/08/%E4%BD%A0%E4%B9%9F%E6%83%B3%E8%A6%81%E9%87%8D%E6%9D%A5%E5%90%97/"/>
    <id>http://blog.x-fei.me/2018/10/08/你也想要重来吗/</id>
    <published>2018-10-08T04:27:38.000Z</published>
    <updated>2018-10-11T16:57:09.199Z</updated>
    
    <content type="html"><![CDATA[<p>上了发条跟有节奏感是两码事  </p><p>上发条是走固定模式<br>心已经在失控 行为看起来却没差  </p><p>有节奏感是由身心掌控<br>有条不紊地 把握现在 感知未来  </p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上了发条跟有节奏感是两码事  &lt;/p&gt;
&lt;p&gt;上发条是走固定模式&lt;br&gt;心已经在失控 行为看起来却没差  &lt;/p&gt;
&lt;p&gt;有节奏感是由身心掌控&lt;br&gt;有条不紊地 把握现在 感知未来  &lt;/p&gt;
    
    </summary>
    
      <category term="Fragments" scheme="http://blog.x-fei.me/categories/Fragments/"/>
    
    
      <category term="think" scheme="http://blog.x-fei.me/tags/think/"/>
    
      <category term="life" scheme="http://blog.x-fei.me/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>这辈子还有很多很丧的时候</title>
    <link href="http://blog.x-fei.me/2018/09/29/%E8%BF%99%E8%BE%88%E5%AD%90%E8%BF%98%E6%9C%89%E5%BE%88%E5%A4%9A%E5%BE%88%E4%B8%A7%E7%9A%84%E6%97%B6%E5%80%99/"/>
    <id>http://blog.x-fei.me/2018/09/29/这辈子还有很多很丧的时候/</id>
    <published>2018-09-29T13:53:13.000Z</published>
    <updated>2018-10-11T16:56:29.835Z</updated>
    
    <content type="html"><![CDATA[<p>总是不开心地太突然。  </p><a id="more"></a><center><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=853708&auto=1&height=66"></iframe></center>  <p>每日一丧的感觉呀哈哈。  </p><p>起因是刷一道leetcode题，想了很久没有想到怎么做，就去google了一下别人blog的题解，看到别人博客里记录的自己大学的点点滴滴。  </p><p>总有一种错觉，以为不走心，可以让自己立于不败之地。但事实上，只有那些走心的人，不怕输的人，拼尽全力的人，才是最后的赢家，因为他们走过的路，每一步都算输。  </p><p>我一直相信，在你虚弱的时候还能剩下的就是那个最真实的你。  </p><p>摔跤就摔跤了，是因为自己不够好，不怪任何人。  </p><p>即是在丧着的时候，依然扑腾着想要求解决些什么。  </p><p>再多的不如意，熬过去，不过是笔下的故事而已。  </p><p>想到将来未知的人生。<br>这辈子还那么长，你还要在荒芜里心碎很多次。<br>碎过了，拼起来，可以再碎出不同的裂痕，就算连裂痕都一样，也还是可以感觉到新鲜的疼痛，<br>流过的眼泪也还是那么真，<br>所以人生有意思啊。    </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总是不开心地太突然。  &lt;/p&gt;
    
    </summary>
    
      <category term="Fragments" scheme="http://blog.x-fei.me/categories/Fragments/"/>
    
    
      <category term="think" scheme="http://blog.x-fei.me/tags/think/"/>
    
      <category term="life" scheme="http://blog.x-fei.me/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>CS MindStorms</title>
    <link href="http://blog.x-fei.me/2018/09/25/CS-MindStorms/"/>
    <id>http://blog.x-fei.me/2018/09/25/CS-MindStorms/</id>
    <published>2018-09-25T14:59:26.000Z</published>
    <updated>2018-10-11T16:58:36.239Z</updated>
    
    <content type="html"><![CDATA[<center>⚡️ MindStorms Collections ⚡️</center>  <a id="more"></a>  <h2 id="脑筋急转弯"><a href="#脑筋急转弯" class="headerlink" title="脑筋急转弯"></a>脑筋急转弯</h2><p><strong>Q1:小白鼠问题</strong>:  有16瓶水，其中只有一瓶水有毒，小白鼠喝一滴之后一小时会死。请问最少用多少只小白鼠，在1小时内一定可以找出至少14瓶无毒的水？  </p><p><em>A1</em>:  <sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a> </sup>  </p><p><em>Remark</em>: 二进制编码的奥秘。思维僵局，一次可以喝多瓶🤦🏻‍。  </p><h2 id="空间感"><a href="#空间感" class="headerlink" title="空间感"></a>空间感</h2><p><strong>Q1: n维空间</strong>:  3维空间有8个定点，6个面，那么4维空间呢？n维空间呢？  </p><p><em>A1</em>: <sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a> </sup>  </p><p><em>Remark</em>: 烧脑。  </p><div class="footnotes"><ol><br>    <li class="footnote" id="fn:1"><br>        <p>答案是至少3只。二进制思想，将16瓶药水用二进制表示，为0000,0001,0010….1111, 取3只小白鼠，让第一只喝最低位为1的药水(xxx1即1,3,5,7,9,11,13,15)， 让第二只喝次最低位为1的药水(xx1x即2,3,6,7,10,11,14,15)，让第三只喝第三位为1的药水(x1xx即4,5,6,7,12,13,14,15)。。如果三只小白鼠都活着(111)，证明这14瓶药水无毒，有毒在0和8号瓶中；小白鼠状态为000（都死），有毒在7或者15号药水中；状态为(001) 有毒在4或者12号药水中。依次类推。。<a href="#fnref:1" title="小白鼠问题"> </a></p><p><br>    </p></li><br>     <li class="footnote" id="fn:2"><br>        <p>4维空间有16个顶点，24个面，8个体。n维空间有<strong>2^n</strong>个顶点，<strong>2n</strong>个体（前一维）。<a href="#fnref:2" title="n维空间"> </a></p><p><br>    </p></li><br></ol></div> <script type="text/javascript">    $.bigfoot();</script><script type="text/javascript">    var bigfoot = $.bigfoot({        deleteOnUnhover: false,        preventPageScroll: false,        hoverDelay: 250,    });</script>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;⚡️ MindStorms Collections ⚡️&lt;/center&gt;
    
    </summary>
    
      <category term="Geek" scheme="http://blog.x-fei.me/categories/Geek/"/>
    
    
      <category term="MindStorms" scheme="http://blog.x-fei.me/tags/MindStorms/"/>
    
      <category term="CS" scheme="http://blog.x-fei.me/tags/CS/"/>
    
      <category term="Math" scheme="http://blog.x-fei.me/tags/Math/"/>
    
      <category term="geek" scheme="http://blog.x-fei.me/tags/geek/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-Contest 103,104</title>
    <link href="http://blog.x-fei.me/2018/09/24/LeetCode-Contest_103-104/"/>
    <id>http://blog.x-fei.me/2018/09/24/LeetCode-Contest_103-104/</id>
    <published>2018-09-24T15:28:35.000Z</published>
    <updated>2018-10-11T16:58:08.656Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Contests"><a href="#Contests" class="headerlink" title="Contests"></a>Contests</h2><p>From Contest103 to Contest 104 ~<br><a id="more"></a></p><h3 id="Contest104"><a href="#Contest104" class="headerlink" title="Contest104"></a>Contest104</h3><h4 id="914-M"><a href="#914-M" class="headerlink" title="914-M"></a>914-M</h4><p><a href="https://leetcode.com/contest/weekly-contest-104/problems/x-of-a-kind-in-a-deck-of-cards/" target="_blank" rel="noopener">914. X of a Kind in a Deck of Cards</a></p><div><br>In a deck of cards, each card has an integer written on it.<br><br>Return true if and only if you can choose X &gt;= 2 such that it is possible to split the entire deck into 1 or more groups of cards, where:<br><br>Each group has exactly X cards.<br>All the cards in each group have the same integer.<br><br>Example 1:<br>Input: [1,2,3,4,4,3,2,1]<br>Output: true<br>Explanation: Possible partition [1,1],[2,2],[3,3],[4,4]<br><br>Example 2:<br>Input: [1,1,1,2,2,2,3,3]<br>Output: false<br>Explanation: No possible partition.<br><br>Example 3:<br>Input: [1]<br>Output: false<br>Explanation: No possible partition.<br><br>Example 4:<br>Input: [1,1]<br>Output: true<br>Explanation: Possible partition [1,1]<br><br>Example 5:<br>Input: [1,1,2,2,2,2]<br>Output: true<br>Explanation: Possible partition [1,1],[2,2],[2,2]<br><br>Note:<br>1 &lt;= deck.length &lt;= 10000<br>0 &lt;= deck[i] &lt; 10000<br><br>题目的意思是给一组数，把这组数分成若干小组，每小组包含的元素数目相同，至少为2，且组内的元素值相同。<br></div>  <p><strong>Intuition:</strong><br>比较直观，如何找到最好的那个K。<br>我们先统计这组数中每个数出现的频次，比如例2({1:3, 2:3, 3:2})(python可以利用Counter函数完成)。<br>因为分成的小组内的元素值相同，因此只能把同一个数分成若干组，且组内元素个数相同，这样我们需要考虑出现次数最少的数，它‘能’以及<br>需要分成多少组，假设出现次数最少的数的频次是min1，那么找一个刚好比它大的数，求二者的最大公约数res，这个公约数就是我们想要的K。</p><p>Code:  </p><pre><code class="py"><span class="comment"># 我的代码  </span><span class="function"><span class="keyword">def</span> <span class="title">hasGroupsSizeX</span><span class="params">(self, deck)</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">gcd</span><span class="params">(a, b)</span>:</span>        <span class="keyword">while</span> b: a, b = b, a % b        <span class="keyword">return</span> a    <span class="keyword">if</span> len(deck) &lt; <span class="number">2</span>: <span class="keyword">return</span> <span class="keyword">False</span>    values = list(collections.Counter(deck).values())    values.sort()    mina, maxa = values[<span class="number">0</span>], values[<span class="number">-1</span>]    <span class="keyword">if</span> mina == maxa: <span class="keyword">return</span> <span class="keyword">True</span>    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(values)):        <span class="keyword">if</span> values[i] != mina:            maxa = values[i]            <span class="keyword">break</span>    gg = gcd(mina, maxa)    <span class="keyword">if</span> gg &lt; <span class="number">2</span>:        <span class="keyword">return</span> <span class="keyword">False</span>    <span class="keyword">for</span> i <span class="keyword">in</span> values:        <span class="keyword">if</span> i % gg:            <span class="keyword">return</span> <span class="keyword">False</span>    <span class="keyword">return</span> <span class="keyword">True</span><span class="comment"># 大佬的代码</span><span class="function"><span class="keyword">def</span> <span class="title">hasGroupsSizeX</span><span class="params">(self, deck)</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">gcd</span><span class="params">(a, b)</span>:</span>        <span class="keyword">while</span> b: a, b = b, a % b        <span class="keyword">return</span> a    count = collections.Counter(deck).values()    <span class="keyword">return</span> reduce(gcd, count) &gt; <span class="number">1</span></code></pre><hr><h4 id="916-M"><a href="#916-M" class="headerlink" title="916-M"></a>916-M</h4><p><a href="https://leetcode.com/contest/weekly-contest-104/problems/word-subsets/" target="_blank" rel="noopener">916. Word Subsets</a>  </p><div><br>We are given two arrays A and B of words.  Each word is a string of lowercase letters.<br><br>Now, say that word b is a subset of word a if every letter in b occurs in a, including multiplicity.  For example, “wrr” is a subset of “warrior”, but is not a subset of “world”.<br><br>Now say a word a from A is universal if for every b in B, b is a subset of a.<br><br>Return a list of all universal words in A.  You can return the words in any order.<br><br>Example 1:<br>Input: A = [“amazon”,”apple”,”facebook”,”google”,”leetcode”], B = [“e”,”o”]<br>Output: [“facebook”,”google”,”leetcode”]<br><br>Example 5:<br>Input: A = [“amazon”,”apple”,”facebook”,”google”,”leetcode”], B = [“ec”,”oc”,”ceo”]<br>Output: [“facebook”,”leetcode”]<br><br>Note:<br>1 1 &lt;= A.length, B.length &lt;= 10000<br>2 1 &lt;= A[i].length, B[i].length &lt;= 10<br>3 A[i] and B[i] consist only of lowercase letters.<br>4 All words in A[i] are unique: there isn’t i != j with A[i] == A[j].<br><br>题目的意思就是说找出A中所有的word A[i]，它满足，B中每一个（所有）的word B[j]都是A[i]的子集。<br></div>  <p><strong>Intuition:</strong><br>B中所有的word都是<code>A[i]</code>的子集的话，整个B就满足，它里面所有<code>word</code>可以的整合成一个具有所有<code>character</code>以及每个<code>word</code>中<code>character</code>出现的频次的哈希表，这个频次只记录最高频次，比如<code>app</code>和<code>bp</code>，它们整合起来，就是<code>{a:1, b:1, p:2}</code>。  </p><p>这样我们就把B缩减为了一个哈希表，遍历A是在所难免的了。  </p><p>这道题很锻炼<code>collections.Counter()</code>的运用。  </p><pre><code class="py"><span class="function"><span class="keyword">def</span> <span class="title">wordSubsets</span><span class="params">(self, A, B)</span>:</span>    uni = collections.Counter()    <span class="keyword">for</span> b <span class="keyword">in</span> B:        <span class="keyword">for</span> c, n <span class="keyword">in</span> collections.Counter(b).items():            uni[c] = max(uni[c], n)    res = []    <span class="keyword">for</span> a <span class="keyword">in</span> A:        count = collections.Counter(a)        <span class="keyword">if</span> all(count[c] &gt;= uni[c] <span class="keyword">for</span> c <span class="keyword">in</span> uni):            res.append(a)    <span class="keyword">return</span> res</code></pre><hr><h3 id="Contest103"><a href="#Contest103" class="headerlink" title="Contest103"></a>Contest103</h3><h4 id="910-M"><a href="#910-M" class="headerlink" title="910-M"></a>910-M</h4><p><a href="https://leetcode.com/problems/smallest-range-ii/description/" target="_blank" rel="noopener">910. Smallest Range II</a>  </p><div><br>Given an array A of integers, for each integer A[i] we need to choose either x = -K or x = K, and add x to A[i] (only once).<br><br>After this process, we have some array B.<br><br>Return the smallest possible difference between the maximum value of B and the minimum value of B.<br><br>Example 1:<br>Input: A = [0,10], K = 2<br>Output: 6<br>Explanation: B = [2,8]<br><br>Example 2:<br>Input: A = [1,3,6], K = 3<br>Output: 3<br>Explanation: B = [4,6,3]<br><br>Note:<br>1 &lt;= A.length &lt;= 10000<br>0 &lt;= A[i] &lt;= 10000<br>0 &lt;= K &lt;= 10000<br></div>   <p><em>参考lee215的解释</em>  </p><p><strong>Intuition:</strong><br>For each integer A[i],<br>we may choose either x = -K or x = K.  </p><p>If we add K to all B[i], the result won’t change.  </p><p>It’s the same as:<br>For each integer A[i], we may choose either x = 0 or x = 2 * K.  </p><p><strong>Explanation:</strong><br>We sort the A first, and we choose to add x = 0 to all A[i].<br>Now we have <code>res = A[n - 1] - A[0]</code>.<br>Starting from the smallest of A, we add 2 * K to A[i],<br>hoping this process will reduce the difference.  </p><p>Update the new <code>mx = max(mx, A[i] + 2 * K)</code><br>Update the new <code>mn = min(A[i + 1], A[0] + 2 * K)</code><br>Update the <code>res = min(res, mx - mn)</code>  </p><p><strong>Time Complexity:</strong><br>O(NlogN), in both of the worst and the best cases.  </p><p><strong>Remark:</strong><br>理解他的<code>update</code>操作很有意思。我想找一个数，它加上<code>2*K</code>之后比原来最大的数要大（意味着题目中，这个数加上K比原来最大的数减去K要大，那么此时它就是最大的；如果它加之后还没有最大的数减去K大，那原来最大的数还是最大的）。</p><pre><code class="python"><span class="function"><span class="keyword">def</span> <span class="title">smallestRangeII</span><span class="params">(self, A, K)</span>:</span>   A.sort()   res = A[<span class="number">-1</span>] - A[<span class="number">0</span>]   <span class="keyword">for</span> i <span class="keyword">in</span> range(len(A) - <span class="number">1</span>):       big = max(A[<span class="number">-1</span>], A[i] + <span class="number">2</span> * K)       small = min(A[i + <span class="number">1</span>], A[<span class="number">0</span>] + <span class="number">2</span> * K)       res = min(res, big - small)   <span class="keyword">return</span> res</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Contests&quot;&gt;&lt;a href=&quot;#Contests&quot; class=&quot;headerlink&quot; title=&quot;Contests&quot;&gt;&lt;/a&gt;Contests&lt;/h2&gt;&lt;p&gt;From Contest103 to Contest 104 ~&lt;br&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://blog.x-fei.me/categories/Algorithm/"/>
    
    
      <category term="leetcode" scheme="http://blog.x-fei.me/tags/leetcode/"/>
    
      <category term="algorithm" scheme="http://blog.x-fei.me/tags/algorithm/"/>
    
      <category term="python" scheme="http://blog.x-fei.me/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>多项式拟合-线性回归(Python)</title>
    <link href="http://blog.x-fei.me/2018/09/24/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92-%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%8B%9F%E5%90%88/"/>
    <id>http://blog.x-fei.me/2018/09/24/线性回归-多项式拟合/</id>
    <published>2018-09-24T15:24:56.000Z</published>
    <updated>2018-10-11T16:53:52.492Z</updated>
    
    <content type="html"><![CDATA[<p><strong><center>Machine Learning Exercise 1</center></strong>  </p><h3 id="实验题目"><a href="#实验题目" class="headerlink" title="实验题目"></a>实验题目</h3><p>编写程序:模拟仿真多项式回归<br>参见 textbook p4-12(PRML)。完成以下任务:<br>1) 生成正弦序列 s(n);<br>2) 使用噪声函数对正弦序列加噪 x(n)=s(n)+w(n);<br>3) 使用多项式回归模型对 x(n)进行拟合，并分析过拟合和欠拟合情况  </p><p>注:参考误差函数式 1-2，带正则项的修正误差函数式 1-4，实验仿真生成图 1- 6、图 1-7，给出模型系数表。</p><a id="more"></a><h3 id="实验过程及代码"><a href="#实验过程及代码" class="headerlink" title="实验过程及代码"></a>实验过程及代码</h3><p>实验过程按照题目要求可以拆解为4步完成。首先进行数据采样，添加噪声；接着定义损失函数，<br>以及正则项；<br>之后采用梯度下降寻找局部最优解；再通过画图可视化实验结果。以下为具体描述：  </p><h4 id="数据生成"><a href="#数据生成" class="headerlink" title="数据生成"></a>数据生成</h4><p>利用<code>numpy</code>在<code>sin(2*pi*x)</code>的基础上生成点，并添加高斯噪声（其中均值设为0，方差设为0.3）。<br>为了方便后序的实验，我们在生成数据<code>x, y</code>的同时添加阶数，  每个<code>x</code>调整为形如<br><code>x = [1, x, x^2, ..., x^M]</code>的形式。最前面的1对应目标函数的b。  </p><p>数据生成代码如下：  </p><pre><code class="py"><span class="comment"># define gaussion noise function</span><span class="function"><span class="keyword">def</span> <span class="title">noise</span><span class="params">(mu=<span class="number">0</span>, sigma=<span class="number">0.3</span>)</span>:</span>    <span class="string">'''</span><span class="string">    dtype:</span><span class="string">        mu: default 0</span><span class="string">        sigma: default 0.3</span><span class="string">    rtype:</span><span class="string">        noise: float</span><span class="string">    '''</span>    <span class="keyword">return</span> np.random.normal(mu, sigma)<span class="function"><span class="keyword">def</span> <span class="title">genTargetWithNoise</span><span class="params">(x, noise=noise)</span>:</span>    <span class="string">''' target = sin(2*pi*x) + noise</span><span class="string">    dtype:</span><span class="string">        x: float</span><span class="string">        noise: noise function  </span><span class="string">    rtype:</span><span class="string">        t: float</span><span class="string">    '''</span><span class="comment">#     assert 0 &lt;= x &lt;= 1</span>    t = np.sin(<span class="number">2</span>*np.pi*x)    <span class="keyword">if</span> noise:        t += noise()    <span class="keyword">return</span> t<span class="function"><span class="keyword">def</span> <span class="title">regenX</span><span class="params">(random, poly_degree)</span>:</span>    xs = [[x ** i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, poly_degree+<span class="number">1</span>)] <span class="keyword">for</span> x <span class="keyword">in</span> random]    <span class="keyword">for</span> x <span class="keyword">in</span> xs:        x.insert(<span class="number">0</span>, <span class="number">1.</span>)    <span class="keyword">return</span> xs<span class="function"><span class="keyword">def</span> <span class="title">genData</span><span class="params">(numPoints, noise, poly_degree)</span>:</span>    <span class="string">'''Generate data.</span><span class="string">    '''</span>    <span class="comment"># random sample floats in the half-open interval [0.0, 1.0).</span>    random = np.random.random_sample((numPoints,))    <span class="comment"># generate targets for random</span>    targets = list(map(genTargetWithNoise, random))    <span class="comment"># remake data to ractangle form and add 1. to all x to correspond with b</span>    xs = regenX(random, poly_degree)    <span class="keyword">return</span> np.array(xs), np.array(targets)</code></pre><h4 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h4><p>这里我们按照《PRML》中式<code>1-2, 1-3</code>的定义，使用平方误差与均方误差。同时添加正则项。<br>如式<code>1-4</code>。  </p><div align="center"><br><img src="/images/LSE.png" width="60%" alt="LSE" style="text-align:center"><br></div><br><div align="center"><br><img src="/images/RMS.png" width="60%" alt="RMS"><br></div><br><div align="center"><br><img src="/images/loss_with_reg.png" width="60%" alt="loss_with_reg"><br></div>  <p>代码如下：  </p><pre><code class="py"><span class="comment"># define a polynomial</span><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(xs, theta)</span>:</span>    xs = np.asarray(xs)<span class="comment">#     print(xs.shape)</span>    <span class="keyword">if</span> xs.shape[<span class="number">0</span>] &gt; <span class="number">1</span>:        <span class="keyword">return</span> [x.T.dot(theta) <span class="keyword">for</span> x <span class="keyword">in</span> xs]    <span class="keyword">return</span> xs.T.dot(theta)<span class="comment"># define squares error</span><span class="function"><span class="keyword">def</span> <span class="title">LSE_loss</span><span class="params">(y_true, y_hat, theta, penalization=<span class="number">0.1</span>)</span>:</span>    y_true = np.asarray(y_true)    y_hat = np.asarray(y_hat)    <span class="comment"># set the regularizer  </span>    regularizer = (penalization / <span class="number">2</span>) * (np.dot(theta.T, theta))    <span class="keyword">return</span> (<span class="number">1</span>/<span class="number">2</span>) * np.square(y_hat - y_true).sum() + regularizer<span class="comment"># define mean squares error loss</span><span class="function"><span class="keyword">def</span> <span class="title">MSE_loss</span><span class="params">(y_true, y_hat, theta, penalization=<span class="number">0.1</span>)</span>:</span>    y_true = np.asarray(y_true)    y_hat = np.asarray(y_hat)    <span class="comment"># set the regularizer  </span>    regularizer = (penalization / <span class="number">2</span>) * (np.dot(theta.T, theta))    <span class="comment"># compute mse</span>    mse = np.sqrt(np.square(y_hat - y_true).sum()/len(y_hat)) + regularizer    <span class="keyword">return</span> mse</code></pre><h4 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h4><p>上面两步我们分别准备好了数据以及损失函数，这一步我们设置一些常用的参数，利用梯度下降法寻找<br>局部最优解。定义的多项式函数如下:  </p><div align="center"><br><img src="/images/def_func.png" width="60%" alt="Poly"><br></div>  <p>这里我们的<code>theta0</code>设置为1，由于我们在准备数据的时候已经处理好了输入<code>x</code>，因此我们<br>的<code>bias</code>项可以直接并入到<code>w</code>中，构成新的<code>theta</code>。</p><p>对参数theta求导:  </p><div align="center"><br><img src="/images/theta_grad.png" width="30%" alt="theta_grad"><br></div><br>更新theta:<br><div align="center"><br><img src="/images/theta_update.png" width="30%" alt="theta_update"><br></div>    <p>代码如下：  </p><pre><code class="py"><span class="comment"># gd</span><span class="function"><span class="keyword">def</span> <span class="title">gradientDescent</span><span class="params">(x, y, x_val, y_val, theta, lr, sample_num, numIterations, loss_name=<span class="string">'LSE'</span>, penalization=<span class="number">0</span>)</span>:</span>    xTrans = x.transpose()    record = []    freq = <span class="number">100</span> <span class="keyword">if</span> numIterations &lt; <span class="number">10000</span> <span class="keyword">else</span> <span class="number">1000</span>    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, numIterations+<span class="number">1</span>):        y_hat = f(x, theta)        <span class="keyword">if</span> loss_name == <span class="string">'LSE'</span>:            loss = LSE_loss(y, y_hat, theta, penalization)        <span class="keyword">elif</span> loss_name == <span class="string">'MSE'</span>:            loss = MSE_loss(y, y_hat, theta, penalization)        <span class="keyword">if</span> i % freq == <span class="number">0</span>:            print(<span class="string">"Iteration %d | %s loss: %f"</span> % (i, loss_name,  loss))            y_val_hat = f(x_val, theta)            <span class="keyword">if</span> loss_name == <span class="string">'LSE'</span>:                val_loss = LSE_loss(y_val, y_val_hat, theta)            <span class="keyword">elif</span> loss_name == <span class="string">'MSE'</span>:                val_loss = MSE_loss(y_val, y_val_hat, theta)            record.append([i, loss, val_loss])        <span class="comment"># avg gradient per example</span>        gradient = (x.T.dot(y_hat - y) / sample_num) + penalization*theta        <span class="comment"># update</span>        theta = theta - lr * gradient    <span class="keyword">return</span> theta, record</code></pre><h4 id="结果绘图"><a href="#结果绘图" class="headerlink" title="结果绘图"></a>结果绘图</h4><p>这一步我们通过在训练结果以及在训练中保存的结果分别绘制<code>train loss, val loss</code>对比图，<br>与拟合结果图。<br>代码如下：  </p><pre><code class="py"><span class="function"><span class="keyword">def</span> <span class="title">plotLoss</span><span class="params">(record)</span>:</span>    x = [it[<span class="number">0</span>] <span class="keyword">for</span> it <span class="keyword">in</span> record]    train_loss = [it[<span class="number">1</span>] <span class="keyword">for</span> it <span class="keyword">in</span> record]    val_loss = [it[<span class="number">2</span>] <span class="keyword">for</span> it <span class="keyword">in</span> record]    plt.figure(figsize=(<span class="number">8</span>, <span class="number">4</span>))    plt.plot(x, train_loss, label=<span class="string">'$train-loss$'</span>, color=<span class="string">'green'</span>, linewidth=<span class="number">0.5</span>)    plt.plot(x, val_loss, label=<span class="string">'$val-loss$'</span>, color=<span class="string">'red'</span>, linewidth=<span class="number">0.5</span>)    plt.plot(x, train_loss, <span class="string">'go'</span>, markerfacecolor=<span class="string">'none'</span>)    plt.plot(x, val_loss, <span class="string">'ro'</span>, markerfacecolor=<span class="string">'none'</span>)    plt.xlabel(<span class="string">'Iterations'</span>)    plt.ylabel(<span class="string">'Loss'</span>)    plt.title(<span class="string">'Train vs Val'</span>)    plt.legend()    plt.show()<span class="function"><span class="keyword">def</span> <span class="title">plotNow</span><span class="params">(x, y, target_func, cur_func, theta, poly_degree)</span>:</span>    xrange = np.arange(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0.01</span>)    targetfunc = target_func(<span class="number">2</span>*np.pi*xrange)    re_xrange = regenX(xrange, poly_degree)    curfunc = cur_func(re_xrange, theta)    plt.figure(figsize=(<span class="number">8</span>, <span class="number">4</span>))    plt.plot(xrange, targetfunc, label=<span class="string">'$sin(2πx)$'</span>, color=<span class="string">'green'</span>, linewidth=<span class="number">0.5</span>)    plt.plot(xrange, curfunc, label=<span class="string">'$Polynomial$'</span>, color=<span class="string">'red'</span>, linewidth=<span class="number">0.5</span>)    plt.xlabel(<span class="string">'x'</span>)    plt.ylabel(<span class="string">'y'</span>)    plt.title(<span class="string">'Polynomial'</span>)    <span class="comment"># plt.xlim(0,1)</span>    plt.ylim(<span class="number">-2</span>,<span class="number">2</span>)    plt.legend()    plt.plot(x, y, <span class="string">'bo'</span>, markerfacecolor=<span class="string">'none'</span>)    plt.show()</code></pre><p>效果图如下：  </p><div align="center"><br><img src="/images/1order2.png" width="50%" alt="example"><br></div>  <h3 id="实验结果及分析"><a href="#实验结果及分析" class="headerlink" title="实验结果及分析"></a>实验结果及分析</h3><p>实验中，我们分别对了3大组主要的对比实验，分别是：1）对同一阶数的模型用不同的参数作对比实<br>验；2）对不同阶数（模型复杂度）的模型作对比实验；3）对模型添加L2正则项。</p><h4 id="同模型-不同参数"><a href="#同模型-不同参数" class="headerlink" title="同模型-不同参数"></a>同模型-不同参数</h4><p>这里我们选取<code>M=4</code>的模型，4阶模型复杂度适中。  </p><h5 id="迭代次数学习率"><a href="#迭代次数学习率" class="headerlink" title="迭代次数学习率"></a>迭代次数学习率</h5><p>学习率保持不变。迭代次数过少，有可能没有达到局部（全局）最小点的时候终止，导致模型本身欠拟<br>合，需要增加迭代次数；迭代次数过多，模型可能对训练数据过拟合，在测试数据上的误差变大，泛化能力变差。<br>下面三图中，学习率设为0.1,迭代次数分别为1000，10000，20000。  </p><div style="float:left;border:solid 1px 000;margin:2px;"><img src="/images/o4i1000.png" width="350" height="400" alt="iter:1000"></div><div style="float:left;border:solid 1px 000;margin:2px;"><img src="/images/o4i10000.png" width="350" height="400" alt="iter:10000"></div><div align="center"><br><img src="/images/o4i20000.png" width="350px" alt="iter:10000"><br></div>    <p>迭代次数固定为10000，学习率分别设为0.1，0.01。观察到，迭代相同的次数时，<code>lr=0.1</code>时，测<br>试集上的误差要小一些。  </p><div style="float:left;border:solid 1px 000;margin:2px;"><img src="/images/o4i10000l1.png" width="350" height="400" alt="lr:0.1"></div><div style="float:left;border:solid 1px 000;margin:2px;"><img src="/images/o4i10000l2.png" width="350" height="400" alt="lr:0.01"></div><h5 id="不同评价指标"><a href="#不同评价指标" class="headerlink" title="不同评价指标"></a>不同评价指标</h5><p>保持其他条件一致，分别使用两种<code>Loss fucntion</code>做实验。  </p><div style="float:left;border:solid 1px 000;margin:2px;"><img src="/images/o4i3000LSE.png" width="350" height="400" alt="LSE"></div><div style="float:left;border:solid 1px 000;margin:2px;"><img src="/images/o4i3000MSE.png" width="350" height="400" alt="MSE"></div><p>对比发现，有时候单一的评价指标并不能反应模型的准确性能，换了MSE，过拟合了。  </p><h5 id="不同数据量"><a href="#不同数据量" class="headerlink" title="不同数据量"></a>不同数据量</h5><p>训练测试集数量分别采用<code>(50,50)，(100, 50)</code>。分别用50、100组输入作为训练，均用50组输入<br>作为测试。为了方便对比，我们都将其训练至过拟合。  </p><div style="float:left;border:solid 1px 000;margin:2px;"><img src="/images/o4i50000s50v50.png" width="340" height="400" alt="train:50 val:50"></div><div style="float:left;border:solid 1px 000;margin:2px;"><img src="/images/o4i50000s100v50.png" width="360" height="450" alt="train:100 val:50"></div>  <p>对比观察可知，当训练数据增多时，模型的泛化能力相应增强。 </p><h4 id="不同模型-同参数"><a href="#不同模型-同参数" class="headerlink" title="不同模型-同参数"></a>不同模型-同参数</h4><p>通过<code>4.1</code>的实验，我们将参数固定为:<br> <code>(训练, 测试) = (100, 50), learning_rate = 0.1, iterations=5000</code>。  </p><p>M=1, 2, 3  </p><div style="float:left;border:solid 1px 000;margin:2px;"><img src="/images/o1std.png" width="230" alt="M=1"></div><div style="float:left;border:solid 1px 000;margin:2px;"><img src="/images/o2std.png" width="230" alt="M=2"></div>  <div style="float:left;border:solid 1px 000;margin:2px;"><img src="/images/o3std.png" width="230" alt="M=3"></div>  <p>M=4, 5, 6  </p><div style="float:left;border:solid 1px 000;margin:2px;"><img src="/images/o4std.png" width="230" height="300" style="height: 230px !important;" alt="M=4"></div><div style="float:left;border:solid 1px 000;margin:2px;"><img src="/images/o5std.png" width="230" alt="M=5"></div>  <div style="float:left;border:solid 1px 000;margin:2px;"><img src="/images/o6std.png" width="230" alt="M=6"></div>  <p>M=7, 8, 9</p><div style="float:left;border:solid 1px 000;margin:2px;"><img src="/images/o7std.png" width="230" alt="M=7" style="height: 230px !important;"></div><div style="float:left;border:solid 1px 000;margin:2px;"><img src="/images/o8std.png" width="230" alt="M=8"></div>  <div style="float:left;border:solid 1px 000;margin:2px;"><img src="/images/o9std.png" width="230" alt="M=9"></div>  <p>这里我们没有训练到过拟合。观察输出的<code>Val loss</code>，当模型的复杂度上升的时候，模型的表达能力<br>相应提高，因此泛化能力变好，val loss呈现出下降的趋势。同时我发现<code>M=1</code>时，模型训练到2000<br>轮，就不再开始训练了，而更高阶的模型依然可以继续训练。  </p><p>一次实验中的模型系数表如下：  </p><div align="center"><br><img src="/images/params.png" alt="模型系数表"><br></div>   <h4 id="添加正则项-过拟合、欠拟合分析"><a href="#添加正则项-过拟合、欠拟合分析" class="headerlink" title="添加正则项(过拟合、欠拟合分析)"></a>添加正则项(过拟合、欠拟合分析)</h4><p>当我们的迭代次数设置少，或者学习率过低，或者模型过于简单的时候，都可能会出现欠拟合。比如只<br>迭代1000次，学习率设为0.0001，只用<code>M=1</code>的模型。</p><p>我们选取<code>M=4</code>的模型，先将其训练至过拟合。  </p><div align="center"><br><img src="/images/o9overfitting.png" width="50%" alt="过拟合"><br></div>  <p>设置lamda分别为<code>0.1, 0.25, 0.5, 1, 5</code>。  </p><div style="float:left;border:solid 1px 000;margin:2px;"><img src="/images/o9lambda0_1.png" width="340" height="400" alt="lambda=0.1"></div><div style="float:left;border:solid 1px 000;margin:2px;"><img src="/images/o9lambda0_25.png" width="360" height="450" alt="lambda=0.25"></div>  <div style="float:left;border:solid 1px 000;margin:2px;"><img src="/images/o9lambda0_5.png" width="340" height="400" alt="lambda=0.5"></div><div style="float:left;border:solid 1px 000;margin:2px;"><img src="/images/o9lambda1.png" width="360" height="450" alt="lambda=1"></div>  <p><div align="center"><br><img src="/images/o9lambda5.png" width="50%" alt="lambda=5"><br></div><br>观察可知，lambda越大，惩罚越大，模型泛化能力越好。</p><h3 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h3><p>通过本次实验，在概念上，对多项式拟合有了更加全面深入的理解，能正确分析过拟合、欠拟合的<br>情况，运用L2范数增加模型的鲁棒性；在实验呢实践上，给了一个以后做实验的参照物，学习了如<br>何做对比实验、参数如何调整，更熟悉代码实现。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;&lt;center&gt;Machine Learning Exercise 1&lt;/center&gt;&lt;/strong&gt;  &lt;/p&gt;
&lt;h3 id=&quot;实验题目&quot;&gt;&lt;a href=&quot;#实验题目&quot; class=&quot;headerlink&quot; title=&quot;实验题目&quot;&gt;&lt;/a&gt;实验题目&lt;/h3&gt;&lt;p&gt;编写程序:模拟仿真多项式回归&lt;br&gt;参见 textbook p4-12(PRML)。完成以下任务:&lt;br&gt;1) 生成正弦序列 s(n);&lt;br&gt;2) 使用噪声函数对正弦序列加噪 x(n)=s(n)+w(n);&lt;br&gt;3) 使用多项式回归模型对 x(n)进行拟合，并分析过拟合和欠拟合情况  &lt;/p&gt;
&lt;p&gt;注:参考误差函数式 1-2，带正则项的修正误差函数式 1-4，实验仿真生成图 1- 6、图 1-7，给出模型系数表。&lt;/p&gt;
    
    </summary>
    
      <category term="Machine Learning" scheme="http://blog.x-fei.me/categories/Machine-Learning/"/>
    
    
      <category term="Machine Learning" scheme="http://blog.x-fei.me/tags/Machine-Learning/"/>
    
      <category term="Code" scheme="http://blog.x-fei.me/tags/Code/"/>
    
      <category term="linear regression" scheme="http://blog.x-fei.me/tags/linear-regression/"/>
    
  </entry>
  
  <entry>
    <title>事故-SSL23_GET_SERVER_HELLO</title>
    <link href="http://blog.x-fei.me/2018/09/21/Git%E4%BA%8B%E6%95%85-SSL23-GET-SERVER-HELLO/"/>
    <id>http://blog.x-fei.me/2018/09/21/Git事故-SSL23-GET-SERVER-HELLO/</id>
    <published>2018-09-21T02:27:28.000Z</published>
    <updated>2018-10-11T16:58:29.556Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>fatal: unable to access ‘<a href="https://github.com/xxx/yyyy.git/" target="_blank" rel="noopener">https://github.com/xxx/yyyy.git/</a>‘: error:140770FC:SSL routines:SSL23_GET_SERVER_HELLO:unknown protocol  </p></blockquote><a id="more"></a><p>有点头疼，之前使用<code>hexo deploy</code>的时候出现过这个问题，我还以为是某次网络环境差导致本地和远程的版本不一致，但是发现当我把<code>_config.yml</code>中的deploy选项中repo的<code>https</code>换成<code>http</code>之后，又能重新导向了，事情比较多就没有深究。  </p><p>今天尝试<code>git push</code>的时候，又出现上面这个问题。应该Git或者它的配置出问题了。  </p><p>Solution:  </p><ul><li>因为<code>homebrew</code>要用到连接github但是连不上，所以先下载安装包升级<code>git</code>  </li><li>因为还保留这<code>http.sslversion=tlsv1.0</code>的设置，但是它已经被git给ban了，所以删掉它，网上有些解决方案要求指定：<code>git config --global http.sslVersion sslv3</code>    </li><li>之前某次觉得<code>git clone</code>下载慢，所以修改了<code>proxy</code>，有点鸡肋了，删。  </li></ul><p>花了我早上宝贵的一个多小时，fvck。<br>PS: 想起昨天发现如果目录超出默认目录的size，就会很影响美观，所以尝试给目录加上折叠功能，加是加上了，但是有个一点瑕疵让我感觉很不爽，坑先挖了，埋不埋以后再说。  </p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;fatal: unable to access ‘&lt;a href=&quot;https://github.com/xxx/yyyy.git/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/xxx/yyyy.git/&lt;/a&gt;‘: error:140770FC:SSL routines:SSL23_GET_SERVER_HELLO:unknown protocol  &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Geek" scheme="http://blog.x-fei.me/categories/Geek/"/>
    
    
      <category term="geek" scheme="http://blog.x-fei.me/tags/geek/"/>
    
      <category term="git" scheme="http://blog.x-fei.me/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>PyTorch Api Notes 📙</title>
    <link href="http://blog.x-fei.me/2018/09/13/PyTorch-Notes/"/>
    <id>http://blog.x-fei.me/2018/09/13/PyTorch-Notes/</id>
    <published>2018-09-12T17:14:38.000Z</published>
    <updated>2018-10-11T16:58:00.916Z</updated>
    
    <content type="html"><![CDATA[<p><center>Simple Api Notes ✍🏼 For Beginners！</center><br>记录并尝试解释一些常见的Api，并部分介绍它们的原理、实战运用。<br><a id="more"></a></p><h1 id="torch"><a href="#torch" class="headerlink" title="torch"></a>torch</h1><h2 id="Serialization"><a href="#Serialization" class="headerlink" title="Serialization"></a>Serialization</h2><h3 id="torch-save"><a href="#torch-save" class="headerlink" title="torch.save"></a>torch.save</h3><p><code>torch.save(obj, f, pickle_module=&lt;module ‘pickle’ from ‘/homes/alexandrov/.pyenv/versions/3.6.5/lib/python3.6/pickle.py’&gt;, pickle_protocol=2)</code> 存储对象到硬盘中。</p><h3 id="torch-load"><a href="#torch-load" class="headerlink" title="torch.load"></a>torch.load</h3><p><code>torch.load(f,map_location=None,pickle_module=&lt;module ‘pickle’ from ‘/homes/alexandrov/.pyenv/versions/3.6.5/lib/python3.6/pickle.py’&gt;)</code><br>从文件中加载由<code>torch.save()</code>方法存储的对象。<br>序列化存储调用。  </p><h3 id="transpose"><a href="#transpose" class="headerlink" title="transpose_"></a>transpose_</h3><p><code>transpose_(dim0, dim1) → Tensor</code><br>转置dim0和dim1。  </p><hr><h1 id="torch-autograd"><a href="#torch-autograd" class="headerlink" title="torch.autograd"></a>torch.autograd</h1><p><code>torch.autograd</code>提供了实现任意标量值函数自动区分的类和函数，它只需要对现有代码进行最小的更改：只需要在声明需要计算梯度的张量的时候，设置<code>requires_grad</code>关键字为<code>True</code>。  </p><h2 id="torch-Tensor"><a href="#torch-Tensor" class="headerlink" title="torch.Tensor"></a>torch.Tensor</h2><h3 id="backward"><a href="#backward" class="headerlink" title="backward"></a>backward</h3><p><code>backward(gradient=None, retain_graph=None, create_graph=False)</code><br>计算当前张量的梯度。  </p><hr><h1 id="torch-nn"><a href="#torch-nn" class="headerlink" title="torch.nn"></a>torch.nn</h1><h2 id="Containers"><a href="#Containers" class="headerlink" title="Containers"></a>Containers</h2><h3 id="torch-nn-Module"><a href="#torch-nn-Module" class="headerlink" title="torch.nn.Module"></a>torch.nn.Module</h3><p>所有网络模型的基类，即所有自定义的网络都要继承该类。<br><code>Modules</code>可以包含其他<code>Modules</code>， 允许嵌套成树形结构。<br>当我们调用<code>xxmodel.cuda()</code>的时候，模型的参数也会转化为<code>cuda Tensor</code>。  </p><h4 id="cuda"><a href="#cuda" class="headerlink" title="cuda"></a>cuda</h4><p><code>cuda(device=None)</code><br>这个方法帮助我们把所有的模型参数和<code>buffers</code>转移到GPU。<br>注意，这会使得参数和<code>buffers</code>变成不同的对象（<code>cuda Tensor</code>）。所以如果<br>优化时模型存在于GPU上时，本方法需要 <strong>在构造优化器之前被调用</strong>。  </p><p>与之对应的有个方法<code>cpu()</code>。  </p><h4 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h4><p><code>eval()</code><br>使模型处于<code>evaluation</code>模式。 对特定的模块(层)有效，比如<code>Dropout</code>,<code>BatchNorm</code>等，<br>在遇到更具体的模块的时候注意它们的文档。  </p><h4 id="train"><a href="#train" class="headerlink" title="train"></a>train</h4><p><code>train()</code><br>使模型处于<code>training</code>模式，同<code>eval()</code>方法，对特点模块有效。</p><h4 id="forward"><a href="#forward" class="headerlink" title="forward"></a>forward</h4><p><code>forward(*input)</code><br>定义每次调用时的计算过程。 <strong>所有的子类都需要覆盖这个方法</strong>。  </p><h4 id="to"><a href="#to" class="headerlink" title="to"></a>to</h4><p><code>to(*args, **kwargs)</code><br>移动或者映射所有的参数、<code>buffers</code>。  </p><p>可以这么调用:  </p><ul><li><code>to(device=None, dtype=None, non_blocking=False)</code>  </li><li><code>to(dtype, non_blocking=False)</code>  </li><li><code>to(tensor, non_blocking=False)</code>  </li></ul><p>这里的<code>dtype</code>是此模块中浮点参数和缓冲区的所需浮点类型.  </p><h4 id="modules"><a href="#modules" class="headerlink" title="modules"></a>modules</h4><p><code>modules()</code><br>返回可以迭代模型所有模块的迭代器(<code>yields</code>)。  </p><h4 id="load-state-dict"><a href="#load-state-dict" class="headerlink" title="load_state_dict"></a>load_state_dict</h4><p><code>load_state_dict(state_dict,strict=True)</code><br>从<code>state_dict</code>中拷贝参数和缓冲区。<br>如果<code>strict</code>为真，那么<code>state_dict</code>就必须和模型<code>state_dict()</code>方法返回的key完全匹配。<br>这个方法可以用来调用<code>pretrain</code>的model。  </p><h4 id="state-dict"><a href="#state-dict" class="headerlink" title="state_dict"></a>state_dict</h4><p><code>state_dict(destination=None,prefix=&#39;&#39;,keep_vars=False)</code><br>返回包含模块完整状态的词典。<br>所有的参数和缓冲区都被包含进去。key对应参数和缓冲区的名字。</p><h4 id="named-modules"><a href="#named-modules" class="headerlink" title="named_modules"></a>named_modules</h4><p><code>named_modules(memo=None,prefix=&#39;&#39;)</code><br>返回网络中所有模块的迭代器<code>yields</code>，同时包含模块的名称以及模块本身。  </p><hr><h3 id="torch-nn-ModuleList-modules-None"><a href="#torch-nn-ModuleList-modules-None" class="headerlink" title="torch.nn.ModuleList(modules=None)"></a>torch.nn.ModuleList(modules=None)</h3><p>在<code>list</code>中持有若干子模块。<br>可以像python自带的<code>list</code>一样，调用下标。但是它包含的模块均是正确注册<br>过的，可以通过调用<code>modules</code>方法可视化。 </p><h4 id="append"><a href="#append" class="headerlink" title="append"></a>append</h4><p><code>append(module)</code><br>添加一个。  </p><h4 id="extend"><a href="#extend" class="headerlink" title="extend"></a>extend</h4><p><code>extend(modules)</code><br>添加多个。  </p><hr><h3 id="torch-nn-Sequential-args"><a href="#torch-nn-Sequential-args" class="headerlink" title="torch.nn.Sequential(*args)"></a>torch.nn.Sequential(*args)</h3><p>一个队列容器，模块传递进构造器的顺序就是它们添加到模型的顺序，因此一个有序的模块字典<code>OrderedDict</code>也可以传入构造器中。  </p><hr><h2 id="Pooling-layers"><a href="#Pooling-layers" class="headerlink" title="Pooling layers"></a>Pooling layers</h2><h3 id="AdaptiveMaxPool2d"><a href="#AdaptiveMaxPool2d" class="headerlink" title="AdaptiveMaxPool2d"></a>AdaptiveMaxPool2d</h3><p><code>torch.nn.AdaptiveMaxPool2d(output_size,return_indices=False)</code><br>在由多个输入平面组成的输入信号上应用2D自适应最大池化。<br>对于任何输入尺寸，输出的大小为H x W. 输出特征的数量等于输入平面的数量。  </p><p>参数：  </p><ul><li><code>output_size</code>- 目标输出尺寸。可以是一个<code>tuple</code>，也可以是单个值（表示宽和高相同）。<br>除了<code>int</code>也可以是<code>None</code>，代表输出和输入尺寸相同。  </li><li><code>return_indices</code>- 默认<code>False</code>。如果是<code>True</code>，和输出一起返回切片。对<code>nn.MaxUnpool2d</code>有用。  </li></ul><hr><h2 id="Normalization-layers"><a href="#Normalization-layers" class="headerlink" title="Normalization layers"></a>Normalization layers</h2><h3 id="BatchNorm2d"><a href="#BatchNorm2d" class="headerlink" title="BatchNorm2d"></a>BatchNorm2d</h3><p><code>BatchNorm2d(num_features, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</code><br>未完。。  </p><hr><h2 id="Non-linear-activations"><a href="#Non-linear-activations" class="headerlink" title="Non-linear activations"></a>Non-linear activations</h2><h3 id="ReLU"><a href="#ReLU" class="headerlink" title="ReLU"></a>ReLU</h3><ul><li>Input: (N,∗) where * means, any number of additional dimensions</li><li>Output: (N,∗), same shape as the input  </li></ul><hr><h2 id="Dropout-layers"><a href="#Dropout-layers" class="headerlink" title="Dropout layers"></a>Dropout layers</h2><h3 id="Dropout"><a href="#Dropout" class="headerlink" title="Dropout"></a>Dropout</h3><p><code>torch.nn.Dropout(p=0.5, inplace=False)</code><br>在训练期间，使用来自伯努利分布的样本以概率p随机地将输入张量的一些元素归零。 在每个前向传播中随机化零个元素。<br>此外，输出按1/(1-p)的比例缩放.  </p><ul><li>p – probability of an element to be zeroed. Default: 0.5</li><li>inplace – If set to True, will do this operation in-place. Default: False</li></ul><hr><h1 id="torch-nn-functional"><a href="#torch-nn-functional" class="headerlink" title="torch.nn.functional"></a>torch.nn.functional</h1><h2 id="Convolution-functions"><a href="#Convolution-functions" class="headerlink" title="Convolution functions"></a>Convolution functions</h2><h3 id="conv2d"><a href="#conv2d" class="headerlink" title="conv2d"></a>conv2d</h3><p><code>conv2d(input, weight, bias=None, stride=1, padding=0, dilation=1, groups=1) → Tensor</code>  </p><ul><li>input – 输入张量的形状 (minibatch×in_channels×iH×iW)  </li><li>weight – filters of shape (out_channels × (in_channels/groups) × kH × kW)  </li><li>bias – optional bias tensor of shape (out_channels). Default: None  </li><li>stride – 卷积核的步长. 可以是一个数，也可以是一个tuple (sH, sW). 默认为1  </li><li>padding – 输入边缘的隐式零填充，可以是一个数或者一个tuple (padH, padW). 默认为0  </li><li>dilation – 内核元素之间的间距. 可以是一个数或者一个tuple (dH, dW). 默认为1  </li><li>groups – split input into groups, in_channels should be divisible by the number of groups. Default: 1</li></ul><h2 id="Pooling-functions"><a href="#Pooling-functions" class="headerlink" title="Pooling functions"></a>Pooling functions</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;center&gt;Simple Api Notes ✍🏼 For Beginners！&lt;/center&gt;&lt;br&gt;记录并尝试解释一些常见的Api，并部分介绍它们的原理、实战运用。&lt;br&gt;
    
    </summary>
    
      <category term="Machine Learning" scheme="http://blog.x-fei.me/categories/Machine-Learning/"/>
    
    
      <category term="PyTorch" scheme="http://blog.x-fei.me/tags/PyTorch/"/>
    
  </entry>
  
  <entry>
    <title>Lazy Tricks🙈</title>
    <link href="http://blog.x-fei.me/2018/08/26/Lazy-Tricks/"/>
    <id>http://blog.x-fei.me/2018/08/26/Lazy-Tricks/</id>
    <published>2018-08-26T05:43:31.000Z</published>
    <updated>2018-10-11T16:58:20.081Z</updated>
    
    <content type="html"><![CDATA[<p>🍻 高效率 <del>懒人</del> 养成Tricks！🍻<br><a id="more"></a><br>持续收集中～ 🛰  </p><p>抱歉，部分只提供建议，教程什么的，google不到算我输。</p><h2 id="工具-🔧"><a href="#工具-🔧" class="headerlink" title="工具 🔧"></a>工具 🔧</h2><h3 id="ubuntu-desktop-with-openssh-server"><a href="#ubuntu-desktop-with-openssh-server" class="headerlink" title="ubuntu desktop with openssh-server"></a>ubuntu desktop with openssh-server</h3><p>主力机还是自己的笔记本，实验室的 <del>laji</del> 主机怎么办？🐶<br>👇 👇 👇 👇<br>给你的Ubuntu桌面版主机安装<a href="https://help.ubuntu.com/lts/serverguide/openssh-server.html.en" target="_blank" rel="noopener"><code>openssh-server</code></a>，像访问服务器那样访问自己的主机吧！</p><h3 id="tmux"><a href="#tmux" class="headerlink" title="tmux"></a>tmux</h3><p>开启脚本的命令不能关！难道我的笔记本要一直放在实验室吗？🙊<br>怎么把命令挂在后台啊！太难了，学不会🙃<br><a href="https://hackernoon.com/a-gentle-introduction-to-tmux-8d784c404340" target="_blank" rel="noopener"><code>tmux</code></a>你值得拥有！不关机，不kill，关掉命令行都可以！<br>配合<a href="https://help.ubuntu.com/lts/serverguide/openssh-server.html.en" target="_blank" rel="noopener"><code>openssh-server</code></a>，主力机不动，ssh到ubuntu主机上，访问服务器，把脚本挂到tmux上。理论上可以随便玩。</p><h2 id="Tricks-🚲"><a href="#Tricks-🚲" class="headerlink" title="Tricks 🚲"></a>Tricks 🚲</h2><h3 id="shell脚本"><a href="#shell脚本" class="headerlink" title="shell脚本"></a>shell脚本</h3><p>训练CNNs的时候，最初的使用姿势可能是 <code>python cnn.py</code>。  </p><p>但是，要调整网络参数的时候怎么办，还需要到源码中找到然后一个一个修改吗？<strong>No!</strong>  </p><p><code>pytorch</code>里有<code>argparse</code>，<code>tf</code>有<code>FLAGS</code>，我可以这样 <code>python cnn.py -g 0 -param1 val1 -param2 val2 -param3 val3 -param4 val4 -param5 val5 -param6...</code>，  想接多少就。。。接多少！👀 👀 👀  </p><p>推荐写入到shell脚本中，可以顺序执行多个py文件，一个实验一个shell做到底，不用盯着显卡了。</p><p><img src="/images/shell-ml.png" width="50%" height="50%" title="Shell"></p><h3 id="log的生成"><a href="#log的生成" class="headerlink" title="log的生成"></a>log的生成</h3><p>log生成配合shell脚本使用。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh myscript.sh 2&gt;&amp;1 | tee logs/myscript.log</span><br></pre></td></tr></table></figure></p><p>原理：<br><img src="/images/output_redirect.png" alt="Output Redirect">  </p><hr><p><center><strong>持续收集中～ 🛰</strong></center>  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;🍻 高效率 &lt;del&gt;懒人&lt;/del&gt; 养成Tricks！🍻&lt;br&gt;
    
    </summary>
    
      <category term="Geek" scheme="http://blog.x-fei.me/categories/Geek/"/>
    
    
      <category term="geek" scheme="http://blog.x-fei.me/tags/geek/"/>
    
      <category term="trick" scheme="http://blog.x-fei.me/tags/trick/"/>
    
      <category term="tool" scheme="http://blog.x-fei.me/tags/tool/"/>
    
  </entry>
  
  <entry>
    <title>训练网络管理实验的科学探索💪🏼</title>
    <link href="http://blog.x-fei.me/2018/08/26/%E8%AE%AD%E7%BB%83%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86%E5%AE%9E%E9%AA%8C%E7%9A%84%E7%A7%91%E5%AD%A6%E6%8E%A2%E7%B4%A2/"/>
    <id>http://blog.x-fei.me/2018/08/26/训练网络管理实验的科学探索/</id>
    <published>2018-08-26T03:26:49.000Z</published>
    <updated>2018-10-11T16:56:37.700Z</updated>
    
    <content type="html"><![CDATA[<p>👏🏼 Some tips about how to manage your experiments！👏🏼  </p><blockquote><p>无论是打比赛还是写论文，我们都需要做大量的实验。有人说深度调参是“玄学”，为了有效探索这门玄学，需要对模型的结构、参数、结果做全面详尽的记录，对实验结果、模型参数进行合理保存。这里，分享一些我以及我的师兄教给我的在训练网络并科学管理实验方面的一些心得体会。✍🏼  </p></blockquote><a id="more"></a><h2 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h2><p>我们在实验过程中对数据集会遇到两种情况 👉🏻 一是实验需要尝试多个不同的数据集；二是对同一数据集作了不同的预处理操作从而产生了多个“不同”的数据集。为了避免后期总结或者做对比实验的时候找不到对应的数据集，需要我们对数据集进行记录，可以根据数据集的各项特征进⾏区分。这时我们就可以写一个<code>readme_dateset.txt</code>来记录对应特征的数据集文件夹。  </p><p><img src="/images/dataset.png" alt="datasets"><br><img src="/images/dataset_record.png" alt="readme"></p><h2 id="实验记录"><a href="#实验记录" class="headerlink" title="实验记录"></a>实验记录</h2><p>实验记录，一方面有助于自己了解模型在当前数据集、epoch、参数等条件下的性能，另一方面分析本条实验记录的结果可以帮助我们确定下一步的优化方向，最后在自己写report或者paper的时候，有丰富的图文数据支持。这里我们使用Excel表格来记录我们的实验。  </p><h3 id="基本实验记录"><a href="#基本实验记录" class="headerlink" title="基本实验记录"></a>基本实验记录</h3><p>针对单一实验，有很多实验的基本属性，比如序号id，数据集，网络，存储位置，参数，log文件，状态，结果分析等。<br>我们的列表的Head的整体框架基本上可以确定下来了，例如：</p><table><thead><tr><th>status</th><th>date</th><th>id</th><th>net</th><th>dataset</th><th>params</th><th>save_folder</th><th>analysis</th></tr></thead><tbody><tr><td>training</td><td>0901</td><td>a1</td><td>u-net</td><td>trainset</td><td>…</td><td>./Results/a1</td><td>300x400优于200x300</td></tr></tbody></table><h3 id="参数及其它"><a href="#参数及其它" class="headerlink" title="参数及其它"></a>参数及其它</h3><p>我们可以针对自己的需要，先确定一些可能需要修改、做对比实验的参数或者条件，比如不同预处理的数据集，图片的size等，之后可以添加更多的参数，对于已确定的参数可以放到靠后一点的列。同一实验，我们要对比某一参数的表现，最为直接的度量衡就是<code>Loss Function</code>，因此也要将其记录下来。有时，我们可能需要对网络的架构进行调整，这就不是参数了，需要我们用文字或者图片描述。    </p><h3 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h3><p>做文字记录的同时，需要对我们相关实验的数据进行整理保存。<br>训练完网络，产生了很多实验相关的output，我们的report取材都是来源于这些数据。这里注意两点：</p><ul><li><strong>单一实验保存</strong>：我们需要保存的文件可能有训练时产生的很多的checkpoint文件，网络权重，网络参数，日志，样例输出，对应的脚本等。根据自己的需求来保存。例如：  </li></ul><p><img src="/images/single_exp.png" alt="Single Exp">  </p><ul><li><strong>多个实验保存</strong>：注意命名的易读性、可辨别性以及规范性即可。   </li></ul><p><img src="/images/exps.png" alt="Exps"></p><h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><p>最后附一张我做Deeplabv3+的实验记录<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a> </sup>。   </p><p><img src="/images/deeplab_exp.png" alt="My Deeplabv3+ Exp"></p><h2 id="Tricks"><a href="#Tricks" class="headerlink" title="Tricks"></a>Tricks</h2><p>有几条用的上的tricks，包括：</p><ul><li>使用tmux；  </li><li>将需要调整的参数都写进命令行参数中，然后编写shell脚本  </li><li>输出并保存log<br>详情 👉🏻  <a href="/2018/08/26/Lazy-Tricks/" target="_blank">Lazy Tricks🙈</a></li></ul><div class="footnotes"><ol><br>    <li class="footnote" id="fn:1"><br>        <p>这时我第一次做实验的记录，有什么建议大家可以给我留言！欢迎👏 <a href="#fnref:1" title="Suggestions"> </a></p><p><br>    </p></li><br></ol></div> <script type="text/javascript">    $.bigfoot();</script><script type="text/javascript">    var bigfoot = $.bigfoot({        deleteOnUnhover: false,        preventPageScroll: false,        hoverDelay: 250,    });</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;👏🏼 Some tips about how to manage your experiments！👏🏼  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;无论是打比赛还是写论文，我们都需要做大量的实验。有人说深度调参是“玄学”，为了有效探索这门玄学，需要对模型的结构、参数、结果做全面详尽的记录，对实验结果、模型参数进行合理保存。这里，分享一些我以及我的师兄教给我的在训练网络并科学管理实验方面的一些心得体会。✍🏼  &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Geek" scheme="http://blog.x-fei.me/categories/Geek/"/>
    
    
      <category term="Machine Learning" scheme="http://blog.x-fei.me/tags/Machine-Learning/"/>
    
      <category term="trick" scheme="http://blog.x-fei.me/tags/trick/"/>
    
  </entry>
  
  <entry>
    <title>Summary: MICCAI 2018 Skin Lesion Contest</title>
    <link href="http://blog.x-fei.me/2018/08/26/Summary-MICCAI-2018-Skin-Lesion-Contest/"/>
    <id>http://blog.x-fei.me/2018/08/26/Summary-MICCAI-2018-Skin-Lesion-Contest/</id>
    <published>2018-08-25T17:31:37.000Z</published>
    <updated>2018-10-11T16:57:31.134Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Time：6.26-7.27<br>Location: SYSU<br>Contest: MICCAI 2018 SKIN Lesion Analysis Towards Melanoma Detection<br>Task: Lesion Segmentation<br>Rank: 29/66</p></blockquote><p>严格意义上我第一次打这种比赛。除了做白日梦，无用功，大概就只能搬搬砖了。有很多经验教训，只能说<code>too old, too naive</code>。下面从数据预处理，模型选择与实现，后处理，以及模型集成这几个方面总结一下这次比赛。  </p><a id="more"></a><h2 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h2><p>预处理需要分析训练集本身的特性，结合任务的特点。分割给了2594张图片作为训练集，尺寸差异很大。  </p><h3 id="Resize"><a href="#Resize" class="headerlink" title="Resize"></a>Resize</h3><p>由于GPU显存、CNNs以及本身scale不统一的问题，需要对数据做resize。 </p><p><em>Q1: resize到什么大小？</em><br><strong>A1</strong>: 一般300x400, 256x256, 512x512   </p><p><em>Q2: resize的时候需要保持比例吗？</em><br><strong>A2</strong>: 借鉴往年的经验，保持了大部分图片的宽高比为4:3。但是最后Top1的MT并没有保持比例，而是直接Resize，因此这一点存在争议，我觉得一组对比实验确定一下就可以了。</p><h3 id="Preprocessing"><a href="#Preprocessing" class="headerlink" title="Preprocessing"></a>Preprocessing</h3><p>对图像归一化;<br>尝试了使用或者添加<code>HSV</code>通道；(崔哥看H通道结果并不好，弃；最后MT添加了SV通道);<br>尝试了<code>Color Constancy</code> (没有提升);<br>尝试了<code>Gamma</code>校正，然并卵……  </p><h3 id="Augmentation"><a href="#Augmentation" class="headerlink" title="Augmentation"></a>Augmentation</h3><p>数据量偏少，需要做增强。这个比较实用，但是过于保守，应当考虑到皮肤病的病灶区域形状多变性，所以<code>Flip</code>,<code>Rotate</code>, <code>Zoom</code>可以都做一些，尺度也可以大一些。  </p><h3 id="Kth-folder-Cross-Validation"><a href="#Kth-folder-Cross-Validation" class="headerlink" title="Kth folder Cross Validation"></a>Kth folder Cross Validation</h3><p>多折交叉验证<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a> </sup>。 在<code>Local Validation Set</code>以及<code>Public Validation Set</code>上的性能并不能完全代表在<code>Private Validation Set</code>上的性能，所以做多折交叉验证一方面增强模型的鲁棒性，一方面相当于做了模型的集成。<br>这个时候需要我们去shuffle数据集，划分成5份。<br><em>Q3: 先做<code>augmentation</code>还是先划分数据集?</em><br><strong>A3</strong>: 先做<code>augmentation</code>。保证增强后的数据集足够大。  </p><p>我和崔哥两个人主要负责这个task，但是我俩数据预处理一开始就没有统一，无论是resize到什么尺寸还是normalization，间接导致我俩模型性能不能比较，这个问题还是相当严重的，不能及时发现某一网络的性能，从而快速调整，影响整体进度及结果。因此到最后一周多，统一了预处理但没有时间去做交叉验证了。模型的target function更接近<code>Public Validation Set</code>。</p><h2 id="模型选择与实现"><a href="#模型选择与实现" class="headerlink" title="模型选择与实现"></a>模型选择与实现</h2><p>比赛和平时科研的最大不同在于，比赛更看重模型最终的性能，而不是很在意其创新性。对于比赛而言，做baseline的最好方法就是选一个当前top的模型，不做别的动作，直接调整至输出一个不错的结果。  </p><h3 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h3><p>这个就需要依赖平时的积累了，读最新的顶会或者A类期刊的论文，关注新的高性能高表现的网络，这些模型都可以作为备选，以及一些模型中某一组件（tech），比如CRF，multi-scale，ASPP等，通过做实验去证明这些结构的有效性。  </p><h3 id="模型实现"><a href="#模型实现" class="headerlink" title="模型实现"></a>模型实现</h3><p>这就要讨论到用啥主流框架的问题了，我们都是<code>tf</code>的‘脑残粉’，因此一直可怜巴巴痛并快乐地debug。但是遇到改一些架构问题的时候，因为对<code>tf</code>的掌控有限，所以并不得心应手。被老板诟病过很多次，要么换<code>pytorch</code>，要么<code>keras</code>。  </p><h3 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h3><p>训练的时候，做好实验记录！<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a> </sup> 模型参数初始化，最好还是把训练好的网络的权重拿过来直接用。</p><p>打比赛，用<code>pytorch</code>或者<code>keras</code>能快速实现网络、我们的一些想法，把注意力集中到如何提升性能这一方面来，而不是某些技术细节。但是技术细节却是我们比较看重的长期的个人能力，因此之后估计也是走双修的路线吧。</p><h2 id="后处理Post-Processing"><a href="#后处理Post-Processing" class="headerlink" title="后处理Post_Processing"></a>后处理Post_Processing</h2><p>是否需要后处理取决于模型的结果，根据predict的结果，分析模型有哪些做的不够好的地方，是模型本身的缺陷还是数据的问题，为了最终的得分的话，都可以做后处理，去除一些共性的问题。  </p><p>比如Task1规定的，每个图片可能有不止一块lesion区域，但是label只标记了最中间、最主要的那一块。这就导致模型识别出了小块的lesion，但是label没有标记，反而会影响得分。因此我们后处理做了求最大连通区域，去洞操作。</p><h2 id="模型集成"><a href="#模型集成" class="headerlink" title="模型集成"></a>模型集成</h2><p>为了综合提升模型的性能，最终提交的结果需要对单个、多个模型做集成。  </p><h3 id="单模型集成"><a href="#单模型集成" class="headerlink" title="单模型集成"></a>单模型集成</h3><p>单模型的集成分为两大类。  </p><ul><li>多层特征融合：比如尝试改进U-Net的结构，将Encoder层的特征通过卷积再融合到Decoder的最后一层；或者采用简单的multi-scale，将输入数据调整为不同的scale，分别提取特征，最后做融合。  </li><li>网络快照集成法：利用了网络解空间中的局部最优解来对单个网络做模型集成。通过循环调整网络学习率可使网络依次收敛到不同的局部最优解处，取不同epoch处的模型进行融合。  </li></ul><p>但是这里我们做的不够好，比较合理的做法是将不同scale的特征融合到一起的，但是囿于自身技术，没能实现。</p><h3 id="多模型集成"><a href="#多模型集成" class="headerlink" title="多模型集成"></a>多模型集成</h3><p>多模型集成的方法相对较多，看方法名就可以知道大概做法了。需要注意的是，前面的个别单模型集成方法也可以运用到多模型当中，多模型的一些方法也可以看作是单模型的。  </p><h4 id="多模型生成策略"><a href="#多模型生成策略" class="headerlink" title="多模型生成策略"></a>多模型生成策略</h4><p>同一模型不同初始化；<br>同一模型不同训练轮数；<br>不同目标函数；<br>不同网络结构。  </p><h4 id="多模型集成方法"><a href="#多模型集成方法" class="headerlink" title="多模型集成方法"></a>多模型集成方法</h4><p>直接平均法；<br>加权平均法；<br>投票法；<br>留一法。  </p><p>在网络训练的过程中使用dropout也算是多模型集成的一种。  </p><p>实际操作中单模型，多模型集成相结合！  </p><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>我研究了3个星期的deeplabv3+，最后表现并不好，因此最后一周meeting的时候，这个model被kill掉了，最后熬了一夜只做了U-Net的各种集成。<br>虽然没有取得靠前的名次，但是收获了很多宝贵的经验。从如何打比赛到如何做实验、保存实验记录，以及总结了一套个人感觉比较完善的工作流程，一些Tips<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a> </sup>。</p><div class="footnotes"><ol><br>    <li class="footnote" id="fn:1"><br>        <p>这个在台大李宏毅老师的机器学习视频中有详细的介绍。 <a href="#fnref:1" title="Cross Validation"> </a></p><p><br>    </p></li><br>    <li class="footnote" id="fn:2"><br>        <p>实验整理请看👉🏻 <a href="/2018/08/26/训练网络管理实验的科学探索/" target="_blank">训练网络管理实验的科学探索💪🏼</a> <a href="#fnref:2" title="Cross Validation"> </a></p><p><br>    </p></li><br>     <li class="footnote" id="fn:3"><br>        <p>实验整理请看👉🏻 <a href="/2018/08/26/训练网络管理实验的科学探索/" target="_blank">训练网络管理实验的科学探索💪🏼</a> <a href="#fnref:3" title="Cross Validation"> </a></p><p><br>    </p></li><br></ol></div> <script type="text/javascript">    $.bigfoot();</script><script type="text/javascript">    var bigfoot = $.bigfoot({        deleteOnUnhover: false,        preventPageScroll: false,        hoverDelay: 250,    });</script>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Time：6.26-7.27&lt;br&gt;Location: SYSU&lt;br&gt;Contest: MICCAI 2018 SKIN Lesion Analysis Towards Melanoma Detection&lt;br&gt;Task: Lesion Segmentation&lt;br&gt;Rank: 29/66&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;严格意义上我第一次打这种比赛。除了做白日梦，无用功，大概就只能搬搬砖了。有很多经验教训，只能说&lt;code&gt;too old, too naive&lt;/code&gt;。下面从数据预处理，模型选择与实现，后处理，以及模型集成这几个方面总结一下这次比赛。  &lt;/p&gt;
    
    </summary>
    
      <category term="Think" scheme="http://blog.x-fei.me/categories/Think/"/>
    
    
      <category term="think" scheme="http://blog.x-fei.me/tags/think/"/>
    
      <category term="summary" scheme="http://blog.x-fei.me/tags/summary/"/>
    
  </entry>
  
  <entry>
    <title>Hackx上海</title>
    <link href="http://blog.x-fei.me/2017/11/06/Hackx%E4%B8%8A%E6%B5%B7/"/>
    <id>http://blog.x-fei.me/2017/11/06/Hackx上海/</id>
    <published>2017-11-06T03:49:33.000Z</published>
    <updated>2018-10-11T16:58:25.279Z</updated>
    
    <content type="html"><![CDATA[<h3 id="东方明珠"><a href="#东方明珠" class="headerlink" title="东方明珠"></a>东方明珠</h3><p><img src="/images/OrientalPearlTower.png" alt="The Oriental Pearl Tower">  </p><a id="more"></a><h3 id="HACKxFDU"><a href="#HACKxFDU" class="headerlink" title="HACKxFDU"></a>HACKxFDU</h3><p><img src="/images/HACKxFDU.png" alt="HACKxFDU"></p><blockquote><p>Idea很重要！做一个有力的C位很重要！  </p></blockquote><p>人和动物的根本区别是会不会制造和使用工具。<br>人是一支有思想的芦苇。  </p><p>周五NodeX四人乘高铁到了上海，在那里度过了一个值得吐槽的周末。<br>对我个人而言，有很多收获。  </p><h3 id="Idea"><a href="#Idea" class="headerlink" title="Idea"></a>Idea</h3><blockquote><p>人是一支有思想的芦苇。  </p></blockquote><p>这次去上海主要是参加 <em>2017 HACKx FDU</em> <sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a> </sup> 。主题是人工智能、金融科技、云服务和物联网。我们去的四个人，两个前端，我一个客户端，天天全可以。做应用不存在什么问题，但是AI算法是短板了，没有可以做的。但是这是黑客松啊，我理解的黑客松是 <em>现场idea</em> + <em>已有或现学的技术</em> ，所以周五就准备好鸽了，周末出去玩。  </p><p>还是想聊聊关键，A good idea！  </p><p>Without an idea, you are nothing at all.这话是有些夸张的，就是想突出idea的重要性。是的，没有好的Idea，一切都是扯淡。技术是优势，但不是全部！  </p><p>去现场的时候，认识了Luv Letter，然后后面两天看也稍微帮助他们做了一些事情。最开始的时候，他们有了想法，后面实施的时候，现学的nodejs写了后端。实际上，我们这边前后端写起来就是分分钟的事情。但是我们没有想法。<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a> </sup>  </p><p>所以想法啊，真的很重要。人是一支有思想的芦苇，没有idea就是一台掌握了具体技术的机器。  </p><p>那么如何，有一个异于常人的新颖的想法？我也要去寻找答案。  </p><h3 id="打好C位，单C难赢"><a href="#打好C位，单C难赢" class="headerlink" title="打好C位，单C难赢"></a>打好C位，单C难赢</h3><blockquote><p>看新闻才知道S7总决赛SKT输了，Faker哭了，ADC Bang要背锅。</p></blockquote><p>SKT打兔子队的时候，1:2落后拿出瑞兹稳住Carry；打RNG的时候，拿出加里奥疯狂支援。一人扛起了一支队。但是打SSG的时候，Carry不动了，Bang失误太多。  </p><p>之前看一个主播xiaoxin玩《绝地求生大逃杀》的时候，带了三个队友，很菜的那种，最后加上他们共两支队伍6个人。xiaoxin不小心对枪死了，但是知道了对方的位置，然后指挥三个队友打。队友连枪都没对上，全跪了。  </p><p>打游戏的时候是这样的，想赢，别坑，该自己做的做好，Carry起来，一个人很难带的动的。<br>游戏之外也是这样。为什么说的是强强联合，而不是强弱联合？因为绝大多数的弱者没有合作的资格。从强者的角度来说，自然也是希望自己的合作对象是旗鼓相当的强者。（当然，互补是另外的说法，这里的强弱比较视具体情况看）  </p><p>所以，做好自己的C位，不是总有人来带你飞。  </p><h3 id="大道朝天"><a href="#大道朝天" class="headerlink" title="大道朝天"></a>大道朝天</h3><p>除了没有写自己的项目之外，在现场听到IBM，上汽，图森，高盛的人员和复旦教授谈AI。收获还是蛮大的。  </p><blockquote><p>核心的竞争力还是算法。只有掌握了道的本质和精髓才能永远游刃有余。  </p></blockquote><p>所以，更加坚定而且有了足够的鸡汤陪我走下一程了。</p><div class="footnotes"><ol><br>    <li class="footnote" id="fn:1"><br>        <p>第二届复旦大学创客马拉松 <a href="#fnref:1" title="hackx FDU"> </a></p><p><br>    </p></li><br>    <li class="footnote" id="fn:2"><br>        <p>然后周五晚上鸽了之后去吃海底捞的路上，我吐槽说，你们这些都是BAT的败类 🙃。 <a href="#fnref:2" title="hackx FDU"> </a></p><p><br>    </p></li><br></ol></div> <script type="text/javascript">    $.bigfoot();</script><script type="text/javascript">    var bigfoot = $.bigfoot({        deleteOnUnhover: false,        preventPageScroll: false,        hoverDelay: 250,    });</script>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;东方明珠&quot;&gt;&lt;a href=&quot;#东方明珠&quot; class=&quot;headerlink&quot; title=&quot;东方明珠&quot;&gt;&lt;/a&gt;东方明珠&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/images/OrientalPearlTower.png&quot; alt=&quot;The Oriental Pearl Tower&quot;&gt;  &lt;/p&gt;
    
    </summary>
    
      <category term="Geek" scheme="http://blog.x-fei.me/categories/Geek/"/>
    
    
      <category term="geek" scheme="http://blog.x-fei.me/tags/geek/"/>
    
      <category term="出行" scheme="http://blog.x-fei.me/tags/%E5%87%BA%E8%A1%8C/"/>
    
      <category term="HACKx" scheme="http://blog.x-fei.me/tags/HACKx/"/>
    
  </entry>
  
  <entry>
    <title>技术分为术和道两种</title>
    <link href="http://blog.x-fei.me/2017/10/01/%E6%8A%80%E6%9C%AF%E5%88%86%E4%B8%BA%E6%9C%AF%E5%92%8C%E9%81%93%E4%B8%A4%E7%A7%8D/"/>
    <id>http://blog.x-fei.me/2017/10/01/技术分为术和道两种/</id>
    <published>2017-10-01T07:07:21.000Z</published>
    <updated>2018-10-11T16:56:52.838Z</updated>
    
    <content type="html"><![CDATA[<p>2017年9月回顾。<br><a id="more"></a></p><blockquote><p>技术分为术和道两种，具体的做事方法是术，做事的原理和原则是道。术会从独门绝技到普及再到落伍，追求术的人会很辛苦，只有掌握了道的本质和精髓才能永远游刃有余。 ​</p></blockquote><p>上面这句话引用自吴军先生的《数学之美》。思索了很久，然后17年整个9月就在二者之间作出了我目前认为的最合适的决定。  </p><h3 id="方向"><a href="#方向" class="headerlink" title="方向"></a>方向</h3><p>7月25号，拖了很久的一个项目写完了。然后准备秋招。还是想做移动应用开发。而对于Android而言，虽然Java算比较熟悉的了，但是看了一下面经，要看的书太多了，而且入门门槛低，现在基本饱和了吧。正式转iOS开发。  </p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>一周看了两本书，OC以及iOS编程，但是没有真机，只能在模拟器上运行。<br>8月开始，花了7-10天吧，实践加学习Swift3。<br>13号去上海，学校安排的实习。期间又写了一段时间的Java，感觉很浪费时间。所以这段时间算是一直咸鱼了，想做的事没有做好的，就断断续续地刷剑指Offer，然后完美错过阿里秋招！！！！！<br>就很迷，不知道去哪里找这些公司的校招信息，后面才了解到牛客网有一个专门的板块做这个的。<br>8月30号回长沙，开始读《Effective Objective-C》和《Objective-C 高级编程》，继续刷《剑指Offer》。<br>月末的时候写了自己的简历。</p><h3 id="笔试"><a href="#笔试" class="headerlink" title="笔试"></a>笔试</h3><p>从9月8号开始，一直笔试到14号，每天在1到2场之间。重点关注的是京东、新美大、网易、头条以及腾讯。其余的公司全当练手。笔试过程中三点不爽。一是网络和操作系统我看的太少了，准备太不充分，而且一开始看书实在是太慢了，应该看快一点，多看几遍。二是我投递的iOS岗，不得不去答一堆C++的题目，然后就被虐的很惨。三是编程，弱鸡还是弱鸡。不过还好，基本2题的话，1.5A，3题有2A。  </p><h3 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h3><p>网申的速度都比较慢。第一家面试的公司（富途证券），算是腾讯系的公司，技术团队挺好的。前一天晚上参加完线下笔试，第二天就去面试了。一上午两轮技术+HR面结束。感觉很糟糕，毕竟第一次面。然而就是这家公司，在后来给我发了offer。<br>面试的第二家公司，百度。。。。没错，就是百度了，霸面的。前文提到过，这里就不说了。<br>趋势科技面试。由于不太了解，而且说好的视频面试，面试官自己的摄像头一片黑。就很尴尬，然后面了一面就结束了。<br>面试的第四家公司，今日头条。头条给我面试邀请的邮件还是意料之外的，因为头条的笔试题我记得我做的一般，花了比较多的功夫在拓展题上，然后编程题就sb了。面了两轮技术面，面试官都是比较年轻的帅小哥，二面感觉不太好吧，提到很多我没来得及深入研究的东西。所以我只能说一点半点。然后我问了头条现在是用什么来写的，还是OC，还是Swift，还是混编。最重要的一点没有问，什么时候给回复。所以二面结束，他说让我等HR通知。等到现在，估计没戏了。<br>最后27号，网易面试，但是我后面由于时间和票的原因，通知校招组，我放弃了面试，官网的招聘状态也变成了灰色的放弃面试状态。  </p><p>我本科的面试之旅大概就到这里了。当然后面腾讯来长沙的话，通知面试的话去面一下，笔试没过就去霸面～</p><h3 id="推免"><a href="#推免" class="headerlink" title="推免"></a>推免</h3><p>面试头条的时候，莫名其妙有了推免资格（中间发生了一些“有趣”的故事），但是还处于可以放弃的阶段，这时候还没有Offer，比较着急，就没有放弃推免的名额。然后先投了中山和哈工大深研院。后面想了很多，做技术，做学术，赚钱，女朋友。。。等等等等，然后我就文章开头的话做了一番思想斗争后，决定为了更多的💰，去读研。  </p><h3 id="中山"><a href="#中山" class="headerlink" title="中山"></a>中山</h3><p>之后去了中山参加复试，联系了导师，然后基本上就定下来了。但是报名比较晚了，复试成绩也一般，只有专硕了。学费贵，奖学金少。  </p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>这个月，一开始路越走越窄，后面路越走越宽。但是，即使路宽了，还是只能选一条。选一条，否定了别的路，感觉就否定了别的自己。就很难受，很失落。但是长远来看，本科毕业，工作强度高，拿到的年薪一般（除了头条），两年后的成长空间，一般而言，大概涨不到50%，遇到瓶颈可能早一点。花两年，做一笔投资，学历+高起薪，发展前景还是可观的。其实所有的发展都是看个人能力的，能力到了，瓶颈便不复存在。能力不够，投资再多也是有去无回。所以，大四&amp;后两年。过上高三的生活吧！既然否定了其他的自己，决定走这条路，那就全力以赴，奔跑下去～  </p><p><strong>Flag：三年后不后悔。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2017年9月回顾。&lt;br&gt;
    
    </summary>
    
      <category term="Think" scheme="http://blog.x-fei.me/categories/Think/"/>
    
    
      <category term="思考" scheme="http://blog.x-fei.me/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
</feed>
