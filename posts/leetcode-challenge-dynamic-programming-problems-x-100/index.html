<!DOCTYPE html>
<html >
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<meta name="author" content="XFeiF">
		<meta name="description" content="XFeiF的独立博客">
		<meta name="generator" content="Hugo 0.69.2" />
		<title>LeetCode Challenge 🏆 Dynamic Programming Problems X 100 ⚡️ &middot; </title>
		<link rel="shortcut icon" href="https://blog.x-fei.me/images/favicon.ico">
		<link rel="stylesheet" href="https://blog.x-fei.me/css/style.css">
		
		
		
		

		

		
		<link href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">

<link href="https://cdn.staticfile.org/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<script src="https://cdn.staticfile.org/highlight.js/9.12.0/highlight.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>
<script type="text/javascript" async src="https://cdn.staticfile.org/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [
                ['$', '$'],
                ['\\(', '\\)']
            ],
            displayMath: [
                ['$$', '$$'],
                ['\[\[', '\]\]']
            ],
            processEscapes: true,
            processEnvironments: true,
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            TeX: {
                equationNumbers: {
                    autoNumber: "AMS"
                },
                extensions: ["AMSmath.js", "AMSsymbols.js"]
            }
        }
    });

    MathJax.Hub.Queue(function() {
        
        
        
        var all = MathJax.Hub.getAllJax(),
            i;
        for (i = 0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
    MathJax.Hub.Config({
        CommonHTML: {
            linebreaks: {
                automatic: true
            }
        },
        "HTML-CSS": {
            linebreaks: {
                automatic: true
            }
        },
        SVG: {
            linebreaks: {
                automatic: true
            }
        }
    });
</script>

<style>
    code.has-jax {
        font: inherit;
        font-size: 100%;
        background: inherit;
        border: inherit;
        color: #515151;
    }
</style>


<script src="https://cdn.staticfile.org/jquery/1.8.3/jquery.js"></script>
<script src="https://cdn.staticfile.org/jquery.imagesloaded/2.1.0/jquery.imagesloaded.js"></script>
<script src="https://cdn.staticfile.org/masonry/4.2.2/masonry.pkgd.min.js"></script>
<script src="https://cdn.staticfile.org/bigfoot/2.1.4/bigfoot.min.js"></script>
<link href="https://cdn.staticfile.org/bigfoot/2.1.4/bigfoot-default.min.css" rel="stylesheet">
	</head>


<body>
    <div class="nav-header nav-header-fixed animated">
    <a href="https://blog.x-fei.me/" class="left swing">
        <img src="https://blog.x-fei.me/images/Feiaaa.png" alt="" class="icon rounded">
    </a>
</div>

 
<header id="header" class="blog-background banner-mask lazy no-cover" style="display: table; background-image: url(https://raw.githubusercontent.com/XFeiF/Photos/master/blog/reward.jpg);">
    <div class="header-wrap site-nav">
    <div class="home-info-container">
        <a href="https://blog.x-fei.me/">
            <h2>Do not go gentle into that good night</h2>
        </a>
    </div>
    <div class="nav-header-container">
        <ul class="links">
            <li class="nav-blog">
                <a href='https://blog.x-fei.me/'> Home</a>
            </li>
            <li>
                <a href='https://blog.x-fei.me/archives'>Archives</a>
            </li>
            <li>
                <a href='https://blog.x-fei.me/timelines'>Timelines</a>
            </li>
            <li>
                <a href='https://blog.x-fei.me/friends'>Friends</a>
            </li>
            <li>
                <a href='https://blog.x-fei.me/about'>About</a>
            </li>
        </ul>


    	

    	
    </div>
</div>

</header>
 
    <div id="main">
        <article class="page-template page-index container-wrapper">
            <div class="post-card">
                <div class="post-container">
                    <div class="post-header">
                        <div class="meta">
                            <h1 id="post-title">LeetCode Challenge 🏆 Dynamic Programming Problems X 100 ⚡️</h1>
                            
                            
                                <time datetime="2018-12-27">Dec 27, 2018</time>
                            
                            <span class="categories">
                                 on 
    
        <a class="badge badge-primary" href="/categories/algorithm">Algorithm</a>
    


                            </span> - 21 min read.

                        </div>
                    </div>
                    <div class="post-content">
                        <div id="toc" class="">

                        </div>
                        <div class="inner-content">
                            <h1 id="failure">Failure</h1>

<p><center> LeetCode Challenge 🏆 </center>
&gt; 挑战目标🎖: 100道DP题<br />
 <span>&nbsp;&nbsp;&nbsp;</span>时间<span>&nbsp;&nbsp;&nbsp;&nbsp;</span>🗓: <span>&nbsp;</span><del><sup>25</sup>&frasl;<sub>70</sub> （2018-09-13 👉🏻 2018-11-15）</del><br />
 <span>&nbsp;&nbsp;&nbsp;</span>进度<span>&nbsp;&nbsp;&nbsp;&nbsp;</span>🛴: <span>&nbsp;</span><sup>41</sup>&frasl;<sub>100</sub><br />
 成功奖励🍭: ██████████</p>

<p>Solved: 🥈🥈🥈🥈🥉
Log:<br />
18-09-28: 取消每次记录天吧，只记录每周刷了多少道题，感觉时间分配不足了。<br />
18-09-30: 决定50道题之后开个part2的记录，不然篇幅太长了，虽然已经很长了。
18-10-01～18-12-17: Pause</p>

<hr />

<h2 id="week4">Week4:</h2>

<h3 id="solved-7-problems">Solved 7 problems</h3>

<h4 id="309-m">309-M</h4>

<p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/">309. Best Time to Buy and Sell Stock with Cooldown</a><br />
Difficulty: ★★★★☆<br />
Beats: %<br />
Time Complexity: O($n$)</p>

<p>Code:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">maxProfit</span>(self, prices):
    <span style="color:#66d9ef">if</span> len(prices) <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">2</span>: <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>
    sell, buy, prev_sell, prev_buy <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, <span style="color:#f92672">-</span>prices[<span style="color:#ae81ff">0</span>], <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>
    <span style="color:#66d9ef">for</span> price <span style="color:#f92672">in</span> prices:
        prev_buy <span style="color:#f92672">=</span> buy
        buy <span style="color:#f92672">=</span> max(prev_sell <span style="color:#f92672">-</span> price, prev_buy)
        prev_sell <span style="color:#f92672">=</span> sell
        sell <span style="color:#f92672">=</span> max(prev_buy <span style="color:#f92672">+</span> price, prev_sell)
    <span style="color:#66d9ef">return</span> sell</code></pre></div>
<h4 id="764-m">764-M</h4>

<p><a href="https://leetcode.com/problems/largest-plus-sign/">764. Largest Plus Sign</a><br />
Difficulty: ★★★☆☆<br />
Beats: 22.64%<br />
Time Complexity: O($n^2$)</p>

<p>Code:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">orderOfLargestPlusSign</span>(self, N, mines):
    matrix <span style="color:#f92672">=</span> [[<span style="color:#ae81ff">1</span>]<span style="color:#f92672">*</span>N <span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> range(N)]
    dp <span style="color:#f92672">=</span> [[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> (N<span style="color:#f92672">+</span><span style="color:#ae81ff">2</span>) <span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> range(N<span style="color:#f92672">+</span><span style="color:#ae81ff">2</span>)]
    up <span style="color:#f92672">=</span> [[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> (N<span style="color:#f92672">+</span><span style="color:#ae81ff">2</span>) <span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> range(N<span style="color:#f92672">+</span><span style="color:#ae81ff">2</span>)]
    down <span style="color:#f92672">=</span> [[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> (N<span style="color:#f92672">+</span><span style="color:#ae81ff">2</span>) <span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> range(N<span style="color:#f92672">+</span><span style="color:#ae81ff">2</span>)]
    left <span style="color:#f92672">=</span> [[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> (N<span style="color:#f92672">+</span><span style="color:#ae81ff">2</span>) <span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> range(N<span style="color:#f92672">+</span><span style="color:#ae81ff">2</span>)]
    right <span style="color:#f92672">=</span> [[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> (N<span style="color:#f92672">+</span><span style="color:#ae81ff">2</span>) <span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> range(N<span style="color:#f92672">+</span><span style="color:#ae81ff">2</span>)]
    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, N<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>):
        <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, N<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>):
            dp[i][j] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
    <span style="color:#66d9ef">for</span> mine <span style="color:#f92672">in</span> mines:
        x, y <span style="color:#f92672">=</span> mine
        matrix[x][y] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
        dp[x<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>][y<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>

    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, N<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>):
        <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, N<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>):
            <span style="color:#66d9ef">if</span> matrix[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]:
                up[i][j] <span style="color:#f92672">=</span> up[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][j] <span style="color:#f92672">+</span> matrix[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
                left[i][j] <span style="color:#f92672">=</span> left[i][j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> matrix[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
            <span style="color:#66d9ef">if</span> matrix[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][N<span style="color:#f92672">-</span>j]:
                right[i][N<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span><span style="color:#f92672">-</span>j] <span style="color:#f92672">=</span> right[i][N<span style="color:#f92672">+</span><span style="color:#ae81ff">2</span><span style="color:#f92672">-</span>j] <span style="color:#f92672">+</span> matrix[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][N<span style="color:#f92672">-</span>j]
            <span style="color:#66d9ef">if</span> matrix[N<span style="color:#f92672">-</span>i][j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]:
                down[N<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span><span style="color:#f92672">-</span>i][j] <span style="color:#f92672">=</span> down[N<span style="color:#f92672">+</span><span style="color:#ae81ff">2</span><span style="color:#f92672">-</span>i][j] <span style="color:#f92672">+</span> matrix[N<span style="color:#f92672">-</span>i][j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
    res <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
    <span style="color:#66d9ef">for</span> row <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, N<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>):
        <span style="color:#66d9ef">for</span> col <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, N<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>):
            <span style="color:#66d9ef">if</span> matrix[row<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][col<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>:
                dp[row][col] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
            <span style="color:#66d9ef">else</span>:
                dp[row][col] <span style="color:#f92672">=</span> min(up[row<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][col], down[row<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>][col], left[row][col<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>], right[row][col<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>]) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
            res <span style="color:#f92672">=</span> max(res, dp[row][col])
    <span style="color:#66d9ef">return</span> res</code></pre></div>
<h4 id="740-m">740-M</h4>

<p><a href="https://leetcode.com/problems/delete-and-earn/">740. Delete and Earn</a><br />
Difficulty: ★★★☆☆<br />
Beats: 40.95%<br />
Time Complexity: O($n$)</p>

<p>Code:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">deleteAndEarn</span>(self, nums):
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> nums: <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>
    counter <span style="color:#f92672">=</span> collections<span style="color:#f92672">.</span>defaultdict(int)
    vis <span style="color:#f92672">=</span> collections<span style="color:#f92672">.</span>defaultdict(int)
    <span style="color:#66d9ef">for</span> num <span style="color:#f92672">in</span> nums:
        counter[num] <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
        vis[num] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
    nums <span style="color:#f92672">=</span> sorted(list(set(nums)))
    <span style="color:#66d9ef">if</span> len(nums) <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>: <span style="color:#66d9ef">return</span> nums[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">*</span>counter[nums[<span style="color:#ae81ff">0</span>]]

    dp <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span>]<span style="color:#f92672">*</span>len(nums)

    dp[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> counter[nums[<span style="color:#ae81ff">0</span>]]<span style="color:#f92672">*</span>nums[<span style="color:#ae81ff">0</span>]
    <span style="color:#66d9ef">if</span> nums[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">!=</span> nums[<span style="color:#ae81ff">0</span>]:
        dp[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> dp[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">+</span> counter[nums[<span style="color:#ae81ff">1</span>]]<span style="color:#f92672">*</span>nums[<span style="color:#ae81ff">1</span>]
    <span style="color:#66d9ef">else</span>:
        dp[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> max(dp[<span style="color:#ae81ff">0</span>], counter[nums[<span style="color:#ae81ff">1</span>]]<span style="color:#f92672">*</span>nums[<span style="color:#ae81ff">1</span>])
    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">2</span>, len(nums)):
        cur <span style="color:#f92672">=</span> nums[i]<span style="color:#f92672">*</span>counter[nums[i]]
        <span style="color:#66d9ef">if</span> nums[i]<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">!=</span> nums[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]:
            dp[i] <span style="color:#f92672">=</span> dp[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> cur
        <span style="color:#66d9ef">else</span>:
            dp[i] <span style="color:#f92672">=</span> max(dp[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>], dp[i<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>] <span style="color:#f92672">+</span> cur)
    <span style="color:#66d9ef">return</span> max(dp)</code></pre></div>
<h4 id="377-m">377-M</h4>

<p><a href="https://leetcode.com/problems/combination-sum-iv/">377. Combination Sum IV</a>
Difficulty: ★★★☆☆<br />
Beats: 16.16%<br />
Time Complexity: O($n^2$)</p>

<p>Code:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">combinationSum4</span>(self, nums, target):
    nums <span style="color:#f92672">=</span> sorted([num <span style="color:#66d9ef">for</span> num <span style="color:#f92672">in</span> nums <span style="color:#66d9ef">if</span> num <span style="color:#f92672">&lt;=</span> target])
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> nums: <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>
    res <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> (target<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)
    res[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(nums[<span style="color:#ae81ff">0</span>], target<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>):
        smaller <span style="color:#f92672">=</span> list(num <span style="color:#66d9ef">for</span> num <span style="color:#f92672">in</span> nums <span style="color:#66d9ef">if</span> num <span style="color:#f92672">&lt;=</span> i)
        <span style="color:#66d9ef">for</span> num <span style="color:#f92672">in</span> smaller:
            res[i] <span style="color:#f92672">+=</span> res[i<span style="color:#f92672">-</span>num]
    <span style="color:#66d9ef">return</span> res[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]</code></pre></div>
<h4 id="962-m">962-M</h4>

<p><a href="https://leetcode.com/problems/maximum-width-ramp/">962. Maximum Width Ramp</a><br />
Difficulty: ★★★☆☆</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">maxWidthRamp</span>(self, A):
    n <span style="color:#f92672">=</span> len(A)
    res <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> n
    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, n):
        <span style="color:#75715e"># if A[i] &gt;= A[i-1] and res[i-1] != 0:</span>
        <span style="color:#75715e">#     res[i] = res[i-1] + 1</span>
        <span style="color:#75715e"># else:</span>
        <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">0</span>, i):
            <span style="color:#66d9ef">if</span> A[i] <span style="color:#f92672">&gt;=</span> A[j]:
                res[i] <span style="color:#f92672">=</span> i <span style="color:#f92672">-</span> j
                <span style="color:#66d9ef">break</span>
    <span style="color:#66d9ef">return</span> max(res)</code></pre></div>
<h4 id="486-m">486-M</h4>

<p><a href="https://leetcode.com/problems/predict-the-winner/">486. Predict the Winner</a><br />
Difficulty: ★★★★★<br />
Explanation: <a href="https://leetcode.com/problems/predict-the-winner/solution/">Solution</a><br />
Remark: 有的时候就会陷入某一步定住，不知道怎么继续下去。想到分别计算Player1和Player2的最大和关系，sum1 &gt; sum2，却想不到深层或者说再底层的关系，怎么解？(其实还是要回归到DP问题，分析最优子结构、状态、状态转移)</p>

<p>Approach #4:<br />
最优子结构性质：<br />
我们可以观察到，给定子数组<code>nums[x:y]</code>，对当前玩家而言的有效得分只依赖<code>nums</code>整个数组中<code>[x,y]</code>范围内的元素。<br />
就看当前玩家本轮取的是<code>nums[x]</code>还是<code>nums[y]</code>，以及取完后另一个玩家用剩余元素可能达到的最高分数。<br />
因此，当前有效得分不受<code>[x,y]</code>之外的元素影响。</p>

<p>假设我们已知<code>nums[x+1: y]</code> 和 <code>nums[x:y-1]</code>的最大有效得分情况，那么我们就可以轻松得到<code>nums[x:y]</code>的有效的最高得分情况 <code>max(nums[x] - score[x+1][y], nums[y] - score[x][y-1]</code>。</p>

<p>因此得到状态方程:<br />
<code>dp[i, j] = nums[i] - dp[i+1][j], nums[j] - dp[i][j-1]</code>。</p>

<h4 id="931-m">931-M</h4>

<p><a href="https://leetcode.com/problems/minimum-falling-path-sum/">931. Minimum Falling Path Sum</a><br />
Difficulty: ★★★☆☆<br />
Beats: 45.24%<br />
Time Complexity: O($n^2$)
Remark: 最小问题，容易发现状态方程，需要注意边界条件的处理。</p>

<p>Explanation:<br />
这里定义状态为从顶层落到第<code>i</code>层，第<code>j</code>个元素位置处的最小和。<br />
那么对于第<code>i+1</code>层非边界元素位置，其最小值取决于上一层的相邻三个元素<code>i-1</code>,<code>i</code>,<code>i+1</code>的最小值；边界元素只考虑两个相邻元素。<br />
容易得到我们的状态方程： <code>res[i+1][j] = A[i+1][j] + min(res[i][j-1], res[i][j], res[i][j+1])</code>。<br />
Code:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">minFallingPathSum</span>(self, A):
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> A:
        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>
    <span style="color:#66d9ef">if</span> len(A) <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>:
        <span style="color:#66d9ef">return</span> min(A[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>])
    size <span style="color:#f92672">=</span> len(A)
    res <span style="color:#f92672">=</span> [[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">*</span>size <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(size)]
    res[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> A[<span style="color:#ae81ff">0</span>]
    <span style="color:#66d9ef">for</span> row <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, size):
        <span style="color:#66d9ef">for</span> col <span style="color:#f92672">in</span> range(size):
            <span style="color:#66d9ef">if</span> col <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>:
                res[row][col] <span style="color:#f92672">=</span> A[row][col] <span style="color:#f92672">+</span> min(res[row<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][col], res[row<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][col<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>])
            <span style="color:#66d9ef">elif</span> col <span style="color:#f92672">==</span> size <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>:
                res[row][col] <span style="color:#f92672">=</span> A[row][col] <span style="color:#f92672">+</span> min(res[row<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][col<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>], res[row<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][col])
            <span style="color:#66d9ef">else</span>:
                res[row][col] <span style="color:#f92672">=</span> A[row][col] <span style="color:#f92672">+</span> min(res[row<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][col<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>], res[row<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][col], res[row<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][col<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>])
    <span style="color:#66d9ef">return</span> min(res[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>])</code></pre></div>
<hr />

<hr/>

<h2 id="week3">Week3:</h2>

<h3 id="solved-8-problems">Solved 8 problems</h3>

<h4 id="139-m">139-M</h4>

<p><a href="https://leetcode.com/problems/word-break/description/">139. Word Break</a><br />
Difficulty：★★★☆☆<br />
Beats: 81%<br />
Time Complexity: O(nwd)<br />
Remark: 思路清晰，DP.</p>

<p>Explanation:<br />
<div>
The idea is the following:</p>

<p>d is an array that contains booleans</p>

<p>d[i] is True if there is a word in the dictionary that ends at ith index of s AND d is also True at the beginning of the word</p>

<p>Example:</p>

<p>s = &ldquo;leetcode&rdquo;</p>

<p>words = [&ldquo;leet&rdquo;, &ldquo;code&rdquo;]</p>

<p>d[3] is True because there is &ldquo;leet&rdquo; in the dictionary that ends at 3rd index of &ldquo;leetcode&rdquo;</p>

<p>d[7] is True because there is &ldquo;code&rdquo; in the dictionary that ends at the 7th index of &ldquo;leetcode&rdquo; AND d[3] is True</p>

<p>The result is the last index of d.
</div></p>

<p>Code:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">wordBreak</span>(self, s, wordDict):
    n <span style="color:#f92672">=</span> len(s)
    dp <span style="color:#f92672">=</span> [False] <span style="color:#f92672">*</span> n
    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(n):
        <span style="color:#66d9ef">for</span> word <span style="color:#f92672">in</span> wordDict:
            <span style="color:#66d9ef">if</span> word <span style="color:#f92672">==</span> s[i<span style="color:#f92672">-</span>len(word)<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span> : i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">and</span> (dp[i<span style="color:#f92672">-</span>len(word)] <span style="color:#f92672">or</span> i <span style="color:#f92672">-</span> len(word) <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>):
                dp[i] <span style="color:#f92672">=</span> True
                <span style="color:#66d9ef">break</span>
    <span style="color:#66d9ef">return</span> dp[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]</code></pre></div>
<hr/>

<h4 id="464-m">464-M</h4>

<p><a href="https://leetcode.com/problems/can-i-win/description/">464. Can I Win</a><br />
&gt;Difficulty：★★★★★<br />
Beats: 76%<br />
Time Complexity: O(n^2)<br />
Remark: 博弈论，以及移位操作表示数字是否用过的状态。不会。</p>

<p><a href="https://www.liuchuo.net/archives/3155">liuchou的博客</a></p>

<p>Code:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">canIWin</span>(self, M, T):
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">win</span>(M, T, m, state):
        <span style="color:#66d9ef">if</span> T <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>: <span style="color:#66d9ef">return</span> False
        <span style="color:#66d9ef">if</span> m[state] <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>: <span style="color:#66d9ef">return</span> m[state] <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>
        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(M):
        <span style="color:#66d9ef">if</span> (state <span style="color:#f92672">&amp;</span> (<span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> i)) <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>: <span style="color:#66d9ef">continue</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> win(M, T <span style="color:#f92672">-</span> i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, m, state <span style="color:#f92672">|</span> (<span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> i)):
            m[state] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
            <span style="color:#66d9ef">return</span> True
        m[state] <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
        <span style="color:#66d9ef">return</span> False

    s <span style="color:#f92672">=</span> M <span style="color:#f92672">*</span> (M <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>
    <span style="color:#66d9ef">if</span> s <span style="color:#f92672">&lt;</span> T: <span style="color:#66d9ef">return</span> False
    <span style="color:#66d9ef">if</span> T <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>: <span style="color:#66d9ef">return</span> True
    <span style="color:#66d9ef">if</span> s <span style="color:#f92672">==</span> T: <span style="color:#66d9ef">return</span> (M <span style="color:#f92672">%</span> <span style="color:#ae81ff">2</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>

    m <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> (<span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> M)
    <span style="color:#66d9ef">return</span> win(M, T, m, <span style="color:#ae81ff">0</span>)</code></pre></div>
<hr/>

<h4 id="650-m">650-M</h4>

<p><a href="https://leetcode.com/problems/2-keys-keyboard/description/">650. 2 Keys Keyboard</a><br />
&gt;Difficulty：★★★☆☆<br />
Beats: 100%<br />
Time Complexity: O(n)<br />
Remark: 多尝试几个n，就会发现其中蕴含的规律。</p>

<p>Explanation:<br />
什么时候复制、粘贴？<br />
当剩余元素数目是当前已有元素数目的整数倍的时候，如果已复制长度小于已有元素数目，更新复制长度，操作+1，接着复制，反复这个过程，直至剩余元素为0。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">minSteps</span>(self, n):
    res, cpl, ops <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>
    <span style="color:#66d9ef">if</span> n <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>: <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>
    <span style="color:#66d9ef">if</span> n <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span>: <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">2</span>
    rawn <span style="color:#f92672">=</span> n
    n <span style="color:#f92672">=</span> n <span style="color:#f92672">-</span> res
    <span style="color:#66d9ef">while</span> n<span style="color:#f92672">&gt;</span><span style="color:#ae81ff">0</span>:
        <span style="color:#66d9ef">if</span> n <span style="color:#f92672">%</span> res <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>:
            <span style="color:#75715e"># do copy</span>
            <span style="color:#66d9ef">if</span> cpl <span style="color:#f92672">&lt;</span> res:
                cpl <span style="color:#f92672">=</span> res
                ops <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
        <span style="color:#75715e"># do paste</span>
        res <span style="color:#f92672">+=</span> cpl
        n <span style="color:#f92672">-=</span> cpl
        ops <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
    <span style="color:#66d9ef">return</span> ops</code></pre></div>
<hr/>

<h4 id="838-m">838-M</h4>

<p><a href="https://leetcode.com/problems/push-dominoes/description/">838. Push Dominoes</a><br />
&gt;Difficulty：★★★★☆<br />
Beats: 84.30%<br />
Time Complexity: O(n)<br />
Remark: 理解几种普遍的倒下的情况，O(n)可以做。</p>

<p><strong>Intuition:</strong>
Whether be pushed or not, depend on the shortest distance to &lsquo;L&rsquo; and &lsquo;R&rsquo;.<br />
Also the direction matters.</p>

<p>Here is another idea that focus on &lsquo;L&rsquo; and &lsquo;R&rsquo;.<br />
&lsquo;R&hellip;&hellip;R&rsquo; =&gt; &lsquo;RRRRRRRR&rsquo;<br />
&lsquo;R&hellip;&hellip;L&rsquo; =&gt; &lsquo;RRRRLLLL&rsquo; or &lsquo;RRRR.LLLL&rsquo;<br />
&lsquo;L&hellip;&hellip;R&rsquo; =&gt; &lsquo;L&hellip;&hellip;R&rsquo;<br />
&lsquo;L&hellip;&hellip;L&rsquo; =&gt; &lsquo;LLLLLLLL&rsquo;</p>

<p>Code:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">pushDominoes</span>(self, d):
    d <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;L&#39;</span> <span style="color:#f92672">+</span> d <span style="color:#f92672">+</span> <span style="color:#e6db74">&#39;R&#39;</span>
    res <span style="color:#f92672">=</span> []
    i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
    <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, len(d)):
        <span style="color:#66d9ef">if</span> d[j] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;.&#39;</span>: <span style="color:#66d9ef">continue</span>
        middle <span style="color:#f92672">=</span> j <span style="color:#f92672">-</span> i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>
        <span style="color:#66d9ef">if</span> i: res<span style="color:#f92672">.</span>append(d[i])
        <span style="color:#66d9ef">if</span> d[i] <span style="color:#f92672">==</span> d[j]: res<span style="color:#f92672">.</span>append(d[i] <span style="color:#f92672">*</span> middle)
        <span style="color:#66d9ef">elif</span> d[i] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;L&#39;</span> <span style="color:#f92672">and</span> d[j] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;R&#39;</span>: res<span style="color:#f92672">.</span>append(<span style="color:#e6db74">&#39;.&#39;</span> <span style="color:#f92672">*</span> middle)
        <span style="color:#66d9ef">else</span>: res<span style="color:#f92672">.</span>append(<span style="color:#e6db74">&#39;R&#39;</span> <span style="color:#f92672">*</span> (middle <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>) <span style="color:#f92672">+</span> <span style="color:#e6db74">&#39;.&#39;</span> <span style="color:#f92672">*</span> (middle <span style="color:#f92672">%</span> <span style="color:#ae81ff">2</span>) <span style="color:#f92672">+</span> <span style="color:#e6db74">&#39;L&#39;</span> <span style="color:#f92672">*</span> (middle <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>))
        i <span style="color:#f92672">=</span> j
    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#39;&#39;</span><span style="color:#f92672">.</span>join(res)</code></pre></div>
<hr/>

<h4 id="646-m">646-M</h4>

<p><a href="https://leetcode.com/problems/maximum-length-of-pair-chain/description/">646. Maximum Length of Pair Chain</a><br />
&gt;Difficulty：★★★☆☆<br />
Beats: 40.26%<br />
Time Complexity: O(n^2)<br />
Remark: 经常性拿到这种二元变量的题有些没思路，学会使用python的lambda；思路还是比较清晰的，用DP的一般步骤套，可以想到怎么做。</p>

<p>Explanation:<br />
首先判断是DP问题：要求最长的chain，符合重复子问题、最优子结构的性质。</p>

<p>其次，它的状态，可以定义为到第<code>i</code>个元素时，以它结尾的和它前面的元素能组成的最长链。</p>

<p>状态转移，如果<code>pairs[i]</code>能放在<code>pairs[i-1]</code>后面，那么它最长就是在前者基础上加1。<br />
如果不能，我们就需要找到那个能放的，因此需要遍历<code>0...i-2</code>个元素，找到即可。</p>

<p>Code:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">findLongestChain</span>(self, pairs):
    pairs<span style="color:#f92672">.</span>sort(key<span style="color:#f92672">=</span><span style="color:#66d9ef">lambda</span> r:r[<span style="color:#ae81ff">0</span>])
    n <span style="color:#f92672">=</span> len(pairs)
    dp <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span>]<span style="color:#f92672">*</span>n
    dp[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
    <span style="color:#66d9ef">if</span> pairs[<span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">&gt;</span> pairs[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">1</span>]:
        dp[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> dp[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
    <span style="color:#66d9ef">else</span>:
        dp[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">2</span>, n):
        <span style="color:#66d9ef">if</span> pairs[i][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">&gt;</span> pairs[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">1</span>]:
            dp[i] <span style="color:#f92672">=</span> dp[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
        <span style="color:#66d9ef">else</span>:
            j <span style="color:#f92672">=</span> i <span style="color:#f92672">-</span> <span style="color:#ae81ff">2</span>
            <span style="color:#66d9ef">while</span> j <span style="color:#f92672">&gt;</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>:
                <span style="color:#66d9ef">if</span> pairs[j][<span style="color:#ae81ff">1</span>] <span style="color:#f92672">&lt;</span> pairs[i][<span style="color:#ae81ff">0</span>]:
                    <span style="color:#66d9ef">break</span>
                j <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span>
            dp[i] <span style="color:#f92672">=</span> dp[j] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
    <span style="color:#66d9ef">return</span> dp[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]</code></pre></div>
<hr/>

<h4 id="221-m">221-M</h4>

<p><a href="https://leetcode.com/problems/maximal-square/description/">221. Maximal Square</a><br />
&gt;Difficulty：★★★☆☆<br />
Beats: 67.54%<br />
Time Complexity: O(nm)<br />
Remark: 多举几个例子就能发现背后的状态方程了，不算难。</p>

<p>Explanation:<br />
假定状态是以<code>s[i][j]</code>作为右下角的符合条件的正方形的边长<code>dp[i][j]</code>，那么它由周围哪几个状态决定呢？<br />
&gt;[[&ldquo;1&rdquo;,&ldquo;0&rdquo;,&ldquo;1&rdquo;,&ldquo;0&rdquo;,&ldquo;0&rdquo;],[&ldquo;1&rdquo;,&ldquo;0&rdquo;,&ldquo;1&rdquo;,&ldquo;1&rdquo;,&ldquo;1&rdquo;],[&ldquo;1&rdquo;,&ldquo;1&rdquo;,&ldquo;1&rdquo;,&ldquo;1&rdquo;,&ldquo;1&rdquo;],[&ldquo;1&rdquo;,&ldquo;0&rdquo;,&ldquo;0&rdquo;,&ldquo;1&rdquo;,&ldquo;0&rdquo;]]
[[&ldquo;1&rdquo;,&ldquo;0&rdquo;],[&ldquo;0&rdquo;,&ldquo;0&rdquo;]]
[[&ldquo;1&rdquo;,&ldquo;0&rdquo;,&ldquo;1&rdquo;,&ldquo;0&rdquo;],[&ldquo;1&rdquo;,&ldquo;0&rdquo;,&ldquo;1&rdquo;,&ldquo;1&rdquo;],[&ldquo;1&rdquo;,&ldquo;0&rdquo;,&ldquo;1&rdquo;,&ldquo;1&rdquo;],[&ldquo;1&rdquo;,&ldquo;1&rdquo;,&ldquo;1&rdquo;,&ldquo;1&rdquo;]]
[[&ldquo;0&rdquo;,&ldquo;0&rdquo;,&ldquo;0&rdquo;,&ldquo;1&rdquo;],[&ldquo;1&rdquo;,&ldquo;1&rdquo;,&ldquo;0&rdquo;,&ldquo;1&rdquo;],[&ldquo;1&rdquo;,&ldquo;1&rdquo;,&ldquo;1&rdquo;,&ldquo;1&rdquo;],[&ldquo;0&rdquo;,&ldquo;1&rdquo;,&ldquo;1&rdquo;,&ldquo;1&rdquo;],[&ldquo;0&rdquo;,&ldquo;1&rdquo;,&ldquo;1&rdquo;,&ldquo;1&rdquo;]]</p>

<p>给出上面4个例子，其结果是4，1，4，9。自己尝试推导一下。</p>

<p>Code:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">maximalSquare</span>(self, matrix):
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> matrix: <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>
    n <span style="color:#f92672">=</span> len(matrix)
    m <span style="color:#f92672">=</span> len(matrix[<span style="color:#ae81ff">0</span>])
    dp <span style="color:#f92672">=</span> [[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> (m<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> range(n<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)]
    res <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, n<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>):
        <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, m<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>):
            <span style="color:#66d9ef">if</span> matrix[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;1&#34;</span>:
                dp[i][j] <span style="color:#f92672">=</span> min(dp[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][j], dp[i][j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>], dp[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
                res <span style="color:#f92672">=</span> max(res, dp[i][j])
    <span style="color:#66d9ef">return</span> res<span style="color:#f92672">*</span>res</code></pre></div>
<hr/>

<h4 id="091-m">091-M</h4>

<p><a href="https://leetcode.com/problems/decode-ways/description/">91. Decode Ways</a><br />
&gt;Difficulty：★★☆☆☆<br />
Beats: 100%<br />
Time Complexity: O(n)<br />
Remark: 注意对‘0’进行特殊处理，简单DP。</p>

<p>Code:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">numDecodings</span>(self, s):
    d <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span>]<span style="color:#f92672">*</span>(len(s)<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)
    d[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>

    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>,len(d)):
        <span style="color:#66d9ef">if</span> s[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#39;0&#39;</span>:
            d[i] <span style="color:#f92672">+=</span> d[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
        <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">and</span> (<span style="color:#e6db74">&#39;09&#39;</span> <span style="color:#f92672">&lt;</span> s[i<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>:i] <span style="color:#f92672">&lt;</span> <span style="color:#e6db74">&#39;27&#39;</span>):
            d[i] <span style="color:#f92672">+=</span> d[i<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>]              
    <span style="color:#66d9ef">return</span> d[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]</code></pre></div>
<hr/>

<h4 id="152-m">152-M</h4>

<p><a href="https://leetcode.com/problems/maximum-product-subarray/description/">152. Maximum Product Subarray</a><br />
&gt;Difficulty：★★★☆☆<br />
Beats: 47.25%<br />
Time Complexity: O(n)<br />
Remark: 写了一段程序只有最后一个样例过不了，很长的一个数组，15000，超内存应该是其次，最主要还是算法不够好，而且优化的方向就在内存上，为什么会需要<code>n^2</code>的内存。以及，之前的最大和最小在当前数为负数时的转化，题目的思考还是不够深入。</p>

<p>Code:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">maxProduct</span>(self, nums):
    n <span style="color:#f92672">=</span> len(nums)
    res <span style="color:#f92672">=</span> nums[<span style="color:#ae81ff">0</span>]
    rx, rm <span style="color:#f92672">=</span> nums[<span style="color:#ae81ff">0</span>], nums[<span style="color:#ae81ff">0</span>]
    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, n):
        <span style="color:#66d9ef">if</span> nums[i] <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>:
            tmp <span style="color:#f92672">=</span> rx
            rx <span style="color:#f92672">=</span> rm
            rm <span style="color:#f92672">=</span> tmp
        rx <span style="color:#f92672">=</span> max(nums[i], nums[i]<span style="color:#f92672">*</span>rx)
        rm <span style="color:#f92672">=</span> min(nums[i], nums[i]<span style="color:#f92672">*</span>rm)
        res <span style="color:#f92672">=</span> max(res, rx)
    <span style="color:#66d9ef">return</span> res</code></pre></div>
<hr/>

<h2 id="week2">Week2</h2>

<p>中秋放假，就这么混吗？路那么长，多停一天，可能就走不完了。
Solved 8 problems.</p>

<h3 id="day14">Day14</h3>

<p><strong>Date: 18-09-26</strong></p>

<h4 id="718-m">718-M</h4>

<p><a href="https://leetcode.com/problems/maximum-length-of-repeated-subarray/description/">718. Maximum Length of Repeated Subarray</a><br />
&gt;Difficulty：★★★☆☆<br />
Beats: 63.52%<br />
Time Complexity: O(mn)<br />
Remark: 简单题。最长公共子串。</p>

<p>Explanation:<br />
尝试考虑以<code>B[i]</code>结尾的<code>B[:i+1]</code>子串和<code>A</code>串的关系，迭代<code>A</code>，若<code>A[j] == B[i]</code>，那么比较内部的串。<br />
即状态方程：  <code>dp[i][j] = dp[i-1][j-1] + 1 if B[i] == A[j]</code></p>

<p>Code:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">findLength</span>(self, A, B):
    n1, n2 <span style="color:#f92672">=</span> len(A), len(B)
    dp <span style="color:#f92672">=</span> [[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> (n1<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> range(n2<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)]
    res <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, n2<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>):
        <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, n1<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>):
            <span style="color:#66d9ef">if</span> B[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">==</span> A[j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]:
                dp[i][j] <span style="color:#f92672">=</span> dp[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
                res <span style="color:#f92672">=</span> max(res, dp[i][j])     
    <span style="color:#66d9ef">return</span> res</code></pre></div>
<hr/>

<h3 id="day13">Day13</h3>

<p><strong>Date: 18-09-25</strong></p>

<h4 id="494-m">494-M</h4>

<p><a href="https://leetcode.com/problems/target-sum/description/">494. Target Sum</a><br />
&gt;Difficulty：★★★★☆<br />
Beats: 49.57%<br />
Time Complexity: ?<br />
Remark: dp + dfs，这里的dp的自顶向下算法就是dfs，但是需要做memorization，否则会出现TLE。</p>

<p>Explanation:<br />
以第i位置，以及可能在这个位置出现的<code>和</code>，两个值的<code>tuple</code>作为key，节约时间空间。</p>

<p>Code:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">findTargetSumWays</span>(self, nums, S):
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">memoization</span>(i, S):
        <span style="color:#66d9ef">if</span> i <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>:
            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span> <span style="color:#66d9ef">if</span> S <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#66d9ef">else</span> <span style="color:#ae81ff">0</span>
        <span style="color:#66d9ef">elif</span> (i,S) <span style="color:#f92672">in</span> dic:
            <span style="color:#66d9ef">return</span> dic[i, S]
        res <span style="color:#f92672">=</span> memoization(i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, S<span style="color:#f92672">-</span>nums[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]) <span style="color:#f92672">+</span> memoization(i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, S<span style="color:#f92672">+</span>nums[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>])
        dic[i, S] <span style="color:#f92672">=</span> res
        <span style="color:#66d9ef">return</span> res
    dic <span style="color:#f92672">=</span> {}
    <span style="color:#66d9ef">return</span> memoization(len(nums), S)</code></pre></div>
<hr/>

<h3 id="day12">Day12</h3>

<p><strong>Date: 18-09-24</strong></p>

<h4 id="516-m">516-M</h4>

<p><a href="https://leetcode.com/problems/longest-palindromic-subsequence/description/">516. Longest Palindromic Subsequence</a><br />
&gt;Difficulty：★★★☆☆<br />
Beats: \<br />
Time Complexity: O(n^2)<br />
Space Complexity: O(n^2)<br />
Remark: 要么就是python3的执行评判有问题，要么就是python3的执行是真的慢。算法的想法挺简单的，属于那种制表就可以完成的。</p>

<p>Explanation:<br />
我们假设从i位置开始，长度为<code>l</code>的子串<code>subs</code>（这里是子串，不是子序列），现在需要判断<code>subs</code>的最长回文子序列，先判断首尾是否相同：相同则首尾同时向内缩进1位，继续判断。
自底向上的做法，需要我们将长度<code>l</code>从2一直迭代至<code>len(s)</code>。</p>

<p><em>Formula</em>:<br />
<code>T[i][j] = T[i+1][j-1] + 2 if s[i] == s[j] else max(T[i+1][j], T[i][j-1])</code></p>

<p>Code:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py"><span style="color:#75715e"># submit this using python, not python3</span>
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">longestPalindromeSubseq</span>(self, s):
    n <span style="color:#f92672">=</span> len(s)
    dp <span style="color:#f92672">=</span> [[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">*</span>n <span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> range(n)]
    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(n):
        dp[i][i] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
    <span style="color:#66d9ef">for</span> l <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">2</span>, n<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>):
        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">0</span>, n <span style="color:#f92672">-</span> l <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>):
            j <span style="color:#f92672">=</span> i <span style="color:#f92672">+</span> l <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>
            <span style="color:#66d9ef">if</span> l <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">and</span> s[i] <span style="color:#f92672">==</span> s[j]:
                dp[i][j] <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>
            <span style="color:#66d9ef">elif</span> s[i] <span style="color:#f92672">==</span> s[j]:
                dp[i][j] <span style="color:#f92672">=</span> dp[i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>][j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span>
            <span style="color:#66d9ef">else</span>:
                dp[i][j] <span style="color:#f92672">=</span> max(dp[i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>][j], dp[i][j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>])
    <span style="color:#66d9ef">return</span> dp[<span style="color:#ae81ff">0</span>][<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]</code></pre></div>
<hr/>

<h3 id="day11">Day11</h3>

<p><strong>Date: 18-09-23</strong></p>

<h4 id="120-m">120-M</h4>

<p><a href="https://leetcode.com/problems/triangle/description/">120. Triangle</a>
&gt;Difficulty：★★★☆☆<br />
Beats: 72.33%<br />
Time Complexity: O(n^2)<br />
Space Complexity: O(n)<br />
Remark: 标准DP问题。</p>

<p>Explanation:<br />
- <em>Step1: 判断</em><br />
最小化问题，满足两个性质，可以用DP解。</p>

<ul>
<li><p><em>Step2: 状态</em><br />
首先我们不可能从底向上，从最后一层最小的点往上找的。<br />
这样的话，就会想知道，比如到第k层第i个元素，想知道到前k-1层第i/i-1个元素那里哪一个最小。<br />
所以状态可以定义为到第k层第i个元素</p></li>

<li><p><em>Step3: 状态方程</em>
我们需要迭代整个n，去寻找<code>[start, end]</code>的分割位置k，在k位置的时候，计算它的最坏情况，即<code>max(dp[start, k-1], dp[k+1, end]) + k</code>，现在我们想要的最终结果就是所有这样的k中最小的。</p></li>

<li><p><em>Step4: Tabulation or Memorizatio</em><br />
有两种做法，一种是存储N个结果，另一种是直接修改原数组。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">minimumTotal</span>(self, triangle):
<span style="color:#75715e"># res = [0]*len(triangle)</span>
<span style="color:#75715e"># res[0] = triangle[0][0]</span>
<span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, len(triangle)):
    <span style="color:#75715e"># cur = [x for x in res]</span>
    <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(len(triangle[i])):
        <span style="color:#66d9ef">if</span> j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>:
            upmin <span style="color:#f92672">=</span> triangle[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][j]
        <span style="color:#66d9ef">elif</span> j <span style="color:#f92672">&gt;=</span> len(triangle[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]):
            upmin <span style="color:#f92672">=</span> triangle[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
        <span style="color:#66d9ef">else</span>:
            upmin <span style="color:#f92672">=</span> min(triangle[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][j], triangle[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>])

        triangle[i][j] <span style="color:#f92672">+=</span> upmin
    <span style="color:#75715e"># print(res)</span>
<span style="color:#66d9ef">return</span> min(triangle[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>])</code></pre></div></li>
</ul>

<hr/>

<h3 id="day10">Day10</h3>

<p><strong>Date: 18-09-22</strong></p>

<h4 id="375-m">375-M</h4>

<p><a href="https://leetcode.com/problems/guess-number-higher-or-lower-ii/description/">375. Guess Number Higher or Lower II</a><br />
&gt;Difficulty：★★★☆☆<br />
Beats: 15.63%<br />
Time Complexity: O(n^2)<br />
Remark: 题目表述有点晦涩。又是可以用两个数字表示字典key的一道题。</p>

<p>Explanation:<strong>源: <a href="https://leetcode.com/problems/guess-number-higher-or-lower-ii/discuss/84766/Clarification-on-the-problem-description.-Problem-description-need-to-be-updated-!!!">xuehaohu</a></strong><br />
- <em>Step1: 判断</em><br />
最后我们需要找出<code>how much money you need to have to guarantee a win</code>，保证赢，至少需要多少钱，看起来像是需要最大化某个量又需要最小化另外某个量的问题。</p>

<ul>
<li><em>Step2: 状态</em><br />
如果只有一个数，那么不用猜，代价是0；<br /></li>
</ul>

<p>如果有两个数，比如<code>[5, 6]</code>，最小的代价是5：我们有两种方法去猜，一是猜5，猜中代价为0，猜不中代价为5，这种情况下需要付出的代价是5（想一想为什么）；另一种是猜6，猜中代价为0，猜不中代价为6。综合两种情况，猜中的最小代价是5;</p>

<p>如果有三个数，比如<code>[3, 4, 5]</code>，我们猜中的最小代价一定是4。</p>

<p>以此类推，对于更大的范围，我们可以将其划分成多个小的范围，这就符合DP问题的定义了。
我们可以定义状态为从<code>start</code>到<code>end</code>需要付出的最小代价。</p>

<ul>
<li><p><em>Step3: 状态方程</em>
我们需要迭代整个n，去寻找<code>[start, end]</code>的分割位置k，在k位置的时候，计算它的最坏情况，即<code>max(dp[start, k-1], dp[k+1, end]) + k</code>，现在我们想要的最终结果就是所有这样的k中最小的。</p></li>

<li><p><em>Step4: Tabulation or Memorizatio</em></p></li>
</ul>

<p>Code:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">getMoneyAmount</span>(self, n):
    dp <span style="color:#f92672">=</span> {}
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">getMA</span>(l, r):
        <span style="color:#66d9ef">if</span> l <span style="color:#f92672">&gt;</span> r:
            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>
        <span style="color:#66d9ef">if</span> (l, r) <span style="color:#f92672">in</span> dp:
            <span style="color:#66d9ef">return</span> dp[l, r]
        <span style="color:#66d9ef">if</span> r <span style="color:#f92672">==</span> l:
            dp[l, r] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
            <span style="color:#66d9ef">return</span> dp[l, r]
        <span style="color:#66d9ef">if</span> r<span style="color:#f92672">-</span>l <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>:
            dp[l, r] <span style="color:#f92672">=</span> l
            <span style="color:#66d9ef">return</span> dp[l, r]
        dp[l, r] <span style="color:#f92672">=</span> r<span style="color:#f92672">*</span>r
        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(l, r):
            dp[l, r] <span style="color:#f92672">=</span> min(dp[l,r], i <span style="color:#f92672">+</span> max(getMA(l, i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>),getMA(i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, r)))
        <span style="color:#66d9ef">return</span> dp[l, r]
    <span style="color:#66d9ef">return</span> getMA(<span style="color:#ae81ff">1</span>, n)</code></pre></div>
<hr/>

<h3 id="day9">Day9</h3>

<p><strong>Date: 18-09-21</strong><br />
数值分析上到今天终于跟不上了，看来假期需要补一补了，不然就真废了。今天的组会开的很不尽兴，各种事故。</p>

<h4 id="712-m">712-M</h4>

<p><a href="https://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/description/">712. Minimum ASCII Delete Sum for Two Strings</a><br />
&gt;Difficulty：★★★★☆<br />
Beats: 11.11%<br />
Time Complexity: O(n^2)<br />
Remark: 思路较为简单。本题基于最长公共子序列的解法，只不过状态的内容由公共子序列的长度变成了需要删除字母的代价。<br />
Explanation:<br />
- <em>Step1: 判断</em><br />
最小化删除的字母和，是DP问题</p>

<ul>
<li><p><em>Step2: 状态</em><br />
匹配到<code>str1[j]</code>和<code>str2[i]</code>需要删除的代价，即<code>str1[:j]</code>和<code>str2[:i]</code>需要删除的字母ascii码和，设为<code>dp[i][j]</code>。</p></li>

<li><p><em>Step3: 状态方程</em><br />
由状态之间的传递关系，如果<code>str1[j] == str2[i]</code> ，那么它们俩可以不用删除，需要考虑的是<code>str1[:j-1], str2[:i-1]</code>这两个串之间的关系，它们的关系由<code>dp[i-1][j-1]</code>给出；<br />
如果<code>str1[j]</code>和<code>str2[i]</code>不同，直观想法是把这两个字符都删除了，但这样需要付出的代价无疑是
最大的（<code>dp[i-1][j-1] + str2[i] + str1[j]</code>），考虑，如果只删除<code>str1[j]</code>，那么问题转化为<code>str1[:j-1]</code>和<code>str2[:i]</code>进行匹配，它们需要付出的代价就是<code>dp[i][j-1] + str1[j]</code>，同理，删除<code>str2[i]</code>需要付出的代价
是<code>dp[i-1][j] + str2[i]</code>，二者取较小者即可。所以状态方程定义如下：<br />
<code>if str1[j] == str2[i]: dp[i][j] = dp[i-1][j-1]</code><br />
<code>if str1[j] != str2[i]: dp[i][j] = max(dp[i][j-1] + str1[j],dp[i-1][j] + str2[i])</code></p></li>

<li><p><em>Step4: Tabulation or Memorizatio</em><br />
实现的时候，为了计算方便，多增加一行一列。</p></li>
</ul>

<p>Code:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">minimumDeleteSum</span>(self, s1, s2):
    l1, l2 <span style="color:#f92672">=</span> len(s1), len(s2)
    dp <span style="color:#f92672">=</span> [[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">*</span>(l1 <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> range(l2 <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)]
    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, l1<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>):
        dp[<span style="color:#ae81ff">0</span>][i] <span style="color:#f92672">+=</span> dp[<span style="color:#ae81ff">0</span>][i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> ord(s1[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>])
    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, l2<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>):
        dp[i][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">+=</span> dp[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">+</span> ord(s2[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>])

    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, l2<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>):
        <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, l1<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>):
            <span style="color:#66d9ef">if</span> s2[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">==</span> s1[j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]:
                dp[i][j] <span style="color:#f92672">=</span> dp[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
            <span style="color:#66d9ef">else</span>:
                dp[i][j] <span style="color:#f92672">=</span> min(dp[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][j] <span style="color:#f92672">+</span> ord(s2[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]), dp[i][j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> ord(s1[j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]))
    <span style="color:#66d9ef">return</span> dp[l2][l1]</code></pre></div>
<hr/>

<h3 id="day8">Day8</h3>

<p><strong>Date: 18-09-20</strong><br />
失了智的一天，两道题没有一道想出来的。差评，菜🐶。这两道题属于同一类型的，值得再刷！</p>

<h4 id="813-m">813-M</h4>

<p><a href="https://leetcode.com/problems/largest-sum-of-averages/description/">813. Largest Sum of Averages</a><br />
&gt;Difficulty：★★★★☆<br />
Beats: &lt;20%<br />
Time Complexity: O(Kn^2)<br />
Remark: 如果没有直接思路，从笨方法入手深入理解题意，然后再想想哪里可以提升。</p>

<p>Explanation:(参考lee215的题解)<br />
<strong>如何寻找状态？</strong><br />
我们有一个数组，至多可以分成K个连续的部分，然后对每个部分求平均再累加，求这个最大值。<br />
K个连续的部分，如何分割呢，我们可以以每个部分最后一个元素的位置作为分割点（至于为什么这么想，因为标志位置就只有每部分的开头和结尾元素，二者选其一而已）。<br />
现在假设我们分割了倒数一部分元素，那么整个数据集被我们分割成了最后一部分，以及前面k-1个部分，那么它的值便可以用下面的式子表达：<br />
<code>dp[n,k] = max(dp[n, k], dp[i, k-1] + sum(A[i:n])/float(n-i)), i=n-1,...,0</code><br />
由此可以用递归求解本题。<br />
(PS: lee215是真的喜欢用set的key来保存状态（：).</p>

<p>Code:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">largestSumOfAverages</span>(self, A, K):
    memo <span style="color:#f92672">=</span> {}
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">search</span>(n, k):
        <span style="color:#66d9ef">if</span> (n, k) <span style="color:#f92672">in</span> memo: <span style="color:#66d9ef">return</span> memo[n, k]
        <span style="color:#66d9ef">if</span> n <span style="color:#f92672">&lt;</span> k: <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>
        <span style="color:#66d9ef">if</span> k <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>:
            memo[n, k] <span style="color:#f92672">=</span> sum(A[:n]) <span style="color:#f92672">/</span> float(n)
            <span style="color:#66d9ef">return</span> memo[n, k]
        cur, memo[n, k] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>
        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>):
            cur <span style="color:#f92672">+=</span> A[i]
            memo[n, k] <span style="color:#f92672">=</span> max(memo[n, k], search(i, k <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">+</span> cur <span style="color:#f92672">/</span> float(n <span style="color:#f92672">-</span> i))
        <span style="color:#66d9ef">return</span> memo[n, k]
    <span style="color:#66d9ef">return</span> search(len(A), K)</code></pre></div>
<hr/>

<h4 id="873-m">873-M</h4>

<p><a href="https://leetcode.com/problems/length-of-longest-fibonacci-subsequence/description/">873. Length of Longest Fibonacci Subsequence</a><br />
&gt;Difficulty：★★★★☆<br />
Beats: 73.98%<br />
Time Complexity: O(n^2)<br />
Remark: 如果DP的掌握程度可以量化的话，我觉得我才走到25%，状态和状态转移方程真TM神奇，同时也明确提醒自己状态不一定连续。</p>

<p>Explanation:(参考lee215的题解)<br />
首先我们明确一点，<strong>已知类斐波那契数列的连续两个数之后，可以推导出规定范围内所有属于它的数。</strong><br />
基于这一点，我们的状态可以基于<code>类斐波那契数列的连续两个数</code>来设置，即令<code>dp[a, b]</code>表示以数<code>(a, b)</code>为结尾的类斐波那契数列。<br />
如此，我们的状态方程可以设置为：<code>dp[a, b] = (dp[b-a, a] + 1) or 2</code>。</p>

<p>Code:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">lenLongestFibSubseq</span>(self, A):
    dp <span style="color:#f92672">=</span> collections<span style="color:#f92672">.</span>defaultdict(int)
    s <span style="color:#f92672">=</span> set(A)
    res <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
    <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> xrange(len(A)):
        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> xrange(j):
            <span style="color:#66d9ef">if</span> A[j] <span style="color:#f92672">-</span> A[i] <span style="color:#f92672">&lt;</span> A[i] <span style="color:#f92672">and</span> A[j] <span style="color:#f92672">-</span> A[i] <span style="color:#f92672">in</span> s:
                dp[A[i], A[j]] <span style="color:#f92672">=</span> dp<span style="color:#f92672">.</span>get((A[j] <span style="color:#f92672">-</span> A[i], A[i]), <span style="color:#ae81ff">2</span>) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
                res <span style="color:#f92672">=</span> max(res, dp[A[i], A[j]])
    <span style="color:#66d9ef">return</span> max(dp<span style="color:#f92672">.</span>values() <span style="color:#f92672">or</span> [<span style="color:#ae81ff">0</span>])</code></pre></div>
<hr />

<h2 id="week1">Week1</h2>

<p>Solved 18 problems.</p>

<h3 id="day7">Day7</h3>

<p><strong>Date: 18-09-19</strong></p>

<h4 id="064-m">064-M</h4>

<p><a href="https://leetcode.com/problems/minimum-path-sum/description/">64. Minimum Path Sum</a><br />
&gt;Difficulty：★★☆☆☆<br />
Beats: 48.92%<br />
Time Complexity: O(n^2)<br />
Remark: 属于比较简单的基础DP题，模拟一遍就知道状态方程了。</p>

<p>Explanation:<br />
状态定义为走到当前位置需要的最少步数<code>dp[i][j]</code>。<br />
由规则可知，当前步往下一步走，只能向下或者向右，因此可以推得状态方程：<br />
<code>dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]</code>。</p>

<p>Code:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">minPathSum</span>(self, grid):
        <span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">        :type grid: List[List[int]]
</span><span style="color:#e6db74">        :rtype: int
</span><span style="color:#e6db74">        &#34;&#34;&#34;</span>
        n <span style="color:#f92672">=</span> len(grid)
        m <span style="color:#f92672">=</span> len(grid[<span style="color:#ae81ff">0</span>])
        dp <span style="color:#f92672">=</span> [[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">*</span>m <span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> range(n)]
        dp[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> grid[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">0</span>]
        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>,m):
            dp[<span style="color:#ae81ff">0</span>][i] <span style="color:#f92672">=</span> dp[<span style="color:#ae81ff">0</span>][i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> grid[<span style="color:#ae81ff">0</span>][i]
        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>,n):
            dp[i][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> dp[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">+</span> grid[i][<span style="color:#ae81ff">0</span>]
        <span style="color:#75715e"># print(dp)</span>
        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, n):
            <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, m):
                dp[i][j] <span style="color:#f92672">=</span> min(dp[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][j], dp[i][j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]) <span style="color:#f92672">+</span> grid[i][j]
        <span style="color:#75715e"># print(dp)</span>
        <span style="color:#66d9ef">return</span> dp[n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][m<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]</code></pre></div>
<hr/>

<h4 id="300-m">300-M</h4>

<p><a href="https://leetcode.com/problems/longest-increasing-subsequence/description/">300. Longest Increasing Subsequence</a><br />
&gt;Difficulty：★★☆☆☆<br />
Beats: 11.25%<br />
Time Complexity: O(n^2)<br />
Remark: 十分典型的DP题，求最长递增子序列。</p>

<p>Explanation:<br />
定义状态为在第<code>i</code>个元素时以它结尾的最长递增子序列的长度<code>T[i]</code>。<br />
求解<code>T[i]</code>时，我们需要寻找前<code>i</code>个元素中比<code>nums[i]</code>小的最大<code>T[k]</code>。<br />
则状态方程为：</p>
<pre><code class="language-T[i] = max(T[i], T[k] + 1) k=i-1,...,0```" data-lang="T[i] = max(T[i], T[k] + 1) k=i-1,...,0```">Code:  </code></pre>
<p>py
class Solution:
    def lengthOfLIS(self, nums):
        &ldquo;&rdquo;&rdquo;
        :type nums: List[int]
        :rtype: int
        &ldquo;&rdquo;&rdquo;
        if not nums: return 0
        n = len(nums)
        res = [1]*n
        for i in range(n):
            tmp = res[i]
            for j in range(i-1, -1, -1):
                if nums[j] &lt; nums[i]:
                    tmp = max(tmp, res[j] + 1)
            res[i] = tmp
        return max(res)</p>
<pre><code>&lt;hr/&gt;

#### 416-M  
[416. Partition Equal Subset Sum](https://leetcode.com/problems/partition-equal-subset-sum/description/)  
&gt;Difficulty：★★★☆☆     
Beats: 0%   
Time Complexity: O(n^2)  
Remark: 我觉得这题python的判法有问题，同样的思路，复杂度，我递归和制表两种方法都试了，疯狂TLE，太真实了。  

Explanation:  
这题的思路相对简单，要将数据集划分为两个和相等的的子数据集，那么和`sum`肯定是偶数，奇数和直接返回错。  
这个时候问题转化为，求`subset sum`，指定`sum`，是否存在子集满足和等于它。  

对于`subset sum`这个问题，比较经典。  
&lt;pre&gt;
Let isSubSetSum(int set[], int n, int sum) be the function to find whether there is a
subset of set[] with sum equal to sum. n is the number of elements in set[].

The isSubsetSum problem can be divided into two subproblems
…a) Include the last element, recur for n = n-1, sum = sum – set[n-1]
…b) Exclude the last element, recur for n = n-1.
If any of the above the above subproblems return true, then return true.
&lt;/pre&gt;

这题贴没AC的代码，看同样的思路改写成C++有没有问题🙃  
Code:  </code></pre>
<p>py
class Solution:
    def canPartition(self, nums):
        &ldquo;&rdquo;&rdquo;
        :type nums: List[int]
        :rtype: bool
        &ldquo;&rdquo;&rdquo;
        nsum = sum(nums)
        if nsum % 2 == 1:
            return False
        n = len(nums)
        half = int(nsum/2)</p>
<pre><code>    def subsetSum(target, ns):
        if target == 0: return True
        if not ns: return False
        if ns[-1] &gt; target:
            return subsetSum(target, ns[:-1])
        return subsetSum(target-ns[-1], ns[:-1]) or subsetSum(target, ns[:-1])

    return subsetSum(half, nums)

    # dp = [[0]*(half+1) for _ in range(n)]
    # for i in range(n):
    #     dp[i][0] = 1
    # for i in range(1, half+1):
    #     if i == nums[0]:
    #         dp[0][i] = 1
    # for i in range(1, n):
    #     for j in range(1, half+1):
    #         if j &lt; nums[i]:
    #             dp[i][j] = dp[i-1][j]
    #         else:
    #             dp[i][j] = dp[i-1][j] or dp[i-1][j-nums[i]]
    # if dp[n-1][half]:
    #     return True
    # return False  </code></pre><pre><code>&lt;hr/&gt;

### Day6  
**Date: 18-09-18**  

#### 343-M
[343. Integer Break](https://leetcode.com/problems/is-subsequence/description/)  
&gt;Difficulty：★★☆☆☆     
Beats: 36.83%   
Time Complexity: O(n^2)  
Remark: 这道题属于容易推断的DP问题，多举几个例子就能自己发现了。  

Explanation：  
通过枚举观察可以发现以下结果：  
&lt;pre&gt;
2: 1
3: 1x2 = 2
4: 2x2 = 4
5: 2x3 = 6
6: 3x3 = 9
7: 3x4 = 12
8: 2x(6) = 2x9 = 18
9: 3x(6) = 3x9 = 27
10: 2x(8) = 2x18 = 36
&lt;/pre&gt;
所以它具有最优子结构以及重复子问题的性质。值得注意的是，2和3的结果并没有他们本身大，所以后续我们需要用到2或者3的时候，我们用的是它本身，而不是它break的结果。  

状态方程如下：  
`T[n]=max(T[n], T[i]*T[n-i]) i = 1,...,n/2`  

Code:  </code></pre>
<p>py
class Solution:
    def integerBreak(self, n):
        &ldquo;&rdquo;&rdquo;
        :type n: int
        :rtype: int
        &ldquo;&rdquo;&rdquo;
        if n &lt; 4:
            return n-1
        maxr = [0, 1, 2, 3]
        for cur in range(4, n+1):
            cm = 0
            for i in range(1, int(cur/2) + 1):
                cm = max(cm, maxr[i] * maxr[cur-i])
            maxr.append(cm)
        return maxr[n]</p>
<pre><code>&lt;hr/&gt;

#### 474-M
[474. Ones and Zeroes](https://leetcode.com/problems/ones-and-zeroes/description/)  
&gt;Difficulty：★★★☆☆     
Beats: 15.76%   
Time Complexity: O(n)  
Remark: 就题目本身而言，属于经典的0/1背包问题，而且属于二维费用的背包问题。同时这题揭露了LeetCode中python3和python评判的差异，同样的代码，python3用时更久。  

Explanation:  
先Mark一下，状态方程很简单：`dp[i][j] = max(dp[i][j], dp[i-zeros][j-ones]+1)`  
留待背包问题做个总结。  

Code:  </code></pre>
<p>py</p>

<h1 id="使用python-可ac-使用python3-tle">使用python，可AC；使用python3，TLE</h1>

<p>class Solution:
    def findMaxForm(self, strs, m, n):
        &ldquo;&rdquo;&rdquo;
        :type strs: List[str]
        :type m: int
        :type n: int
        :rtype: int
        &ldquo;&rdquo;&rdquo;
        dp = [[0] * (n+1) for _ in range(m+1) ]
        for s in strs:
            s0 = s.count(&lsquo;0&rsquo;)
            s1 = len(s) - s0
            for i in range(m, s0-1, -1):
                for j in range(n, s1-1, -1):
                    dp[i][j] = max(dp[i][j], dp[i-s0][j-s1]+1)</p>
<pre><code>    return dp[m][n]</code></pre><pre><code>&lt;hr/&gt;

#### 392-M
[392. Is Subsequence](https://leetcode.com/problems/is-subsequence/description/)
&gt;Difficulty：★★★☆☆     
Beats: 62.02%   
Time Complexity: O(nm)  
Remark: 中规中矩的DP，但是构建状态矩阵的时候MLE了两次，之后改用了递归。

Explanation:  
- *Step1: 判断*  
满足重叠子问题、最优子结构性质。

- *Step2: 状态*  
首先明确一点，如果一个串B是串A的子串，那么串B中字符出现的先后顺序在串A中也是一样的。想一想为什么？  
在知道了上面一这点后，我们可以这样定义状态，若当前字符s[i]对应串A的A[j]，其状态为`true`。  

- *Step3: 状态方程*  
那么s[i+1]在哪里找呢？我们需要在A[j+1:]里找，重复上面的过程。如果有一次s[k]没有找到对应字符，直接返回`false`。

- *Step4: Tabulation or Memorizatio*    
这里我用的是自上而下的递归。  

Code:  </code></pre>
<p>py
class Solution:
    def isSubsequence(self, s, t):
        &ldquo;&rdquo;&rdquo;
        :type s: str
        :type t: str
        :rtype: bool
        &ldquo;&rdquo;&rdquo;
        def sub(s, t):
            if not s: return True
            if not t: return False
            target = s[0]
            idx = -1
            for i in range(len(t)):
                if target == t[i]:
                    idx = i
                    break
            if idx &lt; 0:
                return False
            return sub(s[1:], t[idx+1:])
        return sub(s, t)</p>
<pre><code># 利用Python自带函数  
def isSubsequence(self, s, t):
    ind = -1
    for i in s:
        try: ind = t.index(i,ind+1)
        except: return False
    return True</code></pre><pre><code>&lt;hr/&gt;

### Day5  

**Date: 18-09-17**  

#### 357-M  
[357. Count Numbers with Unique Digits](https://leetcode.com/problems/count-numbers-with-unique-digits/description/)  

&gt;Difficulty：★★☆☆☆     
Beats: 69.17%   
Time Complexity: O(n)  
Remark: 简单题，可以总结为数学问题，这道题说明，状态不一定要直接解决我们的最终问题，它可以是最终答案的骨架。  

一看就懂，直接放代码。
Code:  </code></pre>
<p>py</p>

<h1 id="n-1-10">n = 1 : 10</h1>

<h1 id="n-2-9-9-1-9-0-9-except-first-digit">n = 2 : 9 * 9      (1-9)|(0-9 except first Digit)</h1>

<h1 id="n-3-9-9-8-1-9-0-9-except-first-digit-0-9-except-first-digit">n = 3 : 9 * 9 * 8  (1-9)|(0-9 except first Digit) | (0-9 except first Digit))</h1>

<h1 id="toc_44">&hellip;</h1>

<p>class Solution:
    def countNumbersWithUniqueDigits(self, n):
        &ldquo;&rdquo;&rdquo;
        :type n: int
        :rtype: int
        &ldquo;&rdquo;&rdquo;
        if n == 0: return 1
        if n == 1: return 10
        dp = [0]*(n+1)
        dp[1] = 10
        dp[2] = 9*9
        for i in range(3, n+1):
            dp[i] = dp[i-1] * (10-i+1)
        return sum(dp)</p>
<pre><code>&lt;hr/&gt;

### Day4  

**Date: 18-09-16**  

#### 714-M  

[714. Best Time to Buy and Sell Stock with Transaction Fee](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/description/)  

&gt;Difficulty：★★★★☆     
Beats: 44.97%   
Time Complexity: O(n)  
Remark: 比较难，什么状态，以及状态方程。我个人想不到需要两个状态方程来维护，所以看了很多题解。买卖这两个字很值得推敲。  

Explanation:  
有两个题解写的比较好，推荐一下。  
[精简的解释](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/discuss/136388)  
[利用状态机，含图解，非本题](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/discuss/75928/)  
[针对买卖股票系列，总结十分全面](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/discuss/108870/)  

本题的关键就是要想清楚什么时候买、什么时候卖。这二者又取决于今天 买/卖 和明天 买/卖 有什么联系。  

买和卖之间的桥梁就是股票以及利润。  

以`1, 4, 2, 8, 4, 9`为例。  
第0天，假设不买，则利润为`profit[0] = 0`；假设买了，持有`shares[0] = -1`。  
第1天，根据第0天的两种状态：  
今天卖还是不卖呢，可以卖手中持有的，如果卖，收益是 `tmp = shares[0] + nums[1] - fee`，这里结果是1，如果不卖，收益就是`profit[0]=0`，说明今天卖昨天买的可以有正收益，因此`profit[1] = max(tmp, profit[0])`；  
那么今天适不适合买呢，如果买，就面临一个选择。因为要求不能持有多余一股，所以今天买了，昨天就不能买。因此，若今天买，需要付出`tmp = profits[0] - nums[1] = -4`，显然第0天买更划算，因此`shares[1] = max(tmp,  shares[0])`。  
……  
以此类推，可以理解为：  
&gt;`dp[i][0]`: arrive i, no shares at hand.
`dp[i][1]`: arrive i, shares at hand.
`dp[i][1] = max(dp[i-1][0] - nums[i], dp[i-1][1])`: buy at nums[i] or do nothing.
`dp[i][0] = max(dp[i-1][1] + nums[i] - fee, dp[i-1][0])`: sell at nums[i] or do nothing.  


Code:  </code></pre>
<p>py
class Solution:
    def maxProfit(self, prices, fee):
        &ldquo;&rdquo;&rdquo;
        :type prices: List[int]
        :type fee: int
        :rtype: int
        &ldquo;&rdquo;&rdquo;
        # dp = [[0 for _ in range(2)] for _ in range(len(prices))]
        # dp[0][0] = 0
        # dp[0][1] = -prices[0]
        # for i in range(1, len(prices)):
        #     dp[i][1] = max([dp[i - 1][0] - prices[i], dp[i - 1][1]])
        #     dp[i][0] = max([dp[i - 1][1] + prices[i] - fee, dp[i - 1][0]])
        # print(dp)
        # return dp[-1][0]</p>
<pre><code>    profits = 0
    shares = -prices[0]
    for i in range(1, len(prices)):
        tmp_shares = shares
        shares = max(profits - prices[i], shares)
        profits = max(tmp_shares + prices[i] - fee, profits)
    return profits   </code></pre><pre><code>&lt;hr/&gt;

#### 647-M
[647. Palindromic Substrings](https://leetcode.com/problems/palindromic-substrings/description/)  
&gt;Difficulty：★★★☆☆     
Beats: 29.16%   
Time Complexity: O(n^2)  
Remark: 关键还是要分析出相邻状态之间的关系。  

Explanation:  
- *Step1: 判断*  
满足重叠子问题、最优子结构性质。考虑如果某个串是回文串，那么它所临近的串应该如何判断呢？

- *Step2: 状态*  
直观一点，我们可以简单的认为状态是从`i`到`j`的子串是否是回文串，即`T[i][j]`是否是回文串。


- *Step3: 状态方程*  
假设现在`T[i][j]`是回文串，对于`s[j+1]`，基于回文串的性质，我们知道，如果在已有回文串的两边加上同样的字符，它依然是一个回文串，所以若`s[i-1]`和`s[j+1]`相等，就可以得出`T[i-1][j+1]`也是回文串。所以我们可以推导出状态方程：  
`if s[i]==s[j]: T[i][j] = T[i+1][j-1]`  


- *Step4: Tabulation or Memorizatio*   
本题我们的父问题需要多个子问题堆叠，比较简单的想法是自底向上，构建二维状态矩阵。  

Code</code></pre>
<p>py
class Solution:
    def countSubstrings(self, s):
        &ldquo;&rdquo;&rdquo;
        :type s: str
        :rtype: int
        &ldquo;&rdquo;&rdquo;
        if not s:
            return 0
        n = len(s)
        T = [[None] * n for _ in range(n)]
        res = 0
        for l in range(n):
            for i in range(n):
                j = i+l
                if j &lt; n:
                    if i == j:
                        T[i][j] = 1
                        res += 1
                        continue
                    if s[i] == s[j]:
                        if j-1 &lt;= i+1 or T[i+1][j-1] == 1:
                            T[i][j] = 1
                            res += 1
        return res</p>
<pre><code>&lt;hr/&gt;


#### 877-M  

[877. Stone Game](https://leetcode.com/problems/stone-game/discuss/)  
&gt;Difficulty：★★★☆☆     
Beats: %   
Time Complexity: O(n)  
Remark: 可以说没有意义。  

Alex永远不会输。

&lt;hr/&gt;

### Day3  

**Date: 180915**  

#### 413-M  

[413. Arithmetic Slices](https://leetcode.com/problems/arithmetic-slices/description/)  
&gt;Difficulty：★★★☆☆     
Beats: 97.54%   
Time Complexity: O(n)  
Remark: 有几个点需要注意一下，按照DP的解题思路，想通了注意点就ok了。  

Explanation:  
- *Step1: 判断*  
满足重叠子问题、最优子结构性质。即如果某个位置与之前连续的若干个元素满足题意，那么其下一个位置是否满足呢？  

- *Step2: 状态*  
假设`A[i]`与之前若干个连续元素满足arithmetic slices的性质 (i&gt;=2)，我们将之前的满足条件的连续元素存到数组中。  
那么元素`A[i+1]`是否满足，只需要比较它和它之前的两个元素即可。  
如果`A[i+1]`满足，会多出多少个满足条件的arithmetic slices呢？  
如果`A[i+1]`不满足，又要怎么算呢？


- *Step3: 状态方程*  
接上面的状态分析。  
举个简单的例子，`1,3,5,7`是满足性质的一个slice，判断元素`9`，`9-7==7-5`，
那么对于`1,3,5,7,9`而言，因为它整体是满足条件的，所有以`9`结尾的所有至少3个连续元素都可以满足题目条件，
即`3,5,7,9`，`5,7,9`均满足，整理一下：  
&lt;pre&gt;
1,3,5,7,9  
3,5,7,9  
5,7,9  
&lt;/pre&gt;
 所以当多出一个元素`9`满足条件的时候，就有多出`5-3+1`个元素。

 注意点，如果`A[i+1]`不满足，我们也不能从`A[i+1]`重新开始算，而是需要从`A[i]`开始重新算。  

- *Step4: Tabulation or Memorizatio*   


Code:</code></pre>
<p>py
class Solution:
    def numberOfArithmeticSlices(self, A):
        &ldquo;&rdquo;&rdquo;
        :type A: List[int]
        :rtype: int
        &ldquo;&rdquo;&rdquo;
        cur = []
        res = 0
        for i in range(len(A)):
            if len(cur) &lt; 2:
                cur.append(A[i])
            else:
                if A[i] - cur[-1] == cur[-1] - cur[-2]:
                    cur.append(A[i])
                    res += len(cur) - 3 + 1
                else:
                    tmp = cur[-1]
                    cur = [tmp, A[i]]
        return res</p>
<pre><code>&lt;hr&gt;

### Day2
**Date: 18-09-14**  

#### 338-M  

[338. Counting Bits](https://leetcode.com/problems/counting-bits/description/)  
&gt;Difficulty：★★★☆☆     
Beats: 63.94%   
Time Complexity: O(n)  
Remark: 考察二进制的时候，多向左移右移的方向考虑。  

Explanation:  
- *Step1: 判断*  
朝`O(n)`的时间复杂度方向考虑，肯定需要用到子问题的解，不然不太可能。  

- *Step2: 状态*  
状态自然是数`i`的二进制中包含1的个数`count[i]`。  
难度是如何找寻它与子问题的关系。  

- *Step3: 状态方程*  
&lt;pre&gt;
0: 0000 0000   0
1: 0000 0001   1
2: 0000 0010   1
3: 0000 0011   2
4: 0000 0100   1
5: 0000 0101   2
6: 0000 0110   2
7: 0000 0111   3
8: 0000 1000   1
&lt;/pre&gt;
观察`0-8`的二进制，会比较自然的朝左移右移的角度去想。一个数的二进制左移一位相当于翻倍，反之减小一般。奇数比较特别的地方在于左移的时候末尾补`0`，右移的时候原来末尾的`1`会丢失。基于这个想法，对于数`i`，在不考虑原本末位的情况下，我们不难想到右移后`i`与`i&gt;&gt;1`的二进制中含有相同个数的`1`。再加上末位可能有的`1`，就可以得到`i`中含有`1`的个数了。  
得到状态方程：`count[i] = count[i&gt;&gt;1] + (i &amp; 1)`

- *Step4: Tabulation or Memorizatio*   
两种方法都可以。  


Code:</code></pre>
<p>python
class Solution:
    def countBits(self, num):
        &ldquo;&rdquo;&rdquo;
        :type num: int
        :rtype: List[int]
        &ldquo;&rdquo;&rdquo;
        array = [0]*(num+1)
        for i in range(num+1):
            array[i] = array[i&gt;&gt;1] + (i &amp; 1)
        return array</p>
<pre><code>&lt;hr&gt;

#### 053-E  

[053 Maximum Subarray](https://leetcode.com/problems/maximum-subarray/description/)  
&gt;Difficulty：★★☆☆☆     
Beats: 99.53%   
Time Complexity: O(n)  
Remark: `O(n^2)`是不行的，从解DP问题的一般思路入手，一步一步来。同样的Beats存在问题，以后除了低于30%的就不写了，另外两个数比较大小，python的`max`函数比直接比较要慢。  

Explanation:  
- *Step1: 判断*  
最大子串问题，属于DP问题。  

- *Step2: 状态*  
我们希望得到的`Maximum Subarray`，这个子串的最后一个元素可能在原数组中的任意位置，因此自然联想到用**以`i`结尾的子串的最大和`res[i]`** 作为状态，当然，这个子串可能不是以`0`作为首元素。  

- *Step3: 状态方程*  
探索`res`的前后序列关系，如果`res[i-1]`是前`i-1`个元素的最大和，那么在第`i`个元素的位置，我们需要计算以它结尾的最大和，如果`res[i-1] &lt; 0`，那就没有累加的必要，反之，累加。即状态方程为：  
`res[i] = max(0, res[i-1]) + nums[i]`  
更新最大值。

- *Step4: Tabulation or Memorizatio*   
两种方法都可以，为了节约空间，我们只使用常数数量的空间。

Code:</code></pre>
<p>python
class Solution:
    def maxSubArray(self, nums):
        &ldquo;&rdquo;&rdquo;
        :type nums: List[int]
        :rtype: int
        &ldquo;&rdquo;&rdquo;
        res = cur = nums[0]
        for i in range(1, len(nums)):
            if cur &lt;= 0:
                cur = nums[i]
            else:
                cur += nums[i]
            if cur &gt; res:
                res = cur
        return res</p>
<pre><code>&lt;hr&gt;

#### 303-E  

[303. Range Sum Query - Immutable](https://leetcode.com/problems/range-sum-query-immutable/description/)  
&gt;Difficulty：★☆☆☆☆  
Beats: 87.5%   
Time Complexity: O(n)  
Remark: 简单题，基于一个简单的发现。同样的Beats存在问题。  

Explanation:  
1. *Step1: 判断*  
求从位置i到位置j的值的和，i和j任意，具有重叠子问题、最优子结构两个性质。  

2. *Step2: 状态*  
如果暴力把所有的i,j都算一遍，那么无论时间还是空间复杂度都会很高。  
换个思路，我们算一下从0到1，两个数的和`sum[1]`是`nums[0]+nums[1]`，
从0到2的和`sum[2]`是`nums[0] + nums[1] + nums[2]`，
从0到3的和`sum[3]`是`nums[0] + nums[1] + nums[2] + nums[3]`。  
我们发现从0开始，加到`i-1`的和是`sum[i-1]`，到`i`的时候，只需要在`sum[i-1]`的基础上加上`nums[i]`，
在`sum[i-2]`的基础上加上`nums[i-1] + nums[i]`……  

3. *Step3: 状态方程*  
那么我们的状态就可以设置为从0到i的和是`sum[i]`。  
从`i`到`j`的话，`sum[j]`就等于`sum[i] + nums[i+1] + ... + nums[j]`。  
从而得到`res[i,j] = sum[j] - sum[i]`。

4. *Step4: Tabulation or Memorizatio*   
根据题目的设置，可以选用`list`或者`dict`。

Code:</code></pre>
<p>python
class NumArray:</p>
<pre><code>def __init__(self, nums):
    &#34;&#34;&#34;
    :type nums: List[int]
    &#34;&#34;&#34;
    self.val = {-1:0}
    for i in range(len(nums)):
        self.val[i] = self.val[i-1] + nums[i]

def sumRange(self, i, j):
    &#34;&#34;&#34;
    :type i: int
    :type j: int
    :rtype: int
    &#34;&#34;&#34;
    return self.val[j] - self.val[i-1]</code></pre><pre><code>&lt;hr&gt;  

#### 198-E
[198. House Robber](https://leetcode.com/problems/house-robber/description/)  
&gt;Difficulty：★☆☆☆☆  
Beats: 50% ? 100%   
Time Complexity: O(n)  
Remark: 同样是Python，时间复杂度相同，常数空间复杂度的解居然也只有50%，对比了其他人的解法，感觉leetcode的评判有点问题。  

Explanation:  
1. *Step1: 判断*  
最大化数值，是DP问题  

2. *Step2: 状态*  
在第i家可以获得的最大利润P[i]，不一定要取nums[i]

3. *Step3: 状态方程*  
P[i] 和同序列之前的数有什么关系呢？  
我们知道为了在第i家的时候，有两种选择：  
    + 一是偷取第i家，此时最大利润是`P[i-2] + nums[i]`  
    + 二是不取第i家，此时最大利润就是`P[i-1]`  

  为了使得在第i家时的利润最大，我们取二者较大的。因此可以求得状态方程：  
`P[i] = max(P[i-1], P[i-2] + nums[i])`。

4. *Step4: Tabulation or Memorizatio*   
这里结合`746-E`里的做法，可以节约空间，只使用常数空间复杂度。

Code:  </code></pre>
<p>python
class Solution:<br />
    def rob(self, nums):
        &ldquo;&rdquo;&rdquo;
        :type nums: List[int]
        :rtype: int
        &ldquo;&rdquo;&rdquo;
        length = len(nums)
        if not nums:
            return 0
        if length == 1:
            return nums[0]</p>
<pre><code>    pre, cur = nums[0], max(nums[0], nums[1])
    for i in range(2, length):
        pre, cur = cur, max(cur, pre + nums[i])
    return cur</code></pre><pre><code>&lt;hr&gt;

### Day1
**Date: 18-09-13**  

#### 746-E  
[746. Min Cost Climbing Stairs](https://leetcode.com/problems/min-cost-climbing-stairs/description/)  
&gt;Difficulty：★☆☆☆☆  
Beats: 52% / 100%   
Time Complexity: O(n)  
Remark: 简单题，斐波那契的拓展，但是同样是BottomUp，用了O(n)的空间，和O(1)的空间是不同的！  

Explanation:  
参考070题，再加上cost的条件，注意要踏到最顶端，容易得出状态是**迈上**第i层的最小代价T[i]。  
要踏上第`i`层，可能是从`i-1`或者`i-2`层上来的，要使得代价最小，那么二者取较小者。  
因此有状态方程：`T[i] = min(T[i-1], T[i-2]) + cost[i]`。  
时间复杂度都是`O(n)`，不难写出代码。下面分享的是两种用不同空间复杂度的代码。  

**空间复杂度 O(n)** - 这是比较常规的做法  </code></pre>
<p>python
class Solution:
    def minCostClimbingStairs(self, cost):
        &ldquo;&rdquo;&rdquo;
        :type cost: List[int]
        :rtype: int
        &ldquo;&rdquo;&rdquo;
        if not cost:
            return 0
        n = len(cost) + 2
        T = [0]*n
        T[0] = 0
        T[1] = 0
        for i in range(2, n):
            T[i] = min(T[i-1], T[i-2]) + cost[i-2]
        print(T)
        return min(T[n-1], T[n-2])</p>
<pre><code>**空间复杂度 O(1)**   </code></pre>
<p>python
class Solution:
    def minCostClimbingStairs(self, cost):
        &ldquo;&rdquo;&rdquo;
        :type cost: List[int]
        :rtype: int
        &ldquo;&rdquo;&rdquo;
        if not cost:
            return 0
        pre, cur = cost[0], cost[1]
        for i in range(2, len(cost)):
            pre, cur = cur, min(pre, cur) + cost[i]
        return min(pre,cur)</p>
<pre><code>注意这里的`pre, cur = cur, min(pre, cur) + cost[i]`，其作用等价于：  </code></pre>
<p>python
tmp = cur
cur = min(pre, cur) + cost[i]
pre = tmp</p>
<pre><code>&lt;hr&gt;

#### 121-E
[121. Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/)  
&gt;难易程度：★★☆☆☆  
Beats: 73.94%  
时间复杂度：O(n)  
Remark: 简单题，有助于DP基本概念的理解。

Explanation:  
暴力：
每一天都和前面所有天的股价计算差值，保留最大值，那么时间复杂度就是 n的平方。不出意外就是TLE了。

问题在于如何确定哪天是股价最小的，再确定差价最高的。

**DP Steps**  
- *Step1: 判断*  
最大化利润，是DP问题  

- *Step2: 状态*  
第i天可以获得的最大利润P[i]（不一定是第[i]天卖出）

- *Step3: 状态方程*  
P[i] 和 P[i-1]有什么关系呢？  
如果s[i] 比s[i-1]小，那么P[i] = P[i-1]，同时这两天最小价格至少会是s[i]，更新minPrice；  
如果s[i] 比s[i-1]大，那么第s[i] - minPrice 是要比s[i-1] - minPrice大的，因此更新当前差价，和最大差价比较，如果比最大差价大，那么P[i] = nowMax

- *Step4: Tabulation or Memorizatio*  
Code:  </code></pre>
<p>python
class Solution:
    def maxProfit(self, prices):
        &ldquo;&rdquo;&rdquo;
        :type prices: List[int]
        :rtype: int
        &ldquo;&rdquo;&rdquo;
        if not prices:
            return 0
        n = len(prices)
        T = [0]
        minPrice = prices[0]
        maxPrice = T[0]
        for i in range(1, n):
            if prices[i] &lt; prices[i-1]:
                T.append(T[i-1])
                minPrice = prices[i] if prices[i] &lt; minPrice else minPrice
            else:
                cur = prices[i] - minPrice
                maxPrice = cur if cur &gt; maxPrice else maxPrice
                T.append(maxPrice)
        return T[n-1]</p>
<pre><code>&lt;!-- &lt;hr style=&#34;border:none; border-top:1px dashed ; height:1px&#34;/&gt; --&gt;
&lt;hr/&gt;

#### 070-E  

[070. Climbing Stairs](https://leetcode.com/problems/climbing-stairs/description/)  
&gt;难易程度：★☆☆☆☆  
TopDown Beats: 100%  
BottomUp Beats: 45.20%
时间复杂度：O(n)  
Remark: 简单题，理解TopDown和BottomUp概念，[区别](https://www.geeksforgeeks.org/tabulation-vs-memoizatation/)。  


DP问题中有一些典型的情况。  
本题属于其中一种，即斐波那契数列。  
那么不难想到状态方程`T[n] = T[n-1] + T[n-2]`。  

假设我们没看出这是一个斐波那契问题，我们来推理看看。

(层数)：方式。解释  
 (1)： 1。只有一种方式  
 (2)： 2。两种方式，11，2。  
 (3)： 3。111，12，21。  
 (4)： 5。1111，112， 121，211，22。  

思考一下4层的情况，如果先迈出了一步，那么总的情况就是1(3)，括号里是剩下的总层数，3层的情况我们已经算过了，把3层的情况填到括号中，1(111)，1(12)，1(21)；同理如果先迈出两步，总的情况就是2(2)，(2)又有2种。那么(4)可以写成`(4) = 1(3) + 2(2)`。下面验证一下(5)。  
(5) =&gt; 1(4)，2(3) =&gt; 1(1111，112， 121，211，22)，2(111，12，21)。  

这个时候我们就可以得出相同的结论了。

这道题的价值在于练习`TopDown` 和 `BottomUp` 两种方式。    

**Top Down**  </code></pre>
<p>python
class Solution:
    def climbStairs(self, n):
        &ldquo;&rdquo;&rdquo;
        :type n: int
        :rtype: int
        &ldquo;&rdquo;&rdquo;
        f = [0] * (n+1)
        f[0] = f[1] = 1
        for i in range(2, n+1):
            f[i] = f[i-1] + f[i-2]
        print(f)
        return f[n]</p>
<pre><code>**Bottom Up**</code></pre>
<p>python
class Solution:
    def climbStairs(self, n):
        &ldquo;&rdquo;&rdquo;
        :type n: int
        :rtype: int
        &ldquo;&rdquo;&rdquo;
        lookup = [None]*(n+1)</p>
<pre><code>    # Memoization -&gt; Bottom Up
    def fib(n):
        if n == 0 or n == 1:
            lookup[n] = 1
        if lookup[n] is None:
            lookup[n] = fib(n-1) + fib(n-2)
        return lookup[n]
    res = fib(n)
    # print(lookup)
    return res</code></pre>
<p>```</p>
                        </div>
                    </div>
                    
                    <div class="post-tags">
                        <span># Tags: </span>
                            
                                <a class="badge badge-primary" href="/tags/leetcode">leetcode</a>
                            
                                <a class="badge badge-primary" href="/tags/dynamic-programming">dynamic programming</a>
                            
                                <a class="badge badge-primary" href="/tags/python">python</a>
                            
                                <a class="badge badge-primary" href="/tags/algorithm">algorithm</a>
                            
                    </div>
                    
                    <nav class="post-related">
                            

    <a rel="prev" id="prev-btn" class="btn hvr-grow" href="/posts/2018/"> &laquo; 2018</a>


    <a rel="next" id="next-btn" class="btn hvr-grow" href="/posts/ml/svm2/">SVM(Part II) &raquo;</a>


                    </nav>
                    <footer class="comments">
                        <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "xfeif" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
                    </footer>
                </div>
            </div>

        </article>
    </div>
    <a id="rocket" href="#top" class=""></a>
<script type="text/javascript" src="https://blog.x-fei.me/js/totop.js"></script>
<footer id="footer" class='site-footer'>
    
    <section class="footer">
    
       🍓<a href="https://blog.x-fei.me">XFeiF</a> © 2015-2021 <i class="fa fa-heart" aria-hidden="true"></i>
    
    </section>
    <section>
        Theme Fx <a href="https://github.com/XFeiF" class="github-repo"><span class="gadget-github"></span>Star</a>
        Designed By <a href="https://github.com/XFeiF">@XFeiF</a>
    </section>
    <section class="poweredby">
        Powered by <a href="http://www.gohugo.io/">Hugo</a>
    </section>
</footer>

</body>
</html>
